<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年计划</title>
    <url>/2020/12/31/md/plan/2020/</url>
    <content><![CDATA[<h3 id="一-改掉坏习惯"><a href="#一-改掉坏习惯" class="headerlink" title="一 改掉坏习惯"></a>一 改掉坏习惯</h3><ul>
<li>戒掉网络小说</li>
<li>二周看一本书</li>
<li>每周至少三次锻炼</li>
</ul>
<blockquote>
<p>耐心和恒心总会得到报酬的</p>
</blockquote>
<blockquote>
<p>没必要透露自己的信息    </p>
</blockquote>
<blockquote>
<p> 虐人还是被虐就靠你的自驱力</p>
</blockquote>
]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>技术学习网站</title>
    <url>/2020/08/20/md/README/</url>
    <content><![CDATA[<p>记录各种学习笔记(算法、Java、数据库、并发……)<br><a href="https://github.com/ZXZxin/ZXBlog" target="_blank" rel="noopener">https://github.com/ZXZxin/ZXBlog</a>  </p>
<p><code>java成神之路</code><br><a href="https://www.hollischuang.com/archives/3280" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3280</a></p>
<p>本系列知识出自中华石杉，可以作为互联网 <code>Java 工程师进阶</code>知识完全扫盲<br><a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">advanced-java</a></p>
<p>这是一份Java学习指南，涵盖大部分Java程序员所需要掌握的核心知识<br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a> </p>
<p>本项目将LeetCode 上所有的题目都用动画的形式演示出来<br><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">LeetCodeAnimation</a>   </p>
<p>这是一个关于准备面试的项目，该项目包含了九大模块，从算法到操作系统、网络、面向对象以及数据库、Java、分布式、工具、编码实践。<br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a>  </p>
<p>【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。<br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
<p>ppt与演讲表达</p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>长大后，你发现什么样的人不能深交？</title>
    <url>/2020/06/09/md/life/make-friend/</url>
    <content><![CDATA[<p>这7类人，摊上任何一个，都会把你的平静的生活，搅碎。全部读完，可以让你避免80%的人际雷区。</p>
<h3 id="1、缺少同理心的自我中心主义人"><a href="#1、缺少同理心的自我中心主义人" class="headerlink" title="1、缺少同理心的自我中心主义人"></a>1、缺少同理心的自我中心主义人</h3><p>永远把自己的需求和感受，放在第一位，这种人想必大家都深有感触，深受其害。</p>
<p>比如，</p>
<p>团建组织一起吃饭，问大家吃啥，TA肯定先发言，“不吃辣，不吃蒜，不吃香菜，不吃这个，不吃那个”，然鹅你还没有问到TA。</p>
<p>你跟这种人聊天，TA比比赖赖的总能扯到自己这边。</p>
<p>你跟TA聊疫情，TA说不出门。<br>你跟TA聊天气，TA说不出门。<br>你跟TA聊工作，TA说不出门。<br>总之，你的话基本等同于放屁，TA可以完全忽视你，自言又自语。</p>
<p>前段时间，黄晓明在《中餐厅》的表现，非常能证明这点。网友甚至调侃，总结这些语录为《明学》。</p>
<p>最有名的就是这句：</p>
<p>在杨紫觉得手指受伤不用去医院的时候，黄店长说：我不要你觉得，我要我觉得！你觉得不管用，我觉得管用好吗？</p>
<p>平时生活中，有个这样的朋友，你可以躲着走。不过，职场上你领导要是这种人，真让你喝一壶。</p>
<p>我13年，工作的时候，一个老领导，老哥一个离婚了。</p>
<p>每天，上班特别早，晚上回去特别晚。</p>
<p>人家早走，他还不愿意。</p>
<p>我们基本加班，都是在晚上9点。</p>
<p>他非要搞到11点，不准大家走。</p>
<p>有人早走，第二天来了准挨批。</p>
<p>这种人不但自我中心，还缺乏同理心。</p>
<p>你没有家，还不让人早回家。</p>
<p>我忍受了半年，就离职了，跟他混等于耗尽生命，还不给你加薪，你说不走图啥？</p>
<p>这种人就是幼稚不成熟，以儿童视角观察世界，观察人。</p>
<p>心理学家皮亚杰，认为这种人心里成熟度就只有6、7岁大，没有把自我和外部世界分开。</p>
<p>如果你遇到自我中心，并且还缺少同理心的人，赶紧让他们滚上一边待着去，跟他们打交道，等同于浪费生命。</p>
<p>看到这里的你，别忘了点个赞嘛，如果没有大段时间看下去，可以点赞码住慢慢看，点赞也会加深自己的记忆点，不容易让自己快速遗忘的。</p>
<h3 id="2、隐忍情绪的理性超人"><a href="#2、隐忍情绪的理性超人" class="headerlink" title="2、隐忍情绪的理性超人"></a>2、隐忍情绪的理性超人</h3><p>这种人对谁都好。只要大家一谈起他，都会在心里默念一个“好”。</p>
<p>从没有人看他们发脾气，简直就是超人。</p>
<p>表面上看一切还好，但就是感觉哪里不对。</p>
<p>人吃五谷杂粮，有七情六欲。</p>
<p>可是他们只给你看到一面，异常理性的一面。</p>
<p>让你深看不透，脊背发凉。</p>
<p>我接触过一个案例：</p>
<p>我现同事，他宿舍有一个哥们，一起合租离公司近。每天上下班，一起，但从不聊天。</p>
<p>你不知道他爱好，不知道他想法，总之很努力工作。就这样，过了1年多，基本上没什么深交。</p>
<p>这哥们突然管他借10万块钱，说家里房子着火了，急用。我这同事也好心，就把存款借给他，也没立什么字据。</p>
<p>谁能想到，就这些钱，这个人第二天人间蒸发了。微信不回信，手机打不通，哪哪找不到。</p>
<p>你说吓人不吓人。</p>
<p>人有七情六欲，这种人连情绪都无时不刻的在控制，什么控制不了呢。</p>
<p>或者根本就是没有感情的理性人，非常可怕。也就是说，在他们那边全是套路。</p>
<p>假如，你和这种人谈恋爱，他们像冰一样，你怎么焐热呢？</p>
<p>珍爱生命，远离理性超人。</p>
<p>其实，只要敢爱敢恨，适当去表达自己的喜怒哀乐即可。就比如，你喜欢这个答案，那就点一个赞，表达你的欢喜，就这么简单。</p>
<h3 id="3、损人不利己，击穿道德底线的人"><a href="#3、损人不利己，击穿道德底线的人" class="headerlink" title="3、损人不利己，击穿道德底线的人"></a>3、损人不利己，击穿道德底线的人</h3><p>损人不利己，这句话出自鲁迅，“《书信·致曹聚仁》：“只有损人而不利己的事，我是反对的。”</p>
<p>你说吧，损人利己，这事还情有可原。可以解释得通，为了生存，为了自己的美好生活，为了理想，为了xxx。</p>
<p>咱们的祖先，打打杀杀抢地盘，抢资源，抢钱，抢人，都是为了生存，或者生活的更好。</p>
<p>现代社会进入文明社会，那方法和手段变了而已，企业竞争，人与人岗位竞争等等，依然是抢夺，难免会损人利己。</p>
<p>更高级的一点就是，利他利己，但多数竞争之间还是损人利己。</p>
<p>情有可原是吧。</p>
<p>损人不利己，这就很难解释了。</p>
<p>比方说，我小学5年级的时候，一个好朋友，平时玩的都很好。有一天中午，我们两个吃完饭，早早到学校，在班级里逛来逛去。</p>
<p>我眼睁睁的看他，走到一个同学的座位上，一甩手把同学的削笔刀扔出窗外。那削笔刀以盘旋的舞姿，迅速的砸向了玻璃，咔嚓一声，玻璃碎了。</p>
<p>我蒙了，那同学和他无冤无仇，玻璃跟他更没有仇了。原谅，我胆小，我没有给他告老师。后来，我和他绝交了，渐渐疏远了。</p>
<p>损人不利己是单纯的坏。</p>
<p>法律不管的事，道德可以管，道德不管人心管。人心如果是单纯的坏，真的没有什么可以阻挡了。</p>
<p>他们可以义无反顾，做出任何伤害你的事，还毫无愧疚之心。</p>
<p>所以，你身边要是有这样的人，你是不是该远离呢？</p>
<p>修身养性，明辨是非很重要！</p>
<h3 id="4、总是传递负能量爆棚的人"><a href="#4、总是传递负能量爆棚的人" class="headerlink" title="4、总是传递负能量爆棚的人"></a>4、总是传递负能量爆棚的人</h3><p>这种人，典型的特点就是，爱抱怨。</p>
<p>放在微博上，就是杠精。</p>
<p>凡事都只有一个方向，坏事。</p>
<p>他们的困境是，“没能力解决现状，只知道愤世嫉俗的人”。并且，和这种人做朋友，你看他们朋友圈，你就已经够累了。</p>
<p>李笑来在《财富自由之路》里，也提到过这种人，爱抱怨。</p>
<p>抱怨最大的坏处——它不解决任何问题，却像麻醉剂一般，松懈掉正面问题的努力，满足于对问题本身的沉溺。</p>
<p>反正我身边这种人，我微信直接拉黑，生活和工作都会远离。</p>
<p>这种我根本不想多和他们说一句话，本来生活就很艰难，自己给自己打气，鼓劲，刚刚鼓足了劲，正能量慢慢，他们就给你泄气。</p>
<p>你说这种感觉，是不是很糟糕呢？</p>
<h3 id="5、缺少长期自控力的人"><a href="#5、缺少长期自控力的人" class="headerlink" title="5、缺少长期自控力的人"></a>5、缺少长期自控力的人</h3><p>这第五种人，本身人畜无害。</p>
<p>说实话，咱们根本没必要远离啥的。</p>
<p>为什么要又要单独放在这里呢。</p>
<p>“天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行制拂乱其所为，所以动心忍性，曾益其所不能。”</p>
<p>但凡想要获得成功的人，都必须得付出极大的努力，内心也要经受摧残。不然，大家都是人，凭啥你牛逼。</p>
<p>还有句老话说的好，“人往高处走，水往低处流”。如果你身边都是和你水平一样的人，那你的工资基本上就是大家的天花板。</p>
<p>你的能力就是大家的水平线。</p>
<p>一个好汉三个帮，要想自己不那么累，就得积累人脉。咱们不说一直结交高级人脉，攀高枝，但咱们也不能一直突破下线吧。</p>
<p>生活又不是扶贫，谁都不容易，朋友之间资源互相，说白了也就是“交易”。</p>
<p>所以，身边尽量少几个，你要减肥，TA要和你吃大餐。你要读书，TA要和你玩游戏。你要工作，TA要和你去旅游。</p>
<p>砍柴的和放羊的，有时候可以是朋友，有时候就是敌人。关键看你怎么拿捏。</p>
<p>说起自控这事，不是一般的难。三分钟热度一过，该颓废就颓废。比如，前脚刚卸载王者，后脚马上就安装起来。刚说戒烟，回手就是一根。老韩对自律这块的研究，也有几年时间，跑步、读书、写作、创业，哪一项都需要自律。我研究出一套，无痛无压的自律法，一经发布有10万人点赞。如果你也很困扰，自律不起来，可以来我的公众号【老韩大叔】看看，包你满意，我整理了100多篇文章。篇篇颠覆你的认知。我在【老韩大叔】等你，一定要来看看。绝不会让你失望。</p>
<h3 id="6、打着为你好的旗号，满足自己控制欲的人。"><a href="#6、打着为你好的旗号，满足自己控制欲的人。" class="headerlink" title="6、打着为你好的旗号，满足自己控制欲的人。"></a>6、打着为你好的旗号，满足自己控制欲的人。</h3><p>在恋爱里非常多见。什么都是为你好，只要不听我的，就是你不好。</p>
<p>我经常会听到，你要早起、你要自律、你要努力过完美的人生。</p>
<p>那什么样的人生是完美的，是不是该自己定义呢。</p>
<p>小时候，父母告诉我们，要好好学习，天天向上。</p>
<p>长大了，老师告诉我们，考第一考研究生，找好工作。</p>
<p>你不听，他们就会骂你不懂事，为你好都听不懂。</p>
<p>谈恋爱了，你的那个Ta告诉你，要按照Ta的意思做事，要多喝热水，多吃青菜，为你好。</p>
<p>你不喜欢，你喜欢有自我的安排。</p>
<p>你知道所有这些人，都可能是为你好，但不是你想要的生活。</p>
<p>这种人可能无法远离，但请你保持自己，自我和自由才是生命永恒的意义。</p>
<p>7、喜欢否定别人，批评别人的人。<br>生活压力大，竞争压力大。</p>
<p>每个人都会有失控，失去自信的时候。</p>
<p>有时候你特需要一句安慰的话，和一句鼓励的句子。</p>
<p>可身边往往也有这种人，你说你行，他说你不行。</p>
<p>你说你做的还可以，他说你做的是垃圾。</p>
<p>你说你很努力，他说你还没有努力到无能为力。</p>
<p>摆脱，在这脆弱的时刻，能不能安慰下人。</p>
<p>人是社会性动物，根本离不开人际，更需要得到别人的认可。</p>
<p>我之前一个下属，由于公司规划调整，换到一个新领导那边。</p>
<p>新领导每天什么事都不做，只做一件事，就是不断打压他。</p>
<p>说什么都做的不好，反复返工和修改，令人怀疑人生。</p>
<p>随意打压和批评别人的人，是恶魔，不尊重人。</p>
<p>这种人，会让你的人生像一潭死水，毫无生机。</p>
<p>建议让他滚蛋。</p>
<p>最后，老韩总结一下，这里一共介绍了5类人。最雷人最影响生活的就是负能量的人；最危险的就是损人不利己的人；最讨厌的就是没有长期自控的人，总会让你帮忙；最让人恐惧的就是隐忍情绪的理性超人；最难相处的就是自我中心主义的人。</p>
<p>老韩已经给你分辨的方法了，只要对号入座即可，远离雷人，生活更美好。</p>
<p>离开之前，留下你的双击点赞，一起真心交个朋友。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>人生必须明白的几条道理</title>
    <url>/2020/06/09/md/life/best-practice/know-what/</url>
    <content><![CDATA[<h3 id="人生必须明白的几条道理"><a href="#人生必须明白的几条道理" class="headerlink" title="人生必须明白的几条道理"></a>人生必须明白的几条道理</h3><ul>
<li>1钱，就像内裤，你得有，但不必逢人就证明你有。</li>
<li>2干事业，就像怀孕，得够月，着急了容易流产。</li>
<li>3你若成功了，放屁都有道理</li>
<li>4你若失败了，再有道理都是放屁</li>
<li>5不要随便把自己心里的作品晒给别人看，因为这个世界上你根本就分不清，哪些人给你撒的是云南白药，哪些人给你的是辣椒咸盐……</li>
<li>6这世界上没有人能真正帮到你，除了自己。别人帮了你，就是情分，不帮才是本分。</li>
</ul>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>油腻中年男子</title>
    <url>/2020/06/04/md/life/best-practice/idot-portly-feature/</url>
    <content><![CDATA[<p>01.肚子凸起，大腹便便<br>02.整天干吹牛<br>03.停止学习<br>04.一脸色相，整天讲黄段子<br>05.成天叨叨过去的事<br>06.动不动以长辈状教育晚辈<br>07.经常性地求人帮忙<br>08.不修边幅，邋邋遢遢<br>09.亳无激情，没有了半点朝气<br>10.一身奴性，卑躬屈膝<br>11.浑身透着虚伪<br>12.总幻想自己是女人眼中迷人的碾人士</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>极简生活攻略</title>
    <url>/2020/06/04/md/life/best-practice/simple-life/</url>
    <content><![CDATA[<ul>
<li>简单穿衣，不花哨</li>
<li>控制购买欲，不乱买</li>
<li>一旦是必用品，就买最好的，并充分使用</li>
<li>每天只专注做一件事，努力做到最好</li>
<li>抽出时间独处</li>
<li>享受慢节奏</li>
<li>远离无效社交</li>
<li>做自己喜欢做的事儿</li>
</ul>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>做一个精致的男性</title>
    <url>/2020/06/01/md/life/being-well/</url>
    <content><![CDATA[<p>1戒掉传统手艺<br>2尽量不要熬夜，真的会猝死<br>3养成习惯，早睡早起<br>4永远做两件不会过时的事情：读书，健身<br>5别做添狗，舔到最后真的一无所有，即使得到，也是短暂的<br>6二十多岁的年纪，赚钱才是第一位。当你有了钱，自然什么都会有，包括，爱情，亲情。不相信的，大多是还不愿意面对现实的人</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>关于聚餐</title>
    <url>/2020/06/01/md/life/diet/being-well/</url>
    <content><![CDATA[<blockquote>
<p>千万戒掉,去一次,半个月费了,真的!</p>
</blockquote>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>减肥</tag>
      </tags>
  </entry>
  <entry>
    <title>各肉类脂肪含量</title>
    <url>/2020/06/01/md/life/diet/meat-fat-num/</url>
    <content><![CDATA[<p>1 猪肉:脂肪含量29%<br>2 羊肉:脂肪含量24%<br>3 牛肉:脂肪含量12%<br>4 鸭肉:脂肪含量7.5%<br>5 鸡肉:脂肪含量6%<br>6 鱼肉:脂肪含量1.5%<br>7 兔肉:脂肪含量0.4%</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>减肥</tag>
      </tags>
  </entry>
  <entry>
    <title>成年人高情商的20个表现</title>
    <url>/2020/05/17/md/other/good-eq/</url>
    <content><![CDATA[<h3 id="成年人高情商的20个表现"><a href="#成年人高情商的20个表现" class="headerlink" title="成年人高情商的20个表现"></a>成年人高情商的20个表现</h3><p>1.见到女同事，多夸漂亮准没错。<br>2.别人自嘲，千万不要附和。<br>3.同事犯错，最好私下里提醒一下。<br>4.办公室同事说话没有人接，你接一下，对方会感激。。<br>5.办公室分享食品，一定是见者有份。<br>6.没有人喜欢被批评，实在要批评，先肯定再批评。<br>7.不在背后说人坏话。<br>8.不要在经济上贪别人便宜。<br>9.同事不要闹得太僵，再不喜欢面上也要过的去。<br>10.不要为无意义的话题争论到伤了和气。。<br>11.请人帮忙，别人没有直接答应就是拒绝。<br>12、不说别人的缺点。没有人喜欢别人说自己的缺点，哪怕他再不堪。<br>13、不会交浅言深，认识几天就什么都说，日久见人心。<br>14、拒绝别人越干脆，越不会得罪人。<br>15、能用钱解决的事，就别用人情来解决，因为人情难还。<br>16、答应别人的事，不管是否能做到，一定有回音。<br>17、不要四处炫耀，真希望你好的人不多。<br>18、不要总是试图证明自己是对的，自己多博学，只会招人反感。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>增进情侣之间的感情</title>
    <url>/2020/05/16/md/life/flirt/increate-yours/</url>
    <content><![CDATA[<p>这个话题能增进情侣之间的感情</p>
<p>1聊一聊初次见面的印象<br>2什么时候开始喜欢对方<br>3聊聊双方的爱情观<br>4分享童年往事<br>5制定爱情规则<br>6分享兴趣爱好<br>7聊一聊在一起之后一定要做的事情<br>8聊聊共同的未来规划</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>为何和女生聊不嗨</title>
    <url>/2020/05/16/md/life/flirt/chat-not-well/</url>
    <content><![CDATA[<p>和女人聊天你要抓住她的心里，她最喜欢听的是什么话题，你要勾起他的好感</p>
<blockquote>
<p>如果她不喜欢你，你说什么也是无济于事的，</p>
</blockquote>
<p>为什么聊不嗨？你该问问自己过得什么生活！<br>一个有趣的人，他必然腹中有货，言之有物，并且与人交流带着思想的火花。<br>这种人聊吃的，天南地北说的出味道，街头巷尾知道哪里可寻觅美食;聊玩的全球各地都留下足迹，所到之处都有故事；聊天下大事，他深刻洞察，见地新颖，谈吐不凡，似乎乾坤历史都在掌握；聊读书，他博览群书，又不读死书，典故诗歌信手拈来；玩乐器，他抱起吉可以唱民谣，坐在身子可以谈月光曲。<br>试问，这样的人能不能聊嗨？<br>那些聊不嗨小男生，要么是性格内向封闭，要么是自卑沉默，归根到底是没有见识，没有阅历，没有什么值得分享的经历。</p>
<ul>
<li>请问，天天吃鸡，空下来就王者农药，能谈什么？</li>
<li>请问，只看遮天，斗破，玄幻小说，除了说两句狂话，能聊什么？</li>
<li>请问，一百年不看书，要看只看动漫书，你能聊什么？</li>
<li>请问，山川原野从来不屑远行，躲在家里能聊什么？</li>
<li>请问，读书不努力，落榜进工厂，流水线上你能聊什么？</li>
<li>请问，财经新闻，天下大事不关心，八卦花边津津乐道，你能聊什么？</li>
<li>请问，闲暇时间不去广结良友，天天和酒肉朋友撸串喝酒，醉生梦死，你能聊什么？</li>
</ul>
<p>和女生聊天，其实是考验一个人的积累和修炼，能够脱单的人必然有优秀之处，单身狗半天掐不出一个屁，那就要好好反省，自己有多偷懒。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>相亲</title>
    <url>/2020/05/16/md/life/flirt/blind-date/</url>
    <content><![CDATA[<p>相亲定律: 不回信息就说明没戏了，你也没必要联系他了。他如果是跟你说清楚为什么不合适，也是一种伤害吧，绞尽脑汁的委婉拒绝是一种方式，直接不联系也是一种方式，总之不要太在意这些方式，相亲成功的几率本来就是相当低的，没次都要想这么多，不是很累吗？</p>
<p>直接把这一类(聊天不主动，约会不主动，各种不主动)女孩归为渣女还是不太妥当。我想深层次的原因可以归结为中国人的中庸之道，大多数中国人的三观中是不会认同直接拒绝别人这种言行的。面对自己不太满意的人事物，他们要么不作为要么冷不丁回一句不痛不痒的话，只有极少数人才会毫不忌讳地讲出自己的想法表明态度，尤其相亲这件事表现尤为明显。所以希望男同胞们对于这类女孩可以直截了当地问对方想法，大老爷们儿别遮遮掩掩的，也希望女同学们也出于对双方负责的目的勇于表达自己的态度，别他妈以什么慢热来搪塞男方，有感觉就适时传递给男方，没感觉趁早说明。</p>
<p>或许我能理解一点这个妹子的举动，我每次和相亲的在一起也是各种拘束，是真的慢热，不是找个理由说说而已，对方总说我特别淑女不爱说话，其实我内心mnp，还不是跟你不熟嘛，在外人面前我一直都这种形象，处了两三年的朋友才知道我私下有多闷骚……还有，答主开始对妹子也不是很热情啊，你要知道对于一个女生来说主动联系相亲对象需要多大的勇气，至少对我来说是这样的。所以我现在很烦相亲，能不见的就不见，我就不信两个压根儿不认识的人一见面能撞出什么火花来。</p>
<p>了解女生需求<br>把握氛围<br>不要让理性主导<br>周期不益拖超过2个月</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>有哪些你追了很多女生才明白的道理？s</title>
    <url>/2020/05/16/md/life/flirt/konw-what/</url>
    <content><![CDATA[<p>1、你对对方好，不要认为对方一定要以同样的方式对你。</p>
<p>（你的付出得不到回应是正常的，要放平心态，投资也不都是赚的，理性看待，因为你赢一次就够了）</p>
<p>2、不要因为对方的一句话，或者没回你信息患得患失。</p>
<p>（不要脑补过多的信息，她不回你就等着别在联系了，或者可以隔天继续联系）</p>
<p>3、不要强制社交，二人之间关系是一步一步升级来的，开始不要说越级的话，以及越过你们现有关系的关心。</p>
<p>（其中送贵重礼物和有寓意的礼物就是强制社交，而吃饭没有，早点睡觉，多穿点衣服都是越级聊天）</p>
<p>4、追求的过程，自认为付出很多，自我感动在对方看来是最招人烦的，所以别付出太多，多投资自己。</p>
<p>（这个是真的烦，因为别人真没让你去付出，既然付出了就要输的起，输不起的人别人同样看不起）</p>
<p>5、不要暴露自己过多的需求感。</p>
<p>（需求感太多，你的价值就没了，同时你的进攻还会让对方压力过大，压力大了对方就想逃离你）</p>
<p>6、在语言和动作你感觉不到你在ta心中和别人有什么不一样之处，那就是不喜欢你，性格慢热等都是借口。</p>
<p>（追求初期不喜欢你是正常的，不用过于沮丧，如果追了很久还是这样，那就换人吧）</p>
<p>7、不要表白，不要表白，不要表白，表白是水到渠成后二人之间的契约，不是冲锋的号角。</p>
<p>（你表白一个不喜欢你的人，或者你们的关系，还没到能够完全接受你的人，等于就是逼着对方拒绝你啊。确定关系在平时的肢体接触以及言语上，大致就已经确定关系了，表白只是盖章）</p>
<p>8、远离和你价值观，生活习惯相差太大的人，哪怕就是在喜欢，也要快刀斩乱麻。</p>
<p>（这个懂的人自然懂，喜欢如果没有价值观上的认同，这种喜欢一定是以悲剧结尾）</p>
<p>9、你们有点暧昧后，三次约不出来基本可以放弃，不要相信任何借口。</p>
<p>（愿意给你机会的，真有事也会想着下次补偿你，很难出现三次都约不出来的情况）</p>
<p>10、时常审视一下你们之间的关系，如果你感觉自己有点舔狗的味道了，那么请先冷落对方几天，在决定还要不要追。</p>
<p>（冷落对方，是为了重新找回自己的价值，同时冷落的几天，也是让你去掉喜欢对方的这个因素，从性格品行来看在决定要不要追）</p>
<p>11、追求时不要把自己位置摆的太低，摆的越低越没有机会，尽量维持平等原则，对方是在找另一半，不是在找舔狗。</p>
<p>（没有谁喜欢卑微的人，哪怕你原本价值不低，可能如果把自己摆的位置永远比对方低，那你在对方眼里价值就是不如对方，只能当只舔狗了）</p>
<p>12、摸清对方段位这个很重要，追低段位和高段位是完全不一样的追法</p>
<p>（低段位来说一般对对方好好就OK，高段位则比较复杂，如果对方高段位且是个比较善良的人，有时候则不需要那么多套路，死皮赖脸一些，对方不讨厌的方式真诚对对方好，也可以搞定，搞不定当在高手这吸取经验了，在日后的道路可以帮你避开绝大多数渣女）</p>
<p>13、女人随着年龄的增长，和男人的从一而终（脸和身材）不同，女人的择偶需求是慢慢变化的，开始是长相，后面会向情绪价值倾斜，最后则是品质和稳定的生活。</p>
<p>（这是天生的，是一种生理上的差异，主要因为男人的安全感更具有主动性，女人的安全感多数比较被动）</p>
<p>14、送礼物不要瞎送，要送对方需要的，如没摸清楚那就别送，别傻逼逼的去问对方。没确定关系之前，不要送太贵重礼物，也别送太多礼物，一般来说最多三次。</p>
<p>（求求你们刚追一个女生别在送花了，我都不想吐槽了，这万恶的电视剧和小说）</p>
<p>15、没能力提升对方情绪价值，那就先压低对方情绪价值，之后在让对方情绪价值回到原来位置，效果其实差不多。</p>
<p>（解释起来，就是先降低对方期待感，然后再给惊喜）</p>
<p>16、高傲大多都是摆给自己不喜欢的人看的，自己喜欢的，瞬间变成乖巧的小猫咪。</p>
<p>（和喜欢的人是高冷不起来的，因为喜欢人的认同，你会很开心，藏不住）</p>
<p>17、爱情在一定程度上就是利益的结合，比你高阶层的女人，你如果连提高她们情绪价值的能力都没有，那就可以少做些白日梦了。</p>
<p>（知道以前那些玩pua的为什么要五星级酒店，豪车游艇吗？因为价值或者树立一个高价值去骗，世俗上的价值差太多，又没有能力从为人的深度上去弥补，那就真的别做白日梦了）</p>
<p>18、追不上就换一个，别当备胎，备胎的命运是很凄惨的，就算有那么几个幸运的备胎转正，对方也只是没得选了，将就而已。</p>
<p>（为人在世请尊重自己，你自己如果都不尊重自己，你还想有人尊重你吗？）</p>
<p>19、爱情中最难的不是追求，而是怎么稳定好一段长久的亲密关系，所以追求之前先考虑，自己有没有本事稳定长久的亲密关系，如果答案是否定的，建议换人。</p>
<p>（稳定是真的比追求更难，尤其是一个和你不合拍的人，追求之前请一定看长远，考虑清楚，不然你的择偶成本会被无限放大）</p>
<p>20、一段良性的恋情，从出发点开始一定不能有见不得人的勾当，且男女要互相付出。</p>
<p>（长久亲密关系就跟建房子一样，追求的过程是打地基，男方的付出等同于一块块砖头，女方的付出是给墙加固的水泥，不正当的追求方式，等同于地基没打好，房子到了一定程度会轰然倒塌，只有男方一直付出，砖头累加到一定程度，没有水泥固定，墙一样会倒，如单女方付出，没有男方参与，墙砌不起来）</p>
<p>21、一段追求的过程中，提高自己，增加自己的核心竞争力远比把时间花在对方身上，更有用更划算。</p>
<p>（时间花对方身上一定程度上是降低在她眼里你的价值，而花在自己身上永远都是提高自己的价值，你觉得哪个更有用呢？）</p>
<p>22、做好可能追不上的准备，别一定非谁不娶，只是暴露了你的幼稚和偏执。</p>
<p>（追求和投资一样，赚钱了你开心要死，赔钱了你说对方骗子，让对方赔钱，你觉得别人怎么看你？）</p>
<p>23、大多被追求者，都不喜欢追求者弄的人尽皆知。</p>
<p>（人家对你没那么喜欢，或者人家压根就不喜欢你，你这种行为就是在变相的道德绑架，挺烦人的）</p>
<p>24、展示高价值，不要一股脑显摆完，要循环渐进，最好能让对方感到惊喜和意外。</p>
<p>（一股脑显摆是一个很low的行为，成了炫耀，炫耀是小孩子才做的，高价值只有顺其自然的展示，才能打破对方预期，达到你想要的效果，才没有那么低龄化）</p>
<p>25、虽喜欢对方但必须有不可逾越底线。就是在喜欢的人，也不能让对方随意过线。</p>
<p>（你没了底线，对方只会看不起你，你有底线说明你是一个有原则的人，才能赢得别人尊重）</p>
<p>26、明确告诉你不喜欢你的，就别追了，越追越没希望，可以先断连，后提升自己，造成二次吸引，反而倒是可能性会大一些。</p>
<p>（明确告诉你了，你的行为就是骚扰，还是那句话，你不尊重自己，体面都丢了，你以后拿什么再次站在她面前？）</p>
<p>27、开始就用不光彩的手段，获得的爱情，那不叫爱情，因为首先你已经践踏了爱情，所以你也不配拥有爱情，详情请参考20条。</p>
<p>（不光彩手段是一个定时炸弹，因为它突破了为人的道德底线，但凡有原则的人，只要知道了，都无法在接受你）</p>
<p>28、追求对象请尽量是自己横向价值的，而并非纵向价值内的对象。</p>
<p>（横向价值是同阶层不同职业，纵向价值是跨阶层）</p>
<p>29、两性关系捡漏的情况一般只发生在校园，步入社会后基本不可能存在的。</p>
<p>（因为只有校园会把不同阶层的人拉倒同一阶层）</p>
<p>30、每一项能力都很平庸，远没有一项能力优秀，其它稍差有吸引力。</p>
<p>（一项优秀的能力，就是你的才华，要相信才华在一定程度上可以让对方忽略掉，你的一些不太理想的地方）</p>
<p>31、不是百分百确定对方也喜欢你，就别当众表白，这纯属于道德绑架，这种行为不但幼稚，还会让对方不舒服很难做人。</p>
<p>（对于观众来说，观众大多想看一个圆满的结果，如果她拒绝，她就把自己天然树立在和观众敌对位置，而且观众对于她的不满，她是会在心里把这笔帐算在你身上的）</p>
<p>32、在你为对方付出后，用技巧稍稍引导让对方为你付出一些，比一直为对方付出，更能加快追求的进程。</p>
<p>（比如你请对方吃饭，吃完饭后让对方买个冰淇淋，或者你在帮对方进行体力上的劳动，就可以让对方给你倒杯水，要记住这些付出虽很小，但一定要让对方也有所付出，付出要有来有回，别光是你在那付出）</p>
<p>33、决定追求目标后，记得先审视一下你和对方，收入、学历、长相、家庭、职业、情绪价值（情商）、或一个优于绝大多数人的特长、起码你得有一样优于对方吧，否则请放弃这个大胆的想法。</p>
<p>（只有价值匹配，才不至于让人感觉很卑微，或者下意识在她面前流露出的卑微，而卑微是没有希望的）</p>
<p>34、男人不要眼里只有恋爱，眼里只有恋爱的男人最终反而守护不了这份感情。</p>
<p>（古代那些不爱江山爱美人的亡国之君，你好好数数有多少）</p>
<p>35、恋爱知识懂得再多，也只是能帮你搞定阶层相差不大的对象，如要追求自己理想中的那个人，还是得提升内在的核心竞争力。</p>
<p>（价值上差太多是追不上的，因为对方天然在心态和价值上，就甩你N条街，同时人家开着宝马，你骑个小破自行车，你告诉我怎么追？）</p>
<p>36、当你决定追一个人，对方大概率是知道的，女生对于这方面更为敏感，只要人家不挑明，你就别挑明。</p>
<p>（对方如果挑明了：你是在追我吗？</p>
<p>你大可以回：那要看你给不给机会，我才能做出决定）</p>
<p>女生处于废物测试心理有些会挑明，看你回答给你打分！</p>
<p>37、别追的太紧，追的太紧会让对方特别没有安全感。</p>
<p>（越是上门推销自己产品有多好的，你其实越怀疑对方产品质量）</p>
<p>38、聊天要懂得升级，不然当你们无话可说时，就成了聊久凉。</p>
<p>（一般来说一个星期必须升级，一个月不升级的基本可以不用追了）</p>
<p>39、连续发两条以上的消息，对方如果不回就等等吧，别急着发第三条了。</p>
<p>（还是那句话，尊重和体面）</p>
<p>40、这一条是核心：</p>
<p>追是小心翼翼照顾你的情绪对你好，撩则比较随心所欲，其定义大概是指，只对你一人，在一定程度上展示自己高价值，从而达到吸引你的目的。</p>
<p>追和撩二者不属于一个层次，对于喜欢的对象要撩，不要追！</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>午睡</title>
    <url>/2020/05/16/md/other/day-sleep-and-alone/</url>
    <content><![CDATA[<p>如果一个人住，<br>千万不要在下午时睡午觉。</p>
<p>因为，<br>等你一觉睡到六七点，<br>等你一睁开眼，<br>看着朦胧泛黑的天空，<br>看着空荡荡的房间，<br>会有一种被全世界遗弃的感觉。</p>
<p>孤独，<br>在这一刻，<br>体现的淋漓尽致。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>4条撩妹规则</title>
    <url>/2020/05/16/md/life/flirt/four-advise/</url>
    <content><![CDATA[<h4 id="1，不要问女生：我能不能牵你的手？"><a href="#1，不要问女生：我能不能牵你的手？" class="headerlink" title="1，不要问女生：我能不能牵你的手？"></a>1，不要问女生：我能不能牵你的手？</h4><p>相信我，你得到的答案肯定是拒绝。<br>女生天生羞涩，让她回答“好啊”，你知道是有多么难说出口吗？<br>如果，男生想牵女生的手，就需要自己判断准确的时机，然后，主动牵起女生的手，这样就好。</p>
<h4 id="2，跟女生表白，就有被拒绝的风险，所以，一般现在男生都不表白-，这样就没有风险。"><a href="#2，跟女生表白，就有被拒绝的风险，所以，一般现在男生都不表白-，这样就没有风险。" class="headerlink" title="2，跟女生表白，就有被拒绝的风险，所以，一般现在男生都不表白,，这样就没有风险。"></a>2，跟女生表白，就有被拒绝的风险，所以，一般现在男生都不表白,，这样就没有风险。</h4><p>最安全的追女生方式是：当两个人的相处就像男女朋友一样，再给女生一个承诺，这样也是确定关系的一种方式。</p>
<h4 id="3，女生总喜欢说“随便”，但是，男生如果没有安排好，女生就会不开心。"><a href="#3，女生总喜欢说“随便”，但是，男生如果没有安排好，女生就会不开心。" class="headerlink" title="3，女生总喜欢说“随便”，但是，男生如果没有安排好，女生就会不开心。"></a>3，女生总喜欢说“随便”，但是，男生如果没有安排好，女生就会不开心。</h4><p>男生：明天出去玩，你想吃什么？<br>女生：随便。<br>隔天，男生见到女生，还在纠结去哪里吃饭，女生就肯定会不开心。</p>
<blockquote>
<p>女生的“随便”，意思就是你要安排好。</p>
</blockquote>
<h5 id="4，在女生有情绪的时候，不要跟女生讲道理，不要想着如何解决问题？"><a href="#4，在女生有情绪的时候，不要跟女生讲道理，不要想着如何解决问题？" class="headerlink" title="4，在女生有情绪的时候，不要跟女生讲道理，不要想着如何解决问题？"></a>4，在女生有情绪的时候，不要跟女生讲道理，不要想着如何解决问题？</h5><p>当一个女生有情绪的时候，你跟她讲任何事情，她都不会听得进去。<br>所以，在女生生气的时候，男生最应该做的是：先安抚好女生的情绪，然后，再去想解决办法。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>线程生命周期</title>
    <url>/2020/05/05/md/jdk/mulThread/thread-cycle/</url>
    <content><![CDATA[<p><img src="https://www.mqiy.xyz/image/jdk/thread-lifecycle.png" alt="thread-lifecycle.png"></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手</title>
    <url>/2020/05/05/md/part/web/http/three-shake-hand/</url>
    <content><![CDATA[<h3 id="三次握手示意图"><a href="#三次握手示意图" class="headerlink" title="三次握手示意图"></a>三次握手示意图</h3><p><img src="https://www.mqiy.xyz/image/http/three-shake-hand.png" alt="three-shake-hand.png"></p>
<h3 id="两次握手存在的问题"><a href="#两次握手存在的问题" class="headerlink" title="两次握手存在的问题"></a>两次握手存在的问题</h3><p><img src="https://www.mqiy.xyz/image/http/two-shake-hand-problem.png" alt="two-shake-hand-problem.png"></p>
<h3 id="低三层协议"><a href="#低三层协议" class="headerlink" title="低三层协议"></a>低三层协议</h3><p><img src="https://www.mqiy.xyz/image/http/internet-three-layer.png" alt="internet-three-layer.png"></p>
<h3 id="http数据包格式"><a href="#http数据包格式" class="headerlink" title="http数据包格式"></a>http数据包格式</h3><p><img src="https://www.mqiy.xyz/image/http/http-data-package.png" alt="http-data-package.png"></p>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2020/04/24/md/jdk/re/</url>
    <content><![CDATA[<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>1.什么叫反射</p>
<p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</p>
<p>对于任意一个对象，都能够调用它的任意一个方法和属性</p>
<p>这种动态获取信息以及动态调用对象的方法的功能称为java语言的反射机制</p>
<p>2.反射的优点：</p>
<p>反射提高了程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创和控制任何类的对象，无需提前硬编码目标类</p>
<p>3.反射的缺点</p>
]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手</title>
    <url>/2020/04/23/md/part/web/http/http/</url>
    <content><![CDATA[<p>双方都需要确认对方收到了自己的序列号</p>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2020/04/23/md/jdk/thread-pool/</url>
    <content><![CDATA[<p>1、线程池的学与思；<br>2、使用线程池的好与不好；<br>3、为什么阿里开发手册建议自定义线程池；<br>4、自定义线程池的最佳实践；</p>
<p>线程池类型与应用场景：<br>      1）CachedPool<br>      2）FixedThreadPool<br>      3）ScheduledPool<br>      4）WorkStealingPool<br>      5）ForkJoinPool</p>
<p>线程池类型</p>
<p>newCachedThreadPool<br>newFixedThreadPool<br>newSingleThreadExecutor</p>
<p>newScheduleThreadPool<br>newSingleThreadScheduledExecutor</p>
<p>Java提供的四种线程池的好处：</p>
<ul>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳。</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能。</li>
</ul>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>当你提交任务时，线程队列已经满了，这时会发生什么？<br>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。注：默认策略！！！！！！<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p>
]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>cas</title>
    <url>/2020/04/23/md/jdk/mulThread/cas/</url>
    <content><![CDATA[<p>CAS的全称为Compare-And-Swap ,它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值,如果是则更新为新的值,这个过程是原子的。<br>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p>
<p>CAS操作都是通过sun包下Unsafe类实现，而Unsafe类中的方法都是native方法，由JVM本地实现</p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot</title>
    <url>/2020/04/23/md/part/spring/springboot/spring-boot/</url>
    <content><![CDATA[<h4 id="Spring-Boot的核心思想就是约定大于配置"><a href="#Spring-Boot的核心思想就是约定大于配置" class="headerlink" title="Spring Boot的核心思想就是约定大于配置"></a>Spring Boot的核心思想就是约定大于配置</h4><p>其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置.它默认配置了很多框架的使用方式</p>
<h4 id="指定端口号方式"><a href="#指定端口号方式" class="headerlink" title="指定端口号方式"></a>指定端口号方式</h4><p>mvn spring-boot:run -Dspring-boot.run.arguments=–server.port=8085</p>
]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>并发一</title>
    <url>/2020/04/08/md/interview/my/conrrent/</url>
    <content><![CDATA[<h3 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h3><p>Synchronized和ReentrantLock的区别</p>
<ul>
<li>synchronized既可以修饰方法，也可以修饰代码块。 </li>
<li>等待可中断。synchronized中等待线程不能中断，一直等;ReentrantLock不是</li>
<li>公平锁。synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，可以设置为公平锁。</li>
<li>锁绑定多个条件。ReentrantLock可以同时绑定多个Condition对象，只需多次调用newCondition方法即可;synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件。但如果要和多于一个的条件关联的时候，就不得不额外添加一个锁。</li>
<li>性能。JDK 1.5中，synchronized还有很大的优化余地。JDK 1.6 中加入了很多针对锁的优化措施，synchronized与ReentrantLock性能方面基本持平。虚拟机在未来的改进中更偏向于原生的synchronized。</li>
</ul>
<p>补充：关于synchronized关键字<br>1.Java中每个对象都有一个锁（lock）或者叫做监视器（monitor）。<br>2.ReentrantLock和synchronized持有的对象监视器不同。<br>3.如果某个synchronized方法是static的，那么当线程方法改方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在对象所对应的Class对象，因为Java中不管一个类有多少对象，这些对象会对应唯一一个Class对象。因此当线程分别访问同一个类的两个对象的两个static，synchronized方法时，是顺序执行的，亦即一个线程先执行，完毕之后，另一个才开始执行。<br>4.synchronized 方法是一种粗粒度的并发控制，某一时刻，只能有一个线程执行synchronized方法；synchronized块则是一种细粒度的并发控制。只会将块中代码同步，位于方法内，synchronized块之外的代码是可以被多个线程同时访问的。<br>5.synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，操作对象均为锁的计数器。<br>6.相同点：都是可重入的。可重入值的是同一个线程多次试图获取它所占的锁，请求会成功。当释放的时候，直到冲入次数清零，锁才释放。</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm</title>
    <url>/2020/04/08/md/interview/my/jvm/</url>
    <content><![CDATA[<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>JVM的类加载是通过ClassLoader及其子类来完成的</p>
<p>BootstrapClassLoader(c++编写，加载java核心库 java.*,开发者无法直接获取到启动类加载器的引用)<br>ExtensionClassLoader<br>AppClassLoader（系统类加载器）<br>CustomClassLoader（用户自定义类加载器）</p>
<p>双亲委托机制：</p>
<p>自底向上检查类是否已加载；其二，自顶向下尝试加载类。</p>
<p>作用：</p>
<ul>
<li>防止重复加载同一个.class</li>
<li>保证核心.class不能被篡改</li>
</ul>
<p>类的生命周期：<br>加载、连接、初始化、使用、卸载<br>其中连接分为：<br>校验（符合JVM的要求），准备(静态变量，常量赋值)，解析（符号引用-&gt; 直接引用）</p>
<p>初始化：执行没有static修饰的赋值语句和执行语句，为静态变量赋程序设定的初值</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>mq设计</title>
    <url>/2020/04/07/md/part/mq/mq/</url>
    <content><![CDATA[<p>主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播</p>
<p><img src="https://www.mqiy.xyz/image/mq/rocketmq-role.png" alt="rocketmq-role.png"></p>
]]></content>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul VS Gateway</title>
    <url>/2020/04/03/md/part/microServices/gateway/gateway-vs-zuul/</url>
    <content><![CDATA[<p>Zuul is built on servlet 2.5 (works with 3.x), using blocking APIs. It doesn’t support any long lived connections, like websockets.</p>
<p>Gateway is built on Spring Framework 5, Project Reactor and Spring Boot 2 using non-blocking APIs. Websockets are supported and it’s a much better developer experience since it’s tightly integrated with Spring.</p>
<p>difference between gateway and zuul</p>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发、分布式学习</title>
    <url>/2020/04/02/md/part/distributed/distributed-use/</url>
    <content><![CDATA[<p>微服务如何拆分？<br>微服务如何选型、组合与落地？<br>微服务治理场景及方法有哪些？<br>流控、负载、容错级别、链路追踪参数等都有哪些调整策略？<br>需求、性能、数据一致性方面都需要注意那些设计细节？</p>
<p>1.微服务架构如何拆分<br>2.微服务架构应用场合<br>3.微服务架构与Docker容器化<br>4.微服务架构如何达到99.999%的高可用<br>5.微服务架构性能怎么满足千亿次请求调用<br>6.微服务架构开源框架对比（Spring Boot , Spring Cloud , Dubbo等）</p>
<h3 id="Dubbo-微服务之负载均衡算法原理分析"><a href="#Dubbo-微服务之负载均衡算法原理分析" class="headerlink" title="Dubbo 微服务之负载均衡算法原理分析"></a>Dubbo 微服务之负载均衡算法原理分析</h3><ol>
<li>如何理解集群与微服务的关系</li>
<li>负载均衡有哪些业务场景</li>
<li>分析几种负载均衡的异同点</li>
</ol>
<p>Dubbo微服务之服务治理算法原理分析</p>
<ol>
<li>微服务治理运作核心原理</li>
<li>微服务治理手段与场景</li>
<li>微服务服务降级、容错、限流工作机制等流程</li>
</ol>
<p>深入认识分布式事务</p>
<p>1、事务的基本概念（ ACID ）<br>2、理解分布式事务的应用场景及面临的问题<br>3、认识分布式事务事务模型<br>4、演示 LCN 框架分布式事务管理<br>5、分布式事务解决方案（ Atomikos、LCN、TCC、MQ ）<br>6、CAP 定理 &amp; Base 理论及柔性事务</p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch与Solr的比较</title>
    <url>/2020/04/02/md/part/mid/es/es-vs-solr/</url>
    <content><![CDATA[<p><em>Elasticsearch与Solr的比较</em></p>
<h4 id="Search-Fesh-Index-While-Idle"><a href="#Search-Fesh-Index-While-Idle" class="headerlink" title="Search Fesh Index While Idle"></a>Search Fesh Index While Idle</h4><p>当单纯的对已有数据进行搜索时，Solr更快。</p>
<h4 id="search-fresh-index-while-indexing"><a href="#search-fresh-index-while-indexing" class="headerlink" title="search_fresh_index_while_indexing"></a>search_fresh_index_while_indexing</h4><ul>
<li>当实时建立索引时, Solr会产生io阻塞，查询性能较差, Elasticsearch具有明显的优势。</li>
<li>随着数据量的增加，Solr的搜索效率会变得更低，而Elasticsearch却没有明显的变化。</li>
</ul>
<p>综上所述，Solr的架构不适合实时搜索的应用。<br>Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>promotion failure VS concurrent mode failure</title>
    <url>/2020/04/02/md/jdk/jvm/gc-problem/</url>
    <content><![CDATA[<p>1、promotion failure，是在minor gc过程中，survivor的剩余空间不足以容纳eden及当前在用survivor区间存活对象，只能将容纳不下的对象移到年老代(promotion)，而此时年老代满了无法容纳更多对象，通常伴随full gc，因而导致的promotion failure。这种情况通常需要增加年轻代大小，尽量让新生对象在年轻代的时候尽量清理掉。<br>2、concurrent mode failure，主要是由于cms的无法处理浮动垃圾（Floating Garbage）引起的。这个跟cms的机制有关。cms的并发清理阶段，用户线程还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里头，cms无法再本次gc清除掉，这些就是浮动垃圾。由于这种机制，cms年老代回收的阈值不能太高，否则就容易预留的内存空间很可能不够(因为本次gc同时还有浮动垃圾产生)，从而导致concurrent mode failure发生。可以通过-XX:CMSInitiatingOccupancyFraction的值来调优。</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>hashMap</title>
    <url>/2020/04/01/md/jdk/mulThread/hashmap/</url>
    <content><![CDATA[<h4 id="HashMap-put过程-jdk8"><a href="#HashMap-put过程-jdk8" class="headerlink" title="HashMap put过程(jdk8)"></a>HashMap put过程(jdk8)</h4><p><img src="https://www.mqiy.xyz/image/jdk/hashMap-put-jdk8.png" alt="hashMap-put-jdk8.png"></p>
]]></content>
      <tags>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL索引结构</title>
    <url>/2020/03/31/md/part/db/mysql-problem/</url>
    <content><![CDATA[<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>叶子结点放数据，树节点只包含索引，减少IO次数<br>叶子节点间有指针相连，遍历叶子就可以区间访问</p>
]]></content>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm内存模型</title>
    <url>/2020/03/30/md/jdk/mulThread/jmm/</url>
    <content><![CDATA[<p><img src="https://www.mqiy.xyz/image/jvm/jmm.png" alt="jmm.png"></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>aqs与volatile</title>
    <url>/2020/03/30/md/jdk/mulThread/aqs/</url>
    <content><![CDATA[<p><img src="https://www.mqiy.xyz/image/jvm/aqs.png" alt="aqs.png"></p>
<p><img src="https://www.mqiy.xyz/image/jvm/volatile.png" alt="volatile.png"></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>netty</title>
    <url>/2020/03/30/md/part/system/netty/</url>
    <content><![CDATA[<p>netty通过Reactor模型基于多路复用器接收并处理用户请求（能讲就多讲一点），内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件</p>
<p>Netty为什么传输快: 使用ByteBuf在堆外进行，零拷贝</p>
<p>netty是由JBOSS提供的一个java开源框架。<br>netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p>
<p>netty：异步非阻塞开源框架</p>
]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存调优</title>
    <url>/2020/03/29/md/jdk/jvm/gc-opt/</url>
    <content><![CDATA[<p>JVM内存调优<br>使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。</p>
<p> 首先需要注意的是在对JVM内存调优的时候不能只看操作系统级别Java进程所占用的内存，这个数值不能准确的反应堆内存的真实占用情况，因为GC过后这个值是不会变化的，因此内存调优的时候要更多地使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。</p>
<p> 对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，过多的GC和Full GC是会占用很多的系统资源（主要是CPU），影响系统的吞吐量。特别要关注Full GC，因为它会对整个堆进行整理，</p>
<h3 id="导致Full-GC一般由于以下几种情况："><a href="#导致Full-GC一般由于以下几种情况：" class="headerlink" title="导致Full GC一般由于以下几种情况："></a>导致Full GC一般由于以下几种情况：</h3><p>旧生代空间不足<br>    调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 </p>
<p>Pemanet Generation空间不足<br>增大Perm Gen空间，避免太多静态对象<br>统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间<br>控制好新生代和旧生代的比例 </p>
<p>System.gc()被显示调用<br>    垃圾回收不要手动触发，尽量依靠JVM自身的机制 </p>
<h3 id="调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现，下面来看看各部分比例不良设置会导致什么后果"><a href="#调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现，下面来看看各部分比例不良设置会导致什么后果" class="headerlink" title="调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现，下面来看看各部分比例不良设置会导致什么后果"></a>调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现，下面来看看各部分比例不良设置会导致什么后果</h3><p>1）新生代设置过小</p>
<p>一是新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC</p>
<p>2）新生代设置过大</p>
<p>一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发Full GC；二是新生代GC耗时大幅度增加</p>
<p>一般说来新生代占整个堆1/3比较合适</p>
<p>3）Survivor设置过小<br>导致对象从eden直接到达旧生代，降低了在新生代的存活时间</p>
<p>4）Survivor设置过大<br>导致eden过小，增加了GC频率</p>
<blockquote>
<p>通过-XX:MaxTenuringThreshold=n来控制新生代存活时间，尽量让对象在新生代被回收</p>
</blockquote>
<h3 id="由内存管理和垃圾回收可知新生代和旧生代都有多种GC策略和组合搭配，选择这些策略对于我们这些开发人员是个难题，JVM提供两种较为简单的GC策略的设置方式"><a href="#由内存管理和垃圾回收可知新生代和旧生代都有多种GC策略和组合搭配，选择这些策略对于我们这些开发人员是个难题，JVM提供两种较为简单的GC策略的设置方式" class="headerlink" title="由内存管理和垃圾回收可知新生代和旧生代都有多种GC策略和组合搭配，选择这些策略对于我们这些开发人员是个难题，JVM提供两种较为简单的GC策略的设置方式"></a>由内存管理和垃圾回收可知新生代和旧生代都有多种GC策略和组合搭配，选择这些策略对于我们这些开发人员是个难题，JVM提供两种较为简单的GC策略的设置方式</h3><ul>
<li>1）吞吐量优先<br>  JVM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio=n来设置</li>
<li>2）暂停时间优先<br>  JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio=n来设置</li>
</ul>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存调优</title>
    <url>/2020/03/29/md/jdk/jvm/jvm-date/</url>
    <content><![CDATA[<p>HotSpot 1.7中，使用永久代来实现方法区，</p>
<p>方法区和“PermGen space”又有着本质的区别。前者是JVM的规范，而后者则是JVM规范的一种实现(HotSpot)</p>
<p>元空间</p>
<p>方法区存储类信息、常量、静态变量</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>equal与hashcode </title>
    <url>/2020/03/28/md/jdk/equal-hashCode/</url>
    <content><![CDATA[<h3 id="一、equal-和-hashcode-作用和区别？"><a href="#一、equal-和-hashcode-作用和区别？" class="headerlink" title="一、equal 和 hashcode 作用和区别？"></a>一、equal 和 hashcode 作用和区别？</h3><p>答：首先，我们要明白hashCode()和equals（）方法的作用是什么，然后才能说他的区别，说了区别之后在说明使用的时候需要注意的地方，这样的回答思路基本是OK的。<br>一、hahsCode()和equals()的作用是什么？<br>hahsCode()和equals()的作用其实是一样的，目的都是为了再java里面比较两个对象是否相等一致<br>二、hahsCode()和equals()的区别是什么？<br>我们可以从两个角度分别介绍他们的区别：一个是性能，一个是可靠性。他们的主要区别体现在这里<br>1.equals()既然已经实现比较两个对象的功能了，为什么还需要hashCode()呢？<br>因为重写的equals()里一般比较的较为全面和复杂(它会对这个对象内所以成员变量一一进行比较)，这样效率很低，而通过hashCode()对比，则只要生成一个hash值就能比较了，效率很高</p>
<h3 id="二-那hashCode的效率这么高，为啥还要用equals-呢？"><a href="#二-那hashCode的效率这么高，为啥还要用equals-呢？" class="headerlink" title="二.那hashCode的效率这么高，为啥还要用equals()呢？"></a>二.那hashCode的效率这么高，为啥还要用equals()呢？</h3><p>因为hashCode()并不是完全可靠，非常有可能的情况是，两个完全不同的对象的hash值却是一样的。<br>所以会有下面三个重要的结论：</p>
<ul>
<li>equals()相等的两个对象他们的hashCode()肯定相等，即equals()绝对可靠。</li>
<li>hahsCode()相同的两个对象，它们的equals()不一定相同。即用hashCode()比较相同的时候不靠谱</li>
<li>hashCode()不同的两个对象，他们的那么equals()肯定不同。即用hashCode()比较不同的时候肯定靠谱</li>
</ul>
<h3 id="三、hashCode-和equals使用的注意事项"><a href="#三、hashCode-和equals使用的注意事项" class="headerlink" title="三、hashCode()和equals使用的注意事项"></a>三、hashCode()和equals使用的注意事项</h3><ul>
<li>对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方案为：每当需要比较的时候，首先用hahsCode（）去对比，而如果hashCode()不一样，则两个对象肯定不一样，此时就没有必要再用equals()比较了；如果hashCode()相同，则这两个对象有可能相同，这时候再去比较这两个对象的equals()，如若equals()也相同，则表示这两个真的相同的，这样既大大提高了效率，又保证了准确性。</li>
<li>事实上，我们平时用的集合框架中的hashMap、hashSet,hashTable 中对key的比较就是使用上述这种方法。</li>
<li>而Obejct默认的equals和HashCode方法返回的是对象的地址相关信息。所以当我们通过new关键字创建了两个内容相同的对象，虽然他们的内容相同，但是他们在内存中分配的地址不同，导致它们的hashCode()不同，这肯定不是我们想要的。所以当我们要将某个类应用到集合中去的时候，就必须重写equals()方法和hashCode()方法。</li>
</ul>
<h3 id="四、扩展"><a href="#四、扩展" class="headerlink" title="四、扩展"></a>四、扩展</h3><p>1.阿里巴巴开发规约明确规定：<br>*.只要重写了equals()方法，就必须重写hashCode()方法<br>*.因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法<br>*.如果对象定义为Map的健，那么就必须重写equals()方法和hashCode()方法<br>*.String重写了equals()方法和hashCode()方法，所以我们可以非常愉快的时候String对象作为key<br>2.是不是每个对象都要重写这两个方法，到底什么时候重写？<br>*.事实上一般情况下，我们并不需要重写这两个方法，只有该类被应用到集合框架中去的时候，才应该重写。<br>3.我能不能值重写equals()方法，不重写hashCode()方法？<br>*.如果重写了equals()方法，比如说基于对象的内容实现的，而保留了hashCode()的实现不改变，那么最终出现的情况很可能是，两个对象明明是“相等的”，但是hashCode()却不一样，这不是宝宝想要的</p>
]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS使用的是TCP协议还是UDP协议简析?</title>
    <url>/2020/03/28/md/part/web/http/dns-find/</url>
    <content><![CDATA[<h3 id="DNS使用的是TCP协议还是UDP协议简析"><a href="#DNS使用的是TCP协议还是UDP协议简析" class="headerlink" title="DNS使用的是TCP协议还是UDP协议简析?"></a>DNS使用的是TCP协议还是UDP协议简析?</h3><p>dns同时占用tcp和udp的53端口！<br>区域传复送时使用TCP，主要有一下两点考虑：</p>
<ul>
<li>1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了制解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的百数据量要多得多。</li>
<li>2.TCP是一种可靠的连接，保证了数据的准确性。<br>域名解析时使用UDP协议：<br>客户端向DNS服务器查询域名，一般返回的度内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，问客户端也可以指定向DNS服务器查询的时候使用TCP，但事答实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li>
</ul>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>粘包与拆包</title>
    <url>/2020/03/28/md/part/web/http/packet/</url>
    <content><![CDATA[<h4 id="TCP粘包：socket读取时，读到了实际意义上的两个或多个数据包的内容，同时将其作为一个数据包进行处理。"><a href="#TCP粘包：socket读取时，读到了实际意义上的两个或多个数据包的内容，同时将其作为一个数据包进行处理。" class="headerlink" title="TCP粘包：socket读取时，读到了实际意义上的两个或多个数据包的内容，同时将其作为一个数据包进行处理。"></a>TCP粘包：socket读取时，读到了实际意义上的两个或多个数据包的内容，同时将其作为一个数据包进行处理。</h4><h4 id="TCP拆包：socket读取时，没有完整地读取一个数据包，只读取一部分。"><a href="#TCP拆包：socket读取时，没有完整地读取一个数据包，只读取一部分。" class="headerlink" title="TCP拆包：socket读取时，没有完整地读取一个数据包，只读取一部分。"></a>TCP拆包：socket读取时，没有完整地读取一个数据包，只读取一部分。</h4><p><em>粘包/拆包问题</em>一般的处理方式有四种：</p>
<ul>
<li>数据段定长处理，位数不足的空位补齐。</li>
<li>消息头+消息体，消息头中一般会包含消息体的长度，消息类型等信息，消息体为实际数据体。</li>
<li>特殊字符（如：回车符）作为消息数据的结尾，以实现消息数据的分段。</li>
<li>复杂的应用层协议，这种方式使用的相对较少，耦合了网络层与应用层。 上面的四种方式目的都是为了将数据在流中精确分开以便进一步解析处理，在自定义的协议中，第二种方式用的比较多，因为它更能满足定制化协议开发需求，比如自定义Netty协议时可以将具体数据报文放入消息体，消息头中根据需要放入其他变量（如：消息类型，此处可以具体对应到维护netty长链接的心跳消息、客户端请求消息、服务端处理结果消息等）</li>
</ul>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引</title>
    <url>/2020/03/27/md/part/db/db-index/</url>
    <content><![CDATA[<h3 id="MyISAM-VS-Innodb"><a href="#MyISAM-VS-Innodb" class="headerlink" title="MyISAM VS  Innodb"></a>MyISAM VS  Innodb</h3><table>
<thead>
<tr>
<th>内容</th>
<th>MyISAM</th>
<th>Innodb</th>
</tr>
</thead>
<tbody><tr>
<td>叶子节点存放数据</td>
<td>数据记录的地址</td>
<td>完整的数据记录</td>
</tr>
<tr>
<td>索引与数据文件</td>
<td>合一</td>
<td>分索引文件，数据文件</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h3><h4 id="创建数量限制："><a href="#创建数量限制：" class="headerlink" title="创建数量限制："></a>创建数量限制：</h4><ul>
<li>单表不超过5个(浪费空间，更新变慢)</li>
<li>区分度低的字段，例如性别，不要建索引。(离散度太低，导致扫描行数过多)</li>
<li>频繁更新的值，不要作为主键或者索引。(——页分裂)</li>
<li>不建议用无序的值（例如身份证、UUID ）作为索引</li>
</ul>
<h4 id="加索引字段"><a href="#加索引字段" class="headerlink" title="加索引字段"></a>加索引字段</h4><ul>
<li>在用于 where 判断 order 排序和 join 的（on）字段上创建索引</li>
</ul>
<h4 id="创建组合索引的顺序："><a href="#创建组合索引的顺序：" class="headerlink" title="创建组合索引的顺序："></a>创建组合索引的顺序：</h4><ul>
<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>
</ul>
<h3 id="列"><a href="#列" class="headerlink" title="列"></a>列</h3><ul>
<li>尽可能把所有列定义为 NOT NULL</li>
<li>单表记录数量控制在500万以内</li>
<li>尽量做到冷热数据分离,减小表的宽度</li>
<li>禁止在数据库中存储图片,文件等大的二进制数据</li>
<li>不建议使用过长的字段作为主键</li>
</ul>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>会影响父表和子表的写操作从而降低性能</p>
<blockquote>
<p>表与表之间的关联键上建立索引</p>
</blockquote>
<h4 id="过长的字段，使用前缀匹配方式创建索引"><a href="#过长的字段，使用前缀匹配方式创建索引" class="headerlink" title="过长的字段，使用前缀匹配方式创建索引"></a>过长的字段，使用前缀匹配方式创建索引</h4><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>原则</p>
<ul>
<li>最左前缀匹配原则</li>
<li>索引列不能参与计算</li>
<li>关联查询表，建议不超过 5 个</li>
</ul>
<h4 id="具体查询"><a href="#具体查询" class="headerlink" title="具体查询"></a>具体查询</h4><ul>
<li>在明显不会有重复值时使用 UNION ALL 而不是 UNION</li>
<li>少使用子查询（原因：子查询的结果集无法使用索引）</li>
</ul>
<p>or-&gt; in</p>
<p>优化：<br>充分利用已有索引，尽可能的扩展索引<br>覆盖索引(不需要回表)<br>范围查询放在最右边</p>
<h3 id="Mysql如何为表字段添加索引？？？"><a href="#Mysql如何为表字段添加索引？？？" class="headerlink" title="Mysql如何为表字段添加索引？？？"></a>Mysql如何为表字段添加索引？？？</h3><p>1.添加PRIMARY KEY（主键索引）</p>
<p>ALTER TABLE <code>table_name</code> ADD PRIMARY KEY ( <code>column</code> )<br>2.添加UNIQUE(唯一索引)</p>
<p>ALTER TABLE <code>table_name</code> ADD UNIQUE ( <code>column</code> )<br>3.添加INDEX(普通索引)</p>
<p>ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column</code> )<br>4.添加FULLTEXT(全文索引)</p>
<p>ALTER TABLE <code>table_name</code> ADD FULLTEXT ( <code>column</code>)<br>5.添加多列索引</p>
<p>ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column1</code>, <code>column2</code>, <code>column3</code> )</p>
]]></content>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka中常规问题</title>
    <url>/2020/03/27/md/part/mq/kafka-mq-problem/</url>
    <content><![CDATA[<h4 id="如何保证高可用"><a href="#如何保证高可用" class="headerlink" title="如何保证高可用"></a>如何保证高可用</h4><h4 id="如何保证消息可靠性"><a href="#如何保证消息可靠性" class="headerlink" title="如何保证消息可靠性"></a>如何保证消息可靠性</h4><h4 id="如何保证消息顺序性"><a href="#如何保证消息顺序性" class="headerlink" title="如何保证消息顺序性"></a>如何保证消息顺序性</h4><h4 id="如何避免消息重复消费"><a href="#如何避免消息重复消费" class="headerlink" title="如何避免消息重复消费"></a>如何避免消息重复消费</h4><h4 id="如何解决消息队列的延时以及过期失效问题"><a href="#如何解决消息队列的延时以及过期失效问题" class="headerlink" title="如何解决消息队列的延时以及过期失效问题"></a>如何解决消息队列的延时以及过期失效问题</h4>]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB使用</title>
    <url>/2020/03/27/md/part/nosql/mongodb/</url>
    <content><![CDATA[<p>db.createUser({ user: ‘root’, pwd: ‘Admin123#’, roles: [ { role: “root”, db: “admin” } ] });</p>
<p>db.auth(‘root’,’Admin123#’);</p>
<p>db.createUser({ user: ‘hdh’, pwd: ‘Admin123#’, roles: [ { role: “readWrite”, db: “hdh” } ] });</p>
<p>sc delete MongoDB</p>
<p>mongod –dbpath=D:\Doc\MongoDb\data  –logpath=D:\Doc\MongoDb\logs\MongoDB.log –install –serviceName “MongoDB”</p>
]]></content>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>db分库分表</title>
    <url>/2020/03/27/md/part/db/db-share/</url>
    <content><![CDATA[<p>单库最多支撑到并发 2000，健康的单库并发值保持在每秒 1000 左右</p>
<p>harding-jdbc(client ) VS  Mycat(proxy )</p>
<p>分库：提高并发</p>
<p>分表：查询优化</p>
<p>  水平拆分（某字段range[热点问题],hash[扩容难]）<br>  垂直拆分(热点与非热点)</p>
]]></content>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>用户故事</title>
    <url>/2020/03/27/md/part/project/project-story/</url>
    <content><![CDATA[<p>需求获取<br>成本估算<br>项目进度安排<br>进展程度监测</p>
<p>smart 用户故事</p>
<p>确定性（Specific）,可评估(Measurable),可实现(Achievable),相关性(Relevant),时间限制(Timeboxed)</p>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper主要概念</title>
    <url>/2020/03/27/md/part/mid/zookeeper/zk-outline/</url>
    <content><![CDATA[<p>如果zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。所以说，Zookeeper不能保证服务可用性</p>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper主要概念</title>
    <url>/2020/03/27/md/part/mid/zookeeper/zk-main/</url>
    <content><![CDATA[<p>5.Zookeeper做了什么？</p>
<ul>
<li>命名服务   </li>
<li>配置管理   </li>
<li>集群管理   </li>
<li>分布式锁  </li>
<li>队列管理</li>
</ul>
<p> 是CP</p>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器</title>
    <url>/2020/03/27/md/jdk/jvm/gc-collector/</url>
    <content><![CDATA[<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="https://www.mqiy.xyz/image/jvm/gc-colloctor.png" alt="gc-colloctor.png"></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><ul>
<li>新生代</li>
<li>使用复制算法</li>
<li>单线程</li>
<li>简单而高效（就单CPU）,适用于Client模式</li>
<li>Stop The World</li>
</ul>
<h4 id="Serial-old-收集器"><a href="#Serial-old-收集器" class="headerlink" title="Serial old 收集器"></a>Serial old 收集器</h4><ul>
<li>老年代</li>
<li>使用标记-整理算法</li>
<li>其他同Serial收集器 </li>
<li>在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><ul>
<li>Serial收集器的多线程版本</li>
<li>默认开启的收集线程数与CPU的数量相同</li>
<li>与cms配合工作</li>
<li>其他同Serial收集器 </li>
</ul>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><ul>
<li>新生代</li>
<li>复制算法</li>
<li>并行的多线程</li>
<li>达到一个可控制的吞吐量（Throughput），适合后台运算而不需要太多交互的任务（VS cms关注时间）</li>
<li>GC自适应的调节策略(GC Ergonomics)</li>
</ul>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><ul>
<li>老年代</li>
<li>多线程</li>
<li>“标记-整理”算法</li>
<li>JDK 1.6新提供</li>
</ul>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><ul>
<li>老年代</li>
<li>标记-清除算法</li>
<li>并发收集、低停顿</li>
</ul>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>初始标记（initial mark）-&gt; 并发标记（concurrent mark）-&gt;重新标记（remark）-&gt; 并发清除（concurrent sweep）</p>
<ul>
<li>过程中耗时最长的并发标记和并发清除,用户线程均可执行</li>
<li>初始标记与重新标记需要”stop the world”</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>占用cpu</li>
<li>产生浮动垃圾</li>
<li>标记-清除算法产生空间碎片</li>
</ul>
<p>重新标记（Remark） 的作用在于：<br>之前在并发标记时，因为是 GC 和用户程序是并发执行的，可能导致一部分已经标记为 从 GC Roots 不可达 的对象，因为用户程序的（并发）运行，又可达 了，Remark 的作用就是将这部分对象又标记为 可达对象。</p>
<p>至于 <code>浮动垃圾</code>，因为 CMS 在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 重新标记 的作用只是修改之前 并发标记 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的。</p>
<p>remark过程标记活着的对象，从GCRoot的可达性判断对象活着，但无法标记“死亡”的对象。<br>如果在初始标记阶段被标记为活着，并发运行过程中“死亡”，remark过程无法纠正，因此变为浮动垃圾，需等待下次gc的到来。</p>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><ul>
<li>并行与并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿</li>
</ul>
<p><em>工作流程</em></p>
<p>初始标记（Initial Marking） -&gt; 并发标记（Concurrent Marking）-&gt; 最终标记（Final Marking） -&gt; 筛选回收（Live Data Counting and Evacuation） </p>
<blockquote>
<p>并发阶段，用户线程可执行，其他均”stop the world”</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>收集器</th>
<th>线程</th>
<th>区域</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>串行</td>
<td>新生代</td>
<td>复制</td>
<td>响应速度优先</td>
<td>单CPU下Client模式</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU下Client模式，cms后备</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制</td>
<td>响应速度优先</td>
<td>多CPU下Server模式，配合cms</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制</td>
<td>吞吐量优先</td>
<td>后台运算少交互</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>后台运算少交互</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>互联网站或B/S</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制</td>
<td>响应速度优先</td>
<td>服务端,将替代cms</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>触发MinorGC与FullGC情景</title>
    <url>/2020/03/27/md/jdk/jvm/gc-scene/</url>
    <content><![CDATA[<h4 id="触发MinorGC-Young-GC"><a href="#触发MinorGC-Young-GC" class="headerlink" title="触发MinorGC(Young GC)"></a>触发MinorGC(Young GC)</h4><p>​    虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间</p>
<ul>
<li><p>如果大于的话，直接执行minorGC</p>
</li>
<li><p>如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC</p>
</li>
<li><p>如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC</p>
</li>
<li><p>如果大于的话，执行minorGC</p>
</li>
</ul>
<h4 id="触发FullGC"><a href="#触发FullGC" class="headerlink" title="触发FullGC"></a>触发FullGC</h4><h5 id="老年代空间不足"><a href="#老年代空间不足" class="headerlink" title="老年代空间不足"></a>老年代空间不足</h5><p>​     如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。</p>
<h5 id="持久代空间不足"><a href="#持久代空间不足" class="headerlink" title="持久代空间不足"></a>持久代空间不足</h5><p>​    如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC</p>
<h5 id="YGC出现promotion-failure"><a href="#YGC出现promotion-failure" class="headerlink" title="YGC出现promotion failure"></a>YGC出现promotion failure</h5><p>​    promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.</p>
<h5 id="统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间"><a href="#统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间" class="headerlink" title="统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间"></a>统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间</h5><p>​      在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。</p>
<h5 id="显示调用System-gc"><a href="#显示调用System-gc" class="headerlink" title="显示调用System.gc"></a>显示调用System.gc</h5>]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/2020/03/27/md/part/system/io/</url>
    <content><![CDATA[<h4 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h4><h4 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h4><p>有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作</p>
<p> 另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，<br> 而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多</p>
<h4 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h4><p> 当用户线程发起IO请求，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作 </p>
<h4 id="异步IO模型："><a href="#异步IO模型：" class="headerlink" title="异步IO模型："></a>异步IO模型：</h4><p>  最理想的IO模型，用户发起IO请求，内核会立刻返回成功标志，等数据拷贝到用户线程，内核发信号给用户线程表示READ操作完成</p>
<blockquote>
<p> VS  信号驱动模型还需要用户线程调实际的读写操作</p>
</blockquote>
<p>bio：同步阻塞<br>nio：同步非阻塞<br>bio：异步非阻塞</p>
<p>一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作。<br>同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。<br>阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。 </p>
<ul>
<li>同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！ </li>
<li>同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ </li>
<li>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 </li>
<li>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。 </li>
</ul>
]]></content>
      <tags>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo配置</title>
    <url>/2020/03/26/md/part/mid/dubbo/dubbo/</url>
    <content><![CDATA[<h3 id="qos-server-can-not-bind-localhost-22222-dubbo-version-2-6-4-current-host-169-254-68-252-java-net-BindException-Address-already-in-use-bind"><a href="#qos-server-can-not-bind-localhost-22222-dubbo-version-2-6-4-current-host-169-254-68-252-java-net-BindException-Address-already-in-use-bind" class="headerlink" title="qos-server can not bind localhost:22222, dubbo version: 2.6.4, current host: 169.254.68.252 java.net.BindException: Address already in use: bind"></a>qos-server can not bind localhost:22222, dubbo version: 2.6.4, current host: 169.254.68.252 java.net.BindException: Address already in use: bind</h3><blockquote>
<p>服务提供方与服务消费方在同一台机器，均默认使用22222端口，修改配置即可</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.enable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.accept.foreign.ip"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.port"</span> <span class="attr">value</span>=<span class="string">"33333"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">dubbo.application.qos.enable</span>=<span class="string">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">dubbo.application.qos.port</span>=<span class="string">33333</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">dubbo.application.qos.accept.foreign.ip</span>=<span class="string">false</span></span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>es分片与副本数量推荐</title>
    <url>/2020/03/25/md/part/mid/es/es-best-practise/</url>
    <content><![CDATA[<h3 id="分片设置"><a href="#分片设置" class="headerlink" title="分片设置"></a>分片设置</h3><p>将数据切分成n片，当查询数据时，查询请求会同时分发到n片上并行查询，从而降低查询时间。 建议：</p>
<table>
<thead>
<tr>
<th>文档数据量</th>
<th>分片数量</th>
</tr>
</thead>
<tbody><tr>
<td>1百万数据以下</td>
<td>2</td>
</tr>
<tr>
<td>1百万–5百万</td>
<td>3</td>
</tr>
<tr>
<td>5百万-1千万</td>
<td>4</td>
</tr>
<tr>
<td>1千万以上</td>
<td>5~9</td>
</tr>
</tbody></table>
<h3 id="副本设置"><a href="#副本设置" class="headerlink" title="副本设置"></a>副本设置</h3><p>副本是索引数据的一份拷贝，每个副本都可以执行查询请求，充足的物理机下，多个副本可以分散查询请求压力。</p>
<p>建议：</p>
<table>
<thead>
<tr>
<th>TPS</th>
<th>副本数量</th>
</tr>
</thead>
<tbody><tr>
<td>低于1200</td>
<td>1</td>
</tr>
<tr>
<td>1200~4000</td>
<td>2</td>
</tr>
<tr>
<td>4000~6000</td>
<td>3</td>
</tr>
<tr>
<td>以上</td>
<td>暂无推荐</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ES与DB的概念对比</title>
    <url>/2020/03/25/md/part/mid/es/es-vs-db/</url>
    <content><![CDATA[<p>ES与DB的概念对比</p>
<table>
<thead>
<tr>
<th>ES</th>
<th>DB</th>
</tr>
</thead>
<tbody><tr>
<td>索引(Index)</td>
<td>数据库(database)</td>
</tr>
<tr>
<td>类型(Type)</td>
<td>表(table)</td>
</tr>
<tr>
<td>文档(document)</td>
<td>表中的记录(record)</td>
</tr>
<tr>
<td>属性(field)</td>
<td>列(column)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解mysql的事务隔离级别和底层实现原理</title>
    <url>/2020/03/20/md/part/db/mysql-trac-basic/</url>
    <content><![CDATA[<h3 id="一、ACID特性"><a href="#一、ACID特性" class="headerlink" title="一、ACID特性"></a>一、ACID特性</h3><p>持久性，我们就不讲了，易懂。</p>
<h4 id="1、原子性"><a href="#1、原子性" class="headerlink" title="1、原子性"></a>1、原子性</h4><p>在同一个事务内部的一组操作必须全部执行成功（或者全部失败）。<br>为了保证事务操作的原子性，必须实现基于日志的REDO/UNDO机制：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。 最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。<br>某个应用在执行转帐的数据库操作时，必须在同一个事务内部调用对帐户A和帐户B的操作，才能保证数据的一致性。<br>但是，原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。 例如，事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上，事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。<br>简而言之，就是：原子性仅能够保证单个事务的一致性。就像redis一样，也只能保证单操作的线程安全，并不能保证多操作下的线程安全。</p>
<h4 id="2、一致性"><a href="#2、一致性" class="headerlink" title="2、一致性"></a>2、一致性</h4><p>按照我个人的理解，在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。<br>我们举个反例来理解下一致性概念。例如：从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。<br>为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。</p>
<h4 id="3、隔离性"><a href="#3、隔离性" class="headerlink" title="3、隔离性"></a>3、隔离性</h4><p>数据库四种隔离级别，以及常见的几种读异常，大家应该都是耳熟能详的，但数据库底层是怎么实现隔离性的呢？都采用了哪些技术呢？ 主要有两个技术：MVCC(多版本并发控制)和锁。</p>
<h4 id="（1）MVCC-多版本并发控制"><a href="#（1）MVCC-多版本并发控制" class="headerlink" title="（1）MVCC(多版本并发控制)"></a>（1）MVCC(多版本并发控制)</h4><p>多版本并发控制，顾名思义，在并发访问的时候，数据存在版本的概念，可以有效地提升数据库并发能力，常见的数据库如MySQL、MS SQL Server、IBM DB2、Hbase、MongoDB等等都在使用。<br>简单讲，如果没有MVCC，当想要读取的数据被其他事务用排它锁锁住时，只能互斥等待；而这时MVCC可以通过提供历史版本从而实现读取被锁的数据的历史版本，从而避免了互斥等待。<br>InnoDB采用的MVCC实现方式是：在需要时，通过undo日志构造出历史版本。</p>
<h4 id="（2）锁"><a href="#（2）锁" class="headerlink" title="（2）锁"></a>（2）锁</h4><h5 id="1-锁的分类"><a href="#1-锁的分类" class="headerlink" title="1) 锁的分类"></a>1) 锁的分类</h5><ul>
<li>Shared Locks(共享锁/S锁)<br>若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li>
<li>Exclusive Locks(排它锁/X锁)<br>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。<br>注意：排他锁会阻止其它事务再对其锁定的数据加读或写的锁，但是不加锁的就没办法控制了。</li>
<li>Record Locks(行锁)<br>行锁，顾名思义，是加在索引行(对！是索引行！不是数据行！)上的锁。比如select * from user where id=1 and id=10 for update，就会在id=1和id=10的索引行上加Record Lock。</li>
<li>Gap Locks(间隙锁)<br>间隙锁，它会锁住两个索引之间的区域。比如select * from user where id&gt;1 and id&lt;10 for update，就会在id为(1,10)的索引区间上加Gap Lock。</li>
<li>Next-Key Locks(间隙锁)<br>也叫间隙锁，它是Record Lock + Gap Lock形成的一个闭区间锁。比如select * from user where id&gt;=1 and id&lt;=10 for update，就会在id为[1,10]的索引闭区间上加Next-Key Lock。<br>这样组合起来就有，行级共享锁，表级共享锁，行级排它锁，表级排它锁。</li>
</ul>
<h5 id="2-什么时候会加锁？"><a href="#2-什么时候会加锁？" class="headerlink" title="2) 什么时候会加锁？"></a>2) 什么时候会加锁？</h5><p>在数据库增删改查四种操作中，insert、delete和update都是会加排它锁(Exclusive Locks)的，而select只有显式声明才会加锁:<br>select: 即最常用的查询，是不加任何锁的<br>select … lock in share mode: 会加共享锁(Shared Locks)<br>select … for update: 会加排它锁</p>
<h5 id="3-四种隔离级别"><a href="#3-四种隔离级别" class="headerlink" title="3) 四种隔离级别"></a>3) 四种隔离级别</h5><p>不同的隔离级别是在数据可靠性和并发性之间的均衡取舍，隔离级别越高，对应的并发性能越差，数据越安全可靠。<br><strong>READ UNCOMMITTED</strong><br>顾名思义，事务之间可以读取彼此未提交的数据。机智如你会记得，在前文有说到所有写操作都会加排它锁，那还怎么读未提交呢？<br>机智如你，前面我们介绍排它锁的时候，有这种说明： 排他锁会阻止其它事务再对其锁定的数据加读或写的锁，但是对不加锁的读就不起作用了。<br>READ UNCOMMITTED隔离级别下, 读不会加任何锁。而写会加排他锁，并到事务结束之后释放。<br>实例1：<br>查-写：查并没有阻止写，表明查肯定并没有加锁，要不写肯定就阻塞了。写很明显，会加排它锁的。<br>实例2： 写-写：阻塞，表明，写会加排它锁。<br><strong>READ COMMITTED</strong><br>顾名思义，事务之间可以读取彼此已提交的数据。<br>InnoDB在该隔离级别(READ COMMITTED)写数据时，使用排它锁, 读取数据不加锁而是使用了MVCC机制。<br>因此，在读已提交的级别下，都会通过MVCC获取当前数据的最新快照，不加任何锁，也无视任何锁(因为历史数据是构造出来的，身上不可能有锁)。<br>但是，该级别下还是遗留了不可重复读和幻读问题： MVCC版本的生成时机: 是每次select时。这就意味着，如果我们在事务A中执行多次的select，在每次select之间有其他事务更新了我们读取的数据并提交了，那就出现了不可重复读，即：重复读时，会出现数据不一致问题，后面我们会讲解超支现象，就是这种引起的。<br><strong>REPEATABLE READ</strong><br>READ COMMITTED级别不同的是MVCC版本的生成时机，即：一次事务中只在第一次select时生成版本，后续的查询都是在这个版本上进行，从而实现了可重复读。<br>但是因为MVCC的快照只对读操作有效，对写操作无效，举例说明会更清晰一点： 事务A依次执行如下3条sql，事务B在语句1和2之间，插入10条age=20的记录，事务A就幻读了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1. <span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age=<span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">-- return 0: 当前没有age=20的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">2. <span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">name</span>=<span class="keyword">test</span> <span class="keyword">where</span> age=<span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">-- Affects 10 rows: 因为事务B刚写入10条age=20的记录，而写操作是不受MVCC影响，能看到最新数据的，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">-- 所以更新成功，而一旦操作成功，这些被操作的数据就会对当前事务可见</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">3. <span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age=<span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">-- return 10: 出现幻读</span></span></pre></td></tr></table></figure>

<p>REPEATABLE READ级别，可以防止大部分的幻读，但像前边举例读-写-读的情况，使用不加锁的select依然会幻读。<br><strong>SERIALISABLE</strong><br>大杀器，该级别下，会自动将所有普通select转化为select … lock in share mode执行，即针对同一数据的所有读写都变成互斥的了，可靠性大大提高，并发性大大降低。<br>读-写，写-写均互斥。</p>
<h5 id="4）总结：几类读异常"><a href="#4）总结：几类读异常" class="headerlink" title="4）总结：几类读异常*"></a>4）总结：几类读异常*</h5><p>读-写-读，引起的异常</p>
<p>脏读：读取了脏数据(不存在的数据)。 事务一读 事务二写(未提交) 事务二读(脏数据) 事务二回滚</p>
<p>不可重复读：既可以读取修改的数据，也可以读取新增的数据(幻读)。 事务一读 事务二写(更新已提交) 事务二读(数据不一致，不可重复读)</p>
<p>幻读：仅可以读取新增的数据，但是无法读取修改的数据； 事务一读 事务二写(新增已提交) 事务二读(数据不一致，幻读)</p>
<p>附命令<br>查看表的加锁情况: select * from information_schema.INNODB_LOCKS;<br>事务状态 select * from information_schema.INNODB_TRX;</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算符</title>
    <url>/2020/03/17/md/other/bit-calc/</url>
    <content><![CDATA[<h3 id="1-位逻辑运算符："><a href="#1-位逻辑运算符：" class="headerlink" title="1 位逻辑运算符："></a>1 位逻辑运算符：</h3><pre><code>&amp; （位   “与”）  and
^  （位   “异或”）
|   （位    “或”）   or
~  （位   “取反”）</code></pre><h3 id="2-移位运算符："><a href="#2-移位运算符：" class="headerlink" title="2 移位运算符："></a>2 移位运算符：</h3><pre><code>&lt;&lt;（左移）
&gt;&gt;（右移）</code></pre>]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>spring aop</title>
    <url>/2020/03/03/md/part/spring/spring-aop/</url>
    <content><![CDATA[<ol start="51">
<li>解释AOP<br>面向切面的编程(AOP)， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</li>
</ol>
<ol start="52">
<li><p>Aspect 切面<br>AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。</p>
</li>
<li><p>在Spring AOP 中，关注点和横切关注的区别是什么？<br>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
</li>
</ol>
<ol start="54">
<li>连接点<br>连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。</li>
</ol>
<ol start="55">
<li>通知<br>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。<h4 id="Spring切面可以应用五种类型的通知："><a href="#Spring切面可以应用五种类型的通知：" class="headerlink" title="Spring切面可以应用五种类型的通知："></a>Spring切面可以应用五种类型的通知：</h4></li>
</ol>
<ul>
<li>before：前置通知，在一个方法执行前被调用</li>
<li>after：在方法执行之后调用的通知，无论方法执行是否成功</li>
<li>after-returning：仅当方法成功完成后执行的通知</li>
<li>after-throwing：在方法抛出异常退出时执行的通知</li>
<li>around：在方法执行之前和之后调用的通知</li>
</ul>
<ol start="56">
<li><p>切点<br>切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p>
</li>
<li><p>什么是引入？<br>引入允许我们在已存在的类中增加新的方法和属性。</p>
</li>
<li><p>什么是目标对象？<br>被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。</p>
</li>
<li><p>什么是代理？<br>代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</p>
</li>
</ol>
<ol start="60">
<li>有几种不同类型的自动代理？</li>
</ol>
<ul>
<li>BeanNameAutoProxyCreator</li>
<li>DefaultAdvisorAutoProxyCreator</li>
<li>Metadata autoproxying</li>
</ul>
<ol start="61">
<li><p>什么是织入。什么是织入应用的不同点？<br>织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。<br>织入可以在编译时，加载时，或运行时完成。</p>
</li>
<li><p>解释基于XML Schema方式的切面实现<br>在这种情况下，切面由常规类以及基于XML的配置实现。</p>
</li>
<li><p>解释基于注解的切面实现<br>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq问题</title>
    <url>/2020/02/29/md/part/mq/rockemq-problem/</url>
    <content><![CDATA[<p>匿名方法来代替上面的监听类”我也遇到过这个问题花了1个多小时来解决！<br>最终我认为是CLR把这个匿名类当垃圾回收了！</p>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka主要流程</title>
    <url>/2020/02/27/md/part/mq/kafka-flow/</url>
    <content><![CDATA[<h2 id="Kakfa的设计思想"><a href="#Kakfa的设计思想" class="headerlink" title="Kakfa的设计思想"></a>Kakfa的设计思想</h2><h4 id="Kakfa-Broker-Leader的选举"><a href="#Kakfa-Broker-Leader的选举" class="headerlink" title="Kakfa Broker Leader的选举"></a>Kakfa Broker Leader的选举</h4><p>Kakfa Broker集群受Zookeeper管理。<br>所有的Kafka Broker节点一起去Zookeeper上注册一个临时节点，因为只有一个Kafka Broker会注册成功，其他的都会失败，所以这个成功在Zookeeper上注册临时节点的这个Kafka Broker会成为<code>Kafka Broker Controller</code>，其他的Kafka broker叫<code>Kafka Broker follower</code>。（这个过程叫Controller在ZooKeeper注册Watch）。<br>这个Controller会监听其他的Kafka Broker的所有信息，如果这个kafka broker controller宕机了，在zookeeper上面的那个临时节点就会消失，此时所有的kafka broker又会一起去Zookeeper上注册一个临时节点，因为只有一个Kafka Broker会注册成功，其他的都会失败，所以这个成功在Zookeeper上注册临时节点的这个Kafka Broker会成为Kafka Broker Controller，其他的Kafka broker叫Kafka Broker follower。<br>例如：一旦有一个broker宕机了，这个kafka broker controller会读取该宕机broker上所有的partition在zookeeper上的状态，并选取ISR列表中的一个replica作为partition leader（如果ISR列表中的replica全挂，选一个幸存的replica作为leader; 如果该partition的所有的replica都宕机了，则将新的leader设置为-1，等待恢复，等待ISR中的任一个Replica“活”过来，并且选它作为Leader；或选择第一个“活”过来的Replica（不一定是ISR中的）作为Leader），这个broker宕机的事情，kafka controller也会通知zookeeper，zookeeper就会通知其他的kafka broker。</p>
<p>这里曾经发生过一个bug，TalkingData使用Kafka0.8.1的时候，kafka controller在Zookeeper上注册成功后，它和Zookeeper通信的timeout时间是6s，也就是如果kafka controller如果有6s中没有和Zookeeper做心跳，那么Zookeeper就认为这个kafka controller已经死了，就会在Zookeeper上把这个临时节点删掉，那么其他Kafka就会认为controller已经没了，就会再次抢着注册临时节点，注册成功的那个kafka broker成为controller，然后，之前的那个kafka controller就需要各种shut down去关闭各种节点和事件的监听。但是当kafka的读写流量都非常巨大的时候，TalkingData的一个bug是，由于网络等原因，kafka controller和Zookeeper有6s中没有通信，于是重新选举出了一个新的kafka controller，但是原来的controller在shut down的时候总是不成功，这个时候producer进来的message由于Kafka集群中存在两个kafka controller而无法落地。导致数据淤积。</p>
<p>这里曾经还有一个bug，TalkingData使用Kafka0.8.1的时候，当ack=0的时候，表示producer发送出去message，只要对应的kafka broker topic partition leader接收到的这条message，producer就返回成功，不管partition leader 是否真的成功把message真正存到kafka。当ack=1的时候，表示producer发送出去message，同步的把message存到对应topic的partition的leader上，然后producer就返回成功，partition leader异步的把message同步到其他partition replica上。当ack=all或-1，表示producer发送出去message，同步的把message存到对应topic的partition的leader和对应的replica上之后，才返回成功。但是如果某个kafka controller 切换的时候，会导致partition leader的切换（老的 kafka controller上面的partition leader会选举到其他的kafka broker上）,但是这样就会导致丢数据。</p>
<h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>各个consumer（consumer 线程）可以组成一个组（Consumer group ），partition中的每个message只能被组（Consumer group ）中的一个consumer（consumer 线程）消费，如果一个message可以被多个consumer（consumer 线程）消费的话，那么这些consumer必须在不同的组。<br>Kafka不支持一个partition中的message由两个或两个以上的同一个consumer group下的consumer thread来处理，除非再启动一个新的consumer group。所以如果想同时对一个topic做消费的话，启动多个consumer group就可以了，但是要注意的是，这里的多个consumer的消费都必须是顺序读取partition里面的message，新启动的consumer默认从partition队列最头端最新的地方开始阻塞的读message。<br>它不能像AMQ那样可以多个BET作为consumer去互斥的（for update悲观锁）并发处理message，这是因为多个BET去消费一个Queue中的数据的时候，由于要保证不能多个线程拿同一条message，所以就需要行级别悲观所（for update）,这就导致了consume的性能下降，吞吐量不够。<br>而kafka为了保证吞吐量，只允许同一个consumer group下的一个consumer线程去访问一个partition。如果觉得效率不高的时候，可以加partition的数量来横向扩展，那么再加新的consumer thread去消费。如果想多个不同的业务都需要这个topic的数据，起多个consumer group就好了，大家都是顺序的读取message，offsite的值互不影响。这样没有锁竞争，充分发挥了横向的扩展性，吞吐量极高。这也就形成了分布式消费的概念。</p>
<p>当启动一个consumer group去消费一个topic的时候，无论topic里面有多少个partition，无论我们consumer group里面配置了多少个consumer thread。因此，最优的设计就是，<code>consumer group下的consumer thread的数量等于partition数量，这样效率是最高的</code>。</p>
<p>一个consumer group下，无论有多少个consumer，这个consumer group一定回去把这个topic下所有的partition都消费了。</p>
<ul>
<li>当consumer group里面的consumer数量小于这个topic下的partition数量的时候，如下图groupA,groupB，就会出现一个conusmer thread消费多个partition的情况，总之是这个topic下的partition都会被消费。</li>
<li>如果consumer group里面的consumer数量等于这个topic下的partition数量的时候，如下图groupC，此时效率是最高的，每个partition都有一个consumer thread去消费。</li>
<li>当consumer group里面的consumer数量大于这个topic下的partition数量的时候，如下图GroupD，就会有一个consumer thread空闲。因此，我们在设定consumer group的时候，只需要指明里面有几个consumer数量即可，无需指定对应的消费partition序号，consumer会自动进行rebalance。</li>
</ul>
<p><img src="https://www.mqiy.xyz/image/distribute/kafka-concept-consumer-group-one.png" alt="kafka-concept-consumer-group-one.png"></p>
<p>多个Consumer Group下的consumer可以消费同一条message，但是这种消费也是以o（1）的方式顺序的读取message去消费,，所以一定会重复消费这批message的，不能向AMQ那样多个BET作为consumer消费（对message加锁，消费的时候不能重复消费message）</p>
<h4 id="Delivery-Mode"><a href="#Delivery-Mode" class="headerlink" title="Delivery Mode"></a>Delivery Mode</h4><p> Kafka producer 发送message不用维护message的offsite信息，因为这个时候，offsite就相当于一个自增id，producer就尽管发送message就好了。而且Kafka与AMQ不同，AMQ大都用在处理业务逻辑上，而Kafka大都是日志，所以Kafka的producer一般都是大批量的batch发送message，向这个topic一次性发送一大批message，load balance到一个partition上，一起插进去，offsite作为自增id自己增加就好。但是Consumer端是需要维护这个partition当前消费到哪个message的offsite信息的，这个offsite信息，high level api是维护在Zookeeper上，low level api是自己的程序维护。（Kafka管理界面上只能显示high level api的consumer部分，因为low level api的partition offsite信息是程序自己维护，kafka是不知道的，无法在管理界面上展示 ）当使用high level api的时候，先拿message处理，再定时自动commit offsite+1（也可以改成手动）, 并且kakfa处理message是没有锁操作的。因此如果处理message失败，此时还没有commit offsite+1，当consumer thread重启后会重复消费这个message。但是作为高吞吐量高并发的实时处理系统，at least once的情况下，至少一次会被处理到，是可以容忍的。如果无法容忍，就得使用low level api来自己程序维护这个offsite信息，那么想什么时候commit offsite+1就自己搞定了。</p>
<h4 id="Topic-amp-Partition"><a href="#Topic-amp-Partition" class="headerlink" title="Topic &amp; Partition"></a>Topic &amp; Partition</h4><p>Topic相当于传统消息系统MQ中的一个队列queue，producer端发送的message必须指定是发送到哪个topic，但是不需要指定topic下的哪个partition，因为kafka会把收到的message进行load balance，均匀的分布在这个topic下的不同的partition上（ hash(message) % [broker数量] ）。物理上存储上，这个topic会分成一个或多个partition，每个partiton相当于是一个子queue。在物理结构上，每个partition对应一个物理的目录（文件夹），文件夹命名是[topicname][partition][序号]，一个topic可以有无数多的partition，根据业务需求和数据量来设置。在kafka配置文件中可随时更高num.partitions参数来配置更改topic的partition数量，在创建Topic时通过参数指定parittion数量。Topic创建之后通过Kafka提供的工具也可以修改partiton数量。<br>一般来说，</p>
<ul>
<li>（1）一个Topic的Partition数量大于等于Broker的数量，可以提高吞吐率。</li>
<li>（2）同一个Partition的Replica尽量分散到不同的机器，高可用。</li>
</ul>
<p>当add a new partition的时候，partition里面的message不会重新进行分配，原来的partition里面的message数据不会变，新加的这个partition刚开始是空的，随后进入这个topic的message就会重新参与所有partition的load balance</p>
<h4 id="Partition-Replica"><a href="#Partition-Replica" class="headerlink" title="Partition Replica"></a>Partition Replica</h4><p>每个partition可以在其他的kafka broker节点上存副本，以便某个kafka broker节点宕机不会影响这个kafka集群。存replica副本的方式是按照kafka broker的顺序存。<br>例如有5个kafka broker节点，某个topic有3个partition，每个partition存2个副本，那么partition1存broker1,broker2，partition2存broker2,broker3。。。以此类推（replica副本数目不能大于kafka broker节点的数目，否则报错。这里的replica数其实就是partition的副本总数，其中包括一个leader，其他的就是copy副本）。<br>这样如果某个broker宕机，其实整个kafka内数据依然是完整的。但是，replica副本数越高，系统虽然越稳定，但是回来带资源和性能上的下降；replica副本少的话，也会造成系统丢数据的风险。</p>
<ul>
<li><p>（1）怎样传送消息：producer先把message发送到partition leader，再由leader发送给其他partition follower。（如果让producer发送给每个replica那就太慢了）</p>
</li>
<li><p>（2）在向Producer发送ACK前需要保证有多少个Replica已经收到该消息：根据ack配的个数而定</p>
</li>
<li><p>（3）怎样处理某个Replica不工作的情况：</p>
<ul>
<li>如果这个不工作的partition replica不在ack列表中，就是producer在发送消息到partition leader上，partition leader向partition follower发送message没有响应而已，这个不会影响整个系统，也不会有什么问题。</li>
<li>如果这个不工作的partition replica在ack列表中的话，producer发送的message的时候会等待这个不工作的partition replca写message成功，但是会等到time out，然后返回失败因为某个ack列表中的partition replica没有响应，此时kafka会自动的把这个部工作的partition replica从ack列表中移除，以后的producer发送message的时候就不会有这个ack列表下的这个部工作的partition replica了。</li>
</ul>
</li>
<li><p>（4）怎样处理Failed Replica恢复回来的情况：如果这个partition replica之前不在ack列表中，那么启动后重新受Zookeeper管理即可，之后producer发送message的时候，partition leader会继续发送message到这个partition follower上。如果这个partition replica之前在ack列表中，此时重启后，需要把这个partition replica再手动加到ack列表中。（ack列表是手动添加的，出现某个部工作的partition replica的时候自动从ack列表中移除的）</p>
</li>
</ul>
<h4 id="Partition-leader与follower"><a href="#Partition-leader与follower" class="headerlink" title="Partition leader与follower"></a>Partition leader与follower</h4><p>partition也有leader和follower之分。leader是主partition，producer写kafka的时候先写partition leader，再由partition leader push给其他的partition follower。partition leader与follower的信息受Zookeeper控制，一旦partition leader所在的broker节点宕机，zookeeper通知其他的broker的partition follower上选择follower变为partition leader。</p>
<h4 id="Topic分配partition和partition-replica的算法"><a href="#Topic分配partition和partition-replica的算法" class="headerlink" title="Topic分配partition和partition replica的算法"></a>Topic分配partition和partition replica的算法</h4><ul>
<li>（1）将Broker（size=n）和待分配的Partition排序。</li>
<li>（2）将第i个Partition分配到第（i%n）个Broker上。</li>
<li>（3）将第i个Partition的第j个Replica分配到第（(i + j) % n）个Broker上</li>
</ul>
<h3 id="消息投递可靠性"><a href="#消息投递可靠性" class="headerlink" title="消息投递可靠性"></a>消息投递可靠性</h3><p>一个消息如何算投递成功，Kafka提供了三种模式：</p>
<ul>
<li>啥都不管，发送出去就当作成功，这种情况当然不能保证消息成功投递到broker；</li>
<li>Master-Slave模型，只有当Master和所有Slave都接收到消息时，才算投递成功，这种模型提供了最高的投递可靠性，但是损伤了性能；</li>
<li>只要Master确认收到消息就算投递成功；实际使用时，根据应用特性选择，绝大多数情况下都会中和可靠性和性能选择第三种模型</li>
</ul>
]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka关键点</title>
    <url>/2020/02/27/md/part/mq/kafaka-key/</url>
    <content><![CDATA[<h3 id="如何保证消息队列的高可用？"><a href="#如何保证消息队列的高可用？" class="headerlink" title="如何保证消息队列的高可用？"></a>如何保证消息队列的高可用？</h3><p> replica（复制品）副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。broker宕机，存在leader partition ，则会从其他broker上该partition<br>　的follower 中，选举leader。</p>
<h3 id="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</h3><p>Kafka 使用offset记录消息者消费记录，消费者来保证幂等性</p>
<ul>
<li>写db时，用主键查，存在则更新；使用唯一约束</li>
<li>写redis时，不用处理，天然幂等性</li>
<li>其他使用全局唯一的 id </li>
</ul>
<blockquote>
<p>需要为每个Consumer 指定一个Consumer Group，不同Group可读取相同消息；同一group内不同consumer 互斥，不会消费相同的消息，consumer 相关信息也在zk中维护</p>
</blockquote>
<blockquote>
<p>broker.id 用来唯一标识每一个 broker，每个broker都有一个唯一的id值用来区分彼此。Kafka在启动时会在zookeeper中/brokers/ids路径下创建一个与当前broker的id为名称的虚节点，Kafka的健康状态检查就依赖于此节点。</p>
</blockquote>
<blockquote>
<p>bootstrap-servers指的是目标集群的服务器地址，这个和broker-list功能是一样的，只不过我们在console producer要求用后者</p>
</blockquote>
<blockquote>
<p>0.8以前的kafka，消费的进度(offset)是写在zk中的，所以consumer需要知道zk的地址。后来的版本都统一由broker管理，所以就用bootstrap-server了。</p>
</blockquote>
<h3 id="不会丢数据"><a href="#不会丢数据" class="headerlink" title="不会丢数据"></a>不会丢数据</h3><p>default.replication.factor=2  （副本数量，要求大于1）</p>
<p>producer.type = sync (同步模式,sync:同步,异步:async)</p>
<p>min.insync.replicas=2 ()</p>
<p>broker.rack</p>
<p>request.required.acks=1（值可设为 0, 1, -1/all, 其中 -1 和 all 等同）  producer 发消息到broker</p>
<p>调用read函数，文件数据copy到内核缓冲区</p>
]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>PPT放映当前页快捷键是</title>
    <url>/2020/02/27/md/tool/ppt/</url>
    <content><![CDATA[<p><em>PPT当前页开始放映的快捷键是Shift+F5</em></p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq主要概念</title>
    <url>/2020/02/27/md/part/mq/rockemq-concept/</url>
    <content><![CDATA[<h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><p>1.NameServer<br>可以理解为是消息队列的协调者，Broker向它注册路由信息，同时Client向其获取路由信息，如果使用过Zookeeper，就比较容易理解了，但是功能比Zookeeper弱；<br>NameServer本身是没有状态的，并且多个NameServer直接并没有通信，可以横向扩展多台，Broker会和每一台NameServer建立长连接；</p>
<p>2.Broker<br>Broker是RocketMQ的核心，提供了消息的接收，存储，拉取等功能，一般都需要保证Broker的高可用，所以会配置Broker Slave，当Master挂掉之后，Consumer然后可以消费Slave；<br>Broker分为Master和Slave，一个Master可以对应多个Slave，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave；</p>
<p>3.Producer<br>消息队列的生产者，需要与NameServer建立连接，从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立连接；Producer无状态，看集群部署；</p>
<p>4.Consumer<br>消息队列的消费者，同样与NameServer建立连接，从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master，Slave建立连接；</p>
<p>5.Topic和Message Queue<br>在介绍完以上4个角色以后，还需要重点介绍一下上面提到的Topic和Message Queue；字面意思就是主题，用来区分不同类型的消息，发送和接收消息前都需要先创建Topic，针对Topic来发送和接收消息，为了提高性能和吞吐量，引入了Message Queue，一个Topic可以设置一个或多个Message Queue，有点类似kafka的分区(Partition)，这样消息就可以并行往各个Message Queue发送消息，消费者也可以并行的从多个Message Queue读取消息；</p>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq 测试</title>
    <url>/2020/02/27/md/part/mq/rocketmq-test/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">nohup sh mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf  autoCreateTopicEnable=true  &amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> tail -f ~/logs/rocketmqlogs/broker.log </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> export NAMESRV_ADDR=localhost:9876</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">关闭rocketmq</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sh bin/mqshutdown broker</span></pre></td></tr><tr><td class="code"><pre><span class="line">sh bin/mqshutdown namesrv</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Broker集群配置</title>
    <url>/2020/02/27/md/part/mq/rocketmq/</url>
    <content><![CDATA[<h4 id="单个-Master"><a href="#单个-Master" class="headerlink" title="单个 Master"></a>单个 Master</h4><p>   这种方式风险较大，一旦Broker 重启或者宕机时，会导致整个服务不可用，不建议线上环境使用。</p>
<h4 id="多-Master-模式-一个集群无-Slave，全是-Master，例如-2-个-Master-或者-3-个-Master"><a href="#多-Master-模式-一个集群无-Slave，全是-Master，例如-2-个-Master-或者-3-个-Master" class="headerlink" title="多 Master 模式   一个集群无 Slave，全是 Master，例如 2 个 Master 或者 3 个 Master"></a>多 Master 模式   一个集群无 Slave，全是 Master，例如 2 个 Master 或者 3 个 Master</h4><ul>
<li>优点：配置简单，单个Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由与 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。</li>
<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。</li>
</ul>
<h4 id="多-Master-多-Slave-模式，异步复制"><a href="#多-Master-多-Slave-模式，异步复制" class="headerlink" title="多 Master 多 Slave 模式，异步复制"></a>多 Master 多 Slave 模式，异步复制</h4><h2 id="每个-Master-配置一个-Slave，有多对Master-Slave，HA-采用异步复制方式，主备有短暂消息延迟，毫秒级。"><a href="#每个-Master-配置一个-Slave，有多对Master-Slave，HA-采用异步复制方式，主备有短暂消息延迟，毫秒级。" class="headerlink" title=" 每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用异步复制方式，主备有短暂消息延迟，毫秒级。"></a> 每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用异步复制方式，主备有<code>短暂消息延迟</code>，毫秒级。</h2><p>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为 Master 宕机后，消费者仍然可以从 Slave 消费，此过程对应用透明。不需要人工干预。性能同多 Master 模式几乎一样。</p>
<ul>
<li>缺点：Master 宕机，磁盘损坏情况，会丢失少量消息。</li>
</ul>
<h4 id="多-Master-多-Slave-模式，同步双写"><a href="#多-Master-多-Slave-模式，同步双写" class="headerlink" title="多 Master 多 Slave 模式，同步双写"></a>多 Master 多 Slave 模式，同步双写</h4><p> 每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用同步双写方式，主备都写成功，向应用返回成功。</p>
<ul>
<li>优点：数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高</li>
<li>缺点：性能比异步复制模式略低，大约低 10%左右，发送单个消息的 RT 会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</li>
</ul>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>学习模板</title>
    <url>/2020/02/27/md/plan/lean-template/</url>
    <content><![CDATA[<h3 id="学习模板"><a href="#学习模板" class="headerlink" title="学习模板"></a>学习模板</h3><ul>
<li>主要概念</li>
<li>主要流程</li>
<li>常规问题</li>
<li>关键点</li>
</ul>
]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC基本概念</title>
    <url>/2020/02/25/md/jdk/mulThread/juc/</url>
    <content><![CDATA[<h3 id="1，tools（工具类）：又叫信号量三组工具类，包含有"><a href="#1，tools（工具类）：又叫信号量三组工具类，包含有" class="headerlink" title="1，tools（工具类）：又叫信号量三组工具类，包含有"></a>1，tools（工具类）：又叫信号量三组工具类，包含有</h3><p>1）<code>CountDownLatch</code>（闭锁） 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待<br>2）<code>CyclicBarrier</code>（栅栏） 之所以叫barrier，是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用。<br>3）<code>Semaphore</code>（信号量） 是一个计数信号量，它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用                                                                                        acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，                                                                                  直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</p>
<h3 id="2，executor-执行者-：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有："><a href="#2，executor-执行者-：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：" class="headerlink" title="2，executor(执行者)：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有："></a>2，executor(执行者)：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：</h3><p>1）<code>ScheduledExecutorService</code>  解决那些需要任务重复执行的问题<br>2）<code>ScheduledThreadPoolExecutor</code>   周期性任务调度的类实现</p>
<h3 id="3，atomic-原子性包-：是JDK提供的一组原子操作类，"><a href="#3，atomic-原子性包-：是JDK提供的一组原子操作类，" class="headerlink" title="3，atomic(原子性包)：是JDK提供的一组原子操作类，"></a>3，atomic(原子性包)：是JDK提供的一组原子操作类，</h3><p>包含有AtomicBoolean、AtomicInteger、AtomicIntegerArray等原子变量类，他们的实现原理大多是持有它们各自的对应的类型变量value，而且被volatile关键字修饰了。这样来保证每次一个线程要使用它都会拿到最新的值。</p>
<h3 id="4，locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地。包含的实现类有：-使用锁"><a href="#4，locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地。包含的实现类有：-使用锁" class="headerlink" title="4，locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地。包含的实现类有：                                              使用锁"></a>4，locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地。包含的实现类有：                                              使用锁</h3><p>1）<code>ReentrantLock</code>   它是独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。<br>2）<code>ReentrantReadWriteLock</code>   它包括子类ReadLock和WriteLock。ReadLock是共享锁，而WriteLock是独占锁。<br>3）<code>LockSupport</code> 它具备阻塞线程和解除阻塞线程的功能，并且不会引发死锁。</p>
<h3 id="5，collections-集合类-：主要是提供线程安全的集合，"><a href="#5，collections-集合类-：主要是提供线程安全的集合，" class="headerlink" title="5，collections(集合类)：主要是提供线程安全的集合，"></a>5，collections(集合类)：主要是提供线程安全的集合，</h3><p>1）ArrayList对应的高并发类是CopyOnWriteArrayList，<br>2）HashSet对应的高并发类是 CopyOnWriteArraySet，<br>3）HashMap对应的高并发类是ConcurrentHashMap等等</p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 和 Spring Boot对应版本</title>
    <url>/2020/02/24/md/part/microServices/spring%20cloud/spring%20cloud%20version/</url>
    <content><![CDATA[<p>Spring Cloud 和 Spring Boot 兼容性请见正文表格：</p>
<table>
<thead>
<tr>
<th align="left">Spring Cloud Train</th>
<th align="left">Spring Boot Version</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Hoxton</td>
<td align="left">2.2.x</td>
</tr>
<tr>
<td align="left">Greenwich</td>
<td align="left">2.1.x</td>
</tr>
<tr>
<td align="left">Finchley</td>
<td align="left">2.0.x</td>
</tr>
<tr>
<td align="left">Edgware</td>
<td align="left">1.5.x</td>
</tr>
<tr>
<td align="left">Dalston</td>
<td align="left">1.5.x</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>知识清单，从开发到架构师！</title>
    <url>/2019/12/26/md/develop/dev-line/</url>
    <content><![CDATA[<h3 id="常见模式与框架"><a href="#常见模式与框架" class="headerlink" title="常见模式与框架"></a>常见模式与框架</h3><p>设计模式<br>开发框架：比如 Spring, SpringMVC, Mybatis</p>
<h3 id="工程化与工具"><a href="#工程化与工具" class="headerlink" title="工程化与工具"></a>工程化与工具</h3><p>软件开发流程&amp;规范<br>Git<br>敏捷开发<br>Docker</p>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>分布式架构设计原则<br>负载均衡，高可用<br>RPC，消息队列<br>分布式存储<br>高性能NIO框架<br>分布式缓存<br>分布式消息中间件</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>Spring Cloud<br>Spring Boot<br>Dubbo<br>Service Mesh</p>
<h3 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h3><p>MySQL<br>MyCat<br>Sharding-JDBC</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>应用层：JVM 结构 &amp; 调优<br>web 服务器层：tomcat 等服务器结构 &amp; 调优<br>存储层：MySQL 结构 &amp; sql 优化，搜索引擎结构 &amp; 查询优化</p>
<h3 id="底层知识"><a href="#底层知识" class="headerlink" title="底层知识"></a>底层知识</h3><p>对 JDK 的包结构，模块深入学习功能&amp;使用场景<br>围绕数据结构&amp;性能优化学习组织<br>对于 Java 开发来讲，JDK 几乎就是最底层和基础的知识了。对 JVM, MySQL等非 Java 程序了解结构，原理，调优基本就差不多了。但是 JDK 是要深入了解掌握的。</p>
<h3 id="从开发到架构师"><a href="#从开发到架构师" class="headerlink" title="从开发到架构师"></a>从开发到架构师</h3><p>从单体技术 -&gt; 分布式，微服务<br>局部 -&gt; 整体<br>简单 -&gt; 深入</p>
<p>架构师是一个更宏观的角色，单体系统的时候，单体系统划分、设计功能模块的也是架构师。随着分布式的兴起，架构师需要从分布式角度看整体系统，而到了微服务时代，架构师又要关注微服务，docker 等技术。</p>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的切换</title>
    <url>/2019/12/19/md/jdk/mulThread/progress-change/</url>
    <content><![CDATA[<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ul>
<li>指令切换</li>
<li>映射表切换</li>
</ul>
<h4 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h4><ul>
<li>仅指令切换</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java中锁的优化 -- JVM对synchronized的优化</title>
    <url>/2019/12/19/md/jdk/mulThread/syn-opti/</url>
    <content><![CDATA[<h3 id="1）锁消除"><a href="#1）锁消除" class="headerlink" title="1）锁消除"></a>1）锁消除</h3><p>概念：JVM在JIT编译(即时编译)时，通过对运行上下文的扫描，去除掉那些不可能发生共享资源竞争的锁，从而节省了线程请求这些锁的时间。</p>
<p><strong>举例</strong>：<br>        StringBuffer的append方法是一个同步方法，如果StringBuffer类型的变量是一个局部变量，则该变量就不会被其它线程所使用，即对局部变量的操作是不会发生线程不安全的问题。<br>        在这种情景下，JVM会在JIT编译时自动将append方法上的锁去掉。</p>
<h3 id="2）锁粗化"><a href="#2）锁粗化" class="headerlink" title="2）锁粗化"></a>2）锁粗化</h3><p>概念：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，即将加锁的粒度放大。</p>
<p><strong>举例</strong>：在for循环里的加锁/解锁操作，一般需要放到for循环外。</p>
<h3 id="3）使用偏向锁和轻量级锁"><a href="#3）使用偏向锁和轻量级锁" class="headerlink" title="3）使用偏向锁和轻量级锁"></a>3）使用偏向锁和轻量级锁</h3><p>说明：</p>
<ul>
<li>1)java6为了减少获取锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。</li>
<li>2)锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁、轻量级锁、重量级锁。</li>
<li>3)锁的状态会随着竞争情况逐渐升级，并且只可以升级而不能降级。</li>
</ul>
<h4 id="【偏向锁】"><a href="#【偏向锁】" class="headerlink" title="【偏向锁】"></a>【偏向锁】</h4><ul>
<li><p>1)背景：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
</li>
<li><p>2)概念：核心思想就是锁会偏向第一个获取它的线程，如果在接下来的执行过程中没有其它的线程获取该锁，则持有偏向锁的线程永远不需要同步。</p>
</li>
<li><p>3)目的：偏向锁实际上是一种优化锁，其目的是为了减少数据在无竞争情况下的性能损耗。</p>
</li>
<li><p>4)原理：<br>1&gt;当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID。<br>2&gt;以后该线程在进入和退出同步块时就不需要进行CAS操作来加锁和解锁，只需简单地判断一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p>
</li>
<li><p>5)偏向锁的获取：<br>1&gt;访问Mark Word中偏向锁的标识位是否为1，如果是1，则确定为偏向锁。<br>说明：<br>  [1]如果偏向锁的标识位为0，说明此时是处于无锁状态，则当前线程通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；并且将偏向标识位设为1。<br>  [2]如果偏向锁的标识位不为1，也不为0(此时偏向锁的标识位没有值)，说明发生了竞争，偏向锁已经膨胀为轻量级锁，这时使用CAS操作尝试获得锁。</p>
<p>2&gt;如果是偏向锁，则判断Mark Word中的偏向线程ID是否指向当前线程，如果偏向线程ID指向当前线程，则表明当前线程已经获取到了锁；</p>
<p>3&gt;如果偏向线程ID并未指向当前线程，则通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；</p>
<p>4&gt;如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时(在这个时间点上没有正在执行的字节码)，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</p>
</li>
<li><p>6)偏向锁的释放：<br>1&gt;当其它的线程尝试获取偏向锁时，持有偏向锁的线程才会释放偏向锁。<br>2&gt;释放偏向锁需要等待全局安全点(在这个时间点上没有正在执行的字节码)。<br>3&gt;过程：</p>
<pre><code>首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，
如果线程还活着，说明此时发生了竞争，则偏向锁升级为轻量级锁，然后刚刚被暂停的线程会继续往下执行同步代码。</code></pre></li>
<li><p>7)优点：加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</p>
</li>
<li><p>8)缺点：如果线程间存在锁竞争，锁撤销会带来额外的消耗。</p>
</li>
<li><p>9)说明：<br>1&gt;偏向锁默认在应用程序启动几秒钟之后才激活。<br>2&gt;可以通过设置 -XX:BiasedLockingStartupDelay=0 来关闭延迟。<br>3&gt;可以通过设置 -XX:-UseBiasedLocking=false 来关闭偏向锁，程序默认会进入轻量级锁状态。(如果应用程序里的锁大多情况下处于竞争状态，则应该将偏向锁关闭)</p>
</li>
</ul>
<h4 id="【轻量级锁】"><a href="#【轻量级锁】" class="headerlink" title="【轻量级锁】"></a>【轻量级锁】</h4><p>1)原理：<br> 1&gt;当使用轻量级锁(锁标识位为00)时，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中(注:锁记录中的标识字段称为Displaced Mark Word)。</p>
<p> 2&gt;将对象头中的MarkWord复制到栈桢中的锁记录中之后，虚拟机将尝试使用CAS将对象头中Mark Word替换为指向该线程虚拟机栈中锁记录的指针，此时如果没有线程占有锁或者没有线程竞争锁，则当前线程成功获取到锁，然后执行同步块中的代码。</p>
<p> 3&gt;如果在获取到锁的线程执行同步代码的过程中，另一个线程也完成了栈桢中锁记录的创建，并且已经将对象头中的MarkWord复制到了自己的锁记录中，然后尝试使用CAS将对象头中的MarkWord修改为指向自己的锁记录的指针，但是由于之前获取到锁的线程已经将对象头中的MarkWord修改过了(并且现在还在执行同步体中的代码,即仍然持有着锁)，所以此时对象头中的MarkWord与当前线程锁记录中MarkWord的值不同，导致CAS操作失败，然后该线程就会不停地循环使用CAS操作试图将对象头中的MarkWord替换为自己锁记录中MarkWord的值，(当循环次数或循环时间达到上限时停止循环)如果在循环结束之前CAS操作成功，那么该线程就可以成功获取到锁，如果循环结束之后依然获取不到锁，则锁获取失败，对象头中的MarkWord会被修改为指向重量级锁的指针，然后这个获取锁失败的线程就会被挂起，阻塞了。</p>
<p> 4&gt;当持有锁的那个线程执行完同步体之后，使用CAS操作将对象头中的MarkWord还原为最初的状态时(将对象头中指向锁记录的指针替换为Displaced Mark Word )，发现MarkWord已被修改为指向重量级锁的指针，因此CAS操作失败，该线程会释放锁并唤起阻塞等待的线程，开始新一轮夺锁之争，而此时，轻量级锁已经膨胀为重量级锁，所有竞争失败的线程都会阻塞，而不是自旋。</p>
<p> 自旋锁：<br>     1)所谓自旋锁，就是让没有获得锁的进程自己运行一段时间自循环(默认开启)，但是不挂起线程。<br>     2)自旋的代价就是该线程会一直占用处理器如果锁占用的时间很短，自旋等待的效果很好，反之，自旋锁会消耗大量处理器资源。<br>     3)因此，自旋的等待时间必须有一定限度，超过限度还没有获得锁，就要挂起线程。  </p>
<p> 优点：在没有多线程竞争的前提下，减少传统的重量级锁带来的性能损耗。<br> 缺点：竞争的线程如果始终得不到锁，自旋会消耗cpu。<br> 应用：追求响应时间，同步块执行速度非常快。  </p>
<h4 id="【重量级锁】"><a href="#【重量级锁】" class="headerlink" title="【重量级锁】"></a>【重量级锁】</h4><ul>
<li>说明：<br>  1)java6之前的synchronized属于重量级锁，效率低下，因为monitor是依赖操作系统的Mutex Lock(互斥量)来实现的。<br>  2)多线程竞争锁时，会引起线程的上下文切换(即在cpu分配的时间片还没有用完的情况下进行了上下文切换)。<br>  3)操作系统实现线程的上下文切换需要从用户态转换到核心态，这个状态之间的转换需要相对较长的时间，时间成本相对较高。<br>  4)在互斥状态下，没有得到锁的线程会被挂起阻塞，而挂起线程和恢复线程的操作都需要从用户态转入内核态中完成。</li>
<li>优点：线程竞争不使用自旋，不会消耗cpu。</li>
<li>缺点：线程阻塞，响应时间缓慢。</li>
<li>应用：追求吞吐量，同步块执行速度较长</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>驾驶相关</title>
    <url>/2019/12/13/md/other/driver-itec/</url>
    <content><![CDATA[<h3 id="车开关"><a href="#车开关" class="headerlink" title="车开关"></a>车开关</h3><p><img src="https://www.mqiy.xyz/image/other/car-lock-info.jpg" alt=""></p>
<ul>
<li><code>LOOK</code> 是拔出钥匙位置，同时方向盘锁死；</li>
<li><code>ACC</code>是车内电气开启，可以听收音机等等；</li>
<li><code>ON</code> 是全车电源开启，及启动后返回位置；</li>
<li><code>START</code>为启动位置，钥匙拧到此处是启动发动机</li>
</ul>
<p>黄金三秒原则：</p>
<p>一般高速行车时，视线不要离开前方超过三秒以上，超过三秒则危险系数指数上升</p>
<p>正踩刹车斜踩油门</p>
<p>判断安全车距</p>
<p>安全车距一般跟认得反应时间有关系。教大家一个比较通俗的方法，一般时速多少公里每小时，则安全距离为多少米，例如高速行车速度100km/h，则安全距离为100米，并平时利用高速的距离指示牌训练自己对于距离的把控。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>关于成熟三</title>
    <url>/2019/12/13/md/life/thinking/mature-three/</url>
    <content><![CDATA[<p>1.主动，想事儿，操心。不会什么都不想，都无所谓，等着，拖着。然后让另一半去做。  </p>
<p>2.不搞情绪。就事论事，而不是感情用事。</p>
<p>3.知道自己能力的边界，对自己的优点缺点性格有清晰的认知，不会头脑发热被人忽悠。</p>
<p>4.学会和现实妥协而不是为了无意义的完美主义反复纠结。</p>
<p>5.知道什么是真实的生活，什么是自己的幻想，不会放下已经拥有的，去追求不切实际的一些东西。</p>
<p>6.对身边的人常常心怀愧疚，觉得自己做的还不够（哪怕外人眼中已经做的很好了）。因为心怀愧疚，所以心怀感恩，不会去嫌弃别人。事实上，越是自己不怎么样的人越喜欢嫌弃别人。</p>
<p>7.不会为过去耿耿于怀，也不会为明天的不确定而神经兮兮。做好自己的分内事，其他随缘。</p>
<p>8.为了照顾别人的感受，有些话宁肯说谎也坚决不说。</p>
<p>9.能够面对真实的残酷，能够道歉，反省自己。不纠缠，不会因为心痛丧失自己的原则。</p>
<p>10.对未来有规划，平日有努力奋斗的目标。而不是夸夸其谈，炫耀自己知道的多，炫耀自己口才好，能说会道。</p>
<p>11.不羞涩，放下自己的面子，去处理难堪的事，去见难堪的人，去说难堪的话。</p>
<p>12.做人有底线，有原则。越界的事坚决不做。</p>
<p>13.不去看不起别人，也不去谄媚别人。知道打铁还需自身硬，自己就是最强的人脉。</p>
<p>14.不会为了事业牺牲家庭，会平衡生活与工作。</p>
]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>间歇性踌躇满志，持续性混吃等死</title>
    <url>/2019/12/13/md/life/current-status/</url>
    <content><![CDATA[<p>前年，我从130斤减到104斤，这不算苗条的身材来之不易，我十分珍惜。</p>
<p>朋友问我秘诀，不过是迈开腿管住嘴，合理运动健康饮食。</p>
<p>可很多人一听要忌口就放弃追问。</p>
<p>我的同事COCO郑重其事地上门取经，我热情分享运动安排以及饮食菜单。</p>
<p>一周后，我好意问她餐食如何？她说晚上涮完重庆火锅，现在捧着薯片追剧。至于计划中的运动，早就抛到九霄云外。</p>
<p>后来，COCO几次试图减肥，都很快以失败告终。</p>
<p>COCO说：</p>
<blockquote>
<p>我就是那种开始劲头十足，后期恒心不足的人。你说要至少坚持一个月，觉得做不到就放弃了。说到底，COCO是患上“间歇性努力症”。</p>
</blockquote>
<p>她无法持久地专注于一件有价值却很艰辛的事，而习惯于在突破的零界点前退却。</p>
<p>古语有云：有志者立长志，无志者常立志。</p>
<p>如果你也和COCO一样面临同样的难题，你应该好好想想，为什么你会陷入“间歇性踌躇满志，持续性混吃等死”的矛盾循环？</p>
<p>为什么你总是“间歇性踌躇满志，持续性混吃等死”？<br>为什么你总是“间歇性踌躇满志，持续性混吃等死”？<br>在我看来，患上“间歇性努力症”主要有下面三种原因。</p>
<h3 id="认知力不足"><a href="#认知力不足" class="headerlink" title="认知力不足"></a>认知力不足</h3><p>最近非常流行一句话：“道理我都懂，就是做不到”。</p>
<p>听起来很沮丧，那请问，你真是懂这个“道理”吗？</p>
<p>在我看来，真正的懂只有一个标准，那就是按照特定的“道理”去执行。</p>
<p>如果你真的懂了，肯定能看到这件事背后的“好处”和可观的“收益”，且这个“好处”和“收益”正是你想要的。当你口口声声称自己懂了，却没有去坚持践行，只能说你根本没弄懂这件事的价值。</p>
<p>老是间歇性努力的人，根子还是在认知层面上出现偏差。</p>
<p>你没弄清楚你的行为和你想要结果之间的关联性，也不清楚持续付出的真正作用，更不明白在既定情况下该如何坚持。</p>
<p>所以你只有不断重复既有地目标，而无法将目标转化为切实的实施步骤。</p>
<p>哲学家孙正聿教授在《哲学通论》里说：熟知非真知。说的就是这个道理，认知力不足，导致我们陷入常立志的怪圈。</p>
<h3 id="高估自己的执行力"><a href="#高估自己的执行力" class="headerlink" title="高估自己的执行力"></a>高估自己的执行力</h3><p>后台曾经有粉丝向我请教写作技巧。我便把这几年整理的心得一条条告诉她。</p>
<p>她听完直摇头：“这么复杂，我没时间学。”</p>
<p>我说：“想学写作，就不能懒，笔头勤快才能出好文章。”</p>
<p>她立马点头说：“对啊，我就是太懒了。如果我努力一点点，肯定也能成名。”</p>
<p>其实，真正阻碍她成长的，并不是懒惰，而恰恰事那种“努力一点点，就能成功”的意识。</p>
<p>有的人总以为不用多费时间和精力就能改变现状，其实根本不然。</p>
<p>每一个小小成功的背后都是日积月累的付出，每一口蜜糖都需要用苦涩的汗水去换取。</p>
<p>而高估自己能力的人，不论做什么，定会陷入一而再再而衰三而竭的困局，最后不了了之。</p>
<p>因为他们对困难认识不足，对自己又过于自信，一旦遇到挫折，不会反省自己，而只会抱怨不公。</p>
<p>这不是懒，而是能力配不上梦想。</p>
<p>如同龟兔赛跑中的兔子，自以为是，跑到半路就躺下来庆功。</p>
<h3 id="执迷于宏大的目标"><a href="#执迷于宏大的目标" class="headerlink" title="执迷于宏大的目标"></a>执迷于宏大的目标</h3><p>一个过于依赖目标导向的人往往无法持续地付出。</p>
<p>罗马不是一天造成的，梦想再美好，最重要的仍是切实可行的方法、步骤和阶段成果。</p>
<p>比如减肥，我们身体堆集的脂肪块不是一蹴而就，我们不可能指望一夜之间塑造完美身材。</p>
<p>变苗条只是一个大目标，为达这个目标，一定会有几个关键性结果。比如一周瘦2斤，每天有氧运动40分钟无氧运动10分钟，每日肉类控制在100克，三餐谷物不超过400克等。</p>
<p>文友柳一一曾分享过一个故事。</p>
<p>作家斯蒂芬·盖斯想要减肥。他最开始按计划做30分钟俯卧撑，发现根本做不到。</p>
<p>直到有一次，盖斯心想，管它呢，随便做一个也好啊。当做完第一个，他觉得很轻松呀，于是就继续做第二个，第三个。</p>
<p>2013年一整年，他都只要求自己每天做一个。</p>
<p>结果是，每次做起来自然不只一个。因为目标被清晰地分解，他能够持续获得满足感。</p>
<p>所以，只有将目标具体到可见的阶段结果，才有执行的可能。</p>
<p>如果一味盯着大梦想，不知将阶段性结果作为执行驱动力，那肯定会陷入间歇性努力的怪圈。</p>
<p>为什么你总是“间歇性踌躇满志，持续性混吃等死”？<br>为什么你总是“间歇性踌躇满志，持续性混吃等死”？<br>明白这些原因，也就不难找到破解的方法。</p>
<h4 id="首先，别关注你不能改变的事"><a href="#首先，别关注你不能改变的事" class="headerlink" title="首先，别关注你不能改变的事"></a>首先，别关注你不能改变的事</h4><p>古希腊哲学中的斯多葛派（Stoicism）提出过控制二分法：生活中，有些事情是你能够控制的，有些事情你是控制不了的。</p>
<p>具体到执行面，就是拿出勇气做你能改变的事，将目标从“外部目标”转化为“内部目标”。</p>
<p>拿减肥来说，不要考虑脂肪这个你无法掌握的累赘，安心做你能控制的事，丢开垃圾食品、放下手中高热量饮品、迈开腿动起来等。再远大的目标，也都从卑微小事开始。</p>
<p>谁都想干大事，不愿在小事上浪费精力，但我们是没办法做“不知道该怎么做”的事，更没办法让自己为“不能改变的事”奋斗。好比你想登天，就算你在原地跳出大窟窿也不可能真的上天。</p>
<p>当我们为能控制的小事不断努力，能力会逐渐增长；随着能力增长，我们能改变的事情就越来越多。如此循环，目标就越来越近。</p>
<h4 id="其次，分解任务，设定阶段奖励"><a href="#其次，分解任务，设定阶段奖励" class="headerlink" title="其次，分解任务，设定阶段奖励"></a>其次，分解任务，设定阶段奖励</h4><p>如果一件事的完成周期过长、过程较复杂，很容易让人望而生畏，分解是必不可少的手段。</p>
<p>分解的最大好处是很容易将阶段性结果提取出来，还可以减少失败风险。</p>
<p>先从简单部分着手。我们大脑的特性是，对于简单而明确的指令，愿意立刻去干，且取得进展的成就感让我们更容易坚持。</p>
<p>OKR工作法则说：任务里困难的部分往往是衡量目标是否实现的关键结果。</p>
<p>面对复杂模糊的指令，大脑的本能是调头跑掉。</p>
<p>不幸的是，生活和工作中80%以上的任务都是复杂的。</p>
<p>既然躲不掉，只能冲上去跟它拼了！在这个阶段，调动我们所有资源和能力，与之死磕。</p>
<h4 id="同时，给自己设定阶段性奖励：当完成某事，奖励某物。若完成的快感本身不能缓解奋斗的辛苦时，奖励不失为一种好刺激。"><a href="#同时，给自己设定阶段性奖励：当完成某事，奖励某物。若完成的快感本身不能缓解奋斗的辛苦时，奖励不失为一种好刺激。" class="headerlink" title="同时，给自己设定阶段性奖励：当完成某事，奖励某物。若完成的快感本身不能缓解奋斗的辛苦时，奖励不失为一种好刺激。"></a>同时，给自己设定阶段性奖励：当完成某事，奖励某物。若完成的快感本身不能缓解奋斗的辛苦时，奖励不失为一种好刺激。</h4><p>我曾在减肥坚持不下去的时候，用少量的甜点奖励自己。</p>
<p>开始吃起来心安理得，后来边吃边自责，因为深知掉下来的肉全是汗水，之后锻炼更努力。这个道理之前听别人说过，但自己切身感受才更明白。</p>
<p>《管理的实践》中说：并不是有了工作才有目标，而是有了目标才能确定工作。</p>
<p>我们先在目标这个终点插上旗贴，再分解成适合自己的不同路线，一个个攻克它。</p>
<h4 id="最后，设想未完成的后果"><a href="#最后，设想未完成的后果" class="headerlink" title="最后，设想未完成的后果"></a>最后，设想未完成的后果</h4><p>任何事情都有后果，判定它是否严重取决于个人。</p>
<p>有些写作平台规定签约作者每个月要过稿2篇，若未完成，下个月复活必须完成4篇。</p>
<p>正是有这样的压力，才会让作者们去克服懒惰的天性，不断精益求精。</p>
<p>你想，每次打开电脑，淘宝、微信、抖音，哪个不比写稿轻松？</p>
<p>可是一到月底，有的人就如热锅上的蚂蚱： 2篇都过不了，写4篇更完不成。</p>
<p>这般一想，还是努力看书，持续地输出优质内容，才能有机会让读者粉丝看到自己的作品。</p>
<p>再比如职场的朋友，多想想，如果年底KPI不过关，后果是：晋升机会拱手让人、年底加薪无望、连累上司没脸。所以还是赶紧工作，提升效率吧。</p>
<p>《自控力》里说：</p>
<blockquote>
<p>当我们打算做某件事情或学习某项技能时，我们的本能会拖延、会效率低下。除了在大脑中演绎失败的各种结果，还可以设想身边人的反应。试想，如果你真的失败了，身边人反应只有两种，亲者惋惜、仇者正中下怀。</p>
</blockquote>
<p>多想想身边人的反应，让自己先被绑架，你就有动力坚持。</p>
<p>为什么你总是“间歇性踌躇满志，持续性混吃等死”？<br>为什么你总是“间歇性踌躇满志，持续性混吃等死”？<br>有句笑谈说：人和猪的区别在于，画一个圈给猪，猪会走出那个圈；画一个圈给人，人却将自己永远锁在圈内。</p>
<p>这样的人，好比井底之蛙。</p>
<p>青蛙没有走出井底，没见过外面世界，至少快乐满足，它以为世界就如此。</p>
<p>间歇性努力的人，是曾经跳出井底又跌落原点的青蛙。他知道身后是万丈深渊，也明白前面天空辽阔，就是不愿付出代价挣脱，只好假装没见过外面的世界。</p>
<p>真的不会后悔吗？当我们老去，最痛苦的事情不是失败，而是我本可以。</p>
<p>为了让曾经的苦难配得上自己的梦想，我们可以一步一步由易到难给自己设定目标付诸实践。</p>
<p>理想总是越想越美，生活却是越做越明。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>关于成熟二</title>
    <url>/2019/12/13/md/life/thinking/mature-two/</url>
    <content><![CDATA[<p>气场和气质绝非一朝一夕炼成，但是好在我们可以观察那些有气场者的一言一行，求上得中地模仿下来，应该也不会差到哪里。</p>
<p>你和什么人请教，和什么人学习，你也会成为什么人。</p>
<p>关于成熟，以下部分，男女共用。</p>
<h4 id="1-不容触碰的界限感"><a href="#1-不容触碰的界限感" class="headerlink" title="1. 不容触碰的界限感"></a>1. 不容触碰的界限感</h4><p>大部分人从小都被灌输了一个及其愚蠢的概念——“多个朋友多条路，少个仇人少堵墙。”</p>
<p>且不论前一句话把人情的交换看的太过便利，今天主要说后半句话——不要怕你得罪人就会碰壁，你身边90%的人你都得罪的起。</p>
<p>他们能做的最多也就是恶心恶心你，动动手指头就能碾碎你的大佬没时间伺候你，没必要仅仅因为怕得罪人就不停地低姿态，不停地让步。</p>
<p>意识到大部分人你都惹得起，就不会不停地为了所谓的“维护形象”而委曲求全，就不会不断地允许对方触碰你的界限，哪个国家不是在边界线上筑高墙拉电网让别国知道不该你进的地方别乱逛？</p>
<p>让别人知道你是一个有界限感的人是一切良好关系的基础——有诚意想当你朋友的人 ，都知道尊重是入场券。</p>
<p>当然，大部分人的界限设置的一塌糊涂自己都不清楚是什么，居然还会认为“和我走的近的人无论怎么做都行”——不行，真的不行，界限就是除自己之外都是外人，神来杀神佛来杀佛，谁说话都不好使。</p>
<p>你去观察那些有威严的大哥大姐们，即使你再是他们的心腹，再对他们忠心耿耿，你们再推心置腹，只要你自以为是的去碰那个他们明示过你别靠近的线，他们也会瞬间拉下脸来问你：</p>
<p>“是不是给你脸给多了，让你觉得你可以没规矩了？”</p>
<h4 id="2-极强的克制力"><a href="#2-极强的克制力" class="headerlink" title="2. 极强的克制力"></a>2. 极强的克制力</h4><p>社会十大俗气：腰有十文钱必振衣作响；每与人言必谈及贵戚；遇美人必急索登床；见到问路之人必作傲睨之态；与朋友相聚便喋喋高吟其酸腐诗文；头已花白却喜唱艳曲；施人一小惠便广布于众；与人交谈便借刁言以逞才；借人之债时其脸如丐，被人索偿时则其态如王；见人常多蜜语而背地却常揭人短处。</p>
<p>十大俗气中至少有七八条是缺乏克制力：炫耀感，色心，虚荣，骄傲……普通人一旦有了资本都恨不得把自己的三瓜两枣直接写在脸上；甚至不惜伪造虚假的经历，就为了刷那一点可怜的存在感。</p>
<p>饭桌上油腻的男人分三类：灌小姑娘酒的；逼着小姑娘唱歌脱鞋跳舞的；为了加个小姑娘微信可劲吹牛逼的。</p>
<p>如果你尚且年轻，且容你张狂或者喜欢上那些张狂的愣头青，毕竟年轻人犯错上帝都会原谅。</p>
<p>但是这些人如果没有克制力，不知道在人前收起来自己的欲望和好胜心，不知道自己沾沾自喜的每一句话都伤了别人的自尊，不明白自己信口胡说的每一个成绩都在把自己往被扒皮石锤的路上推，迟早有一天会有人来告诉他什么叫谦虚，什么叫夹着尾巴做人。</p>
<p>拥有极强克制力不仅仅意味着素养高，还以为着一件事——那些别人吹牛逼的事，他早就经历过，体验过了，当初他玩的时候这群张八二五的小孩子还不知道在哪呢。</p>
<p>只有吃饱的人，才会开始注意自己的吃相，才会宁可少夹几筷子也不愿意给别人留下自己吃相难看的印象。</p>
<h4 id="3-坚定的目标和主次分明的态度"><a href="#3-坚定的目标和主次分明的态度" class="headerlink" title="3.坚定的目标和主次分明的态度"></a>3.坚定的目标和主次分明的态度</h4><p>爱情很宝贵，很美好，但是把爱情当成一生追求目标的人，其实挺没出息的。</p>
<p>因为动不动就想着遇到更好的人的人们往往忽略了一个事：在没实现自我价值，你自己都不算活明白的前提下，遇到对的人你也留不住。</p>
<p>况且是谁给你的勇气和自信让你觉得更好的人会闯入你的生命之中？</p>
<p>物以类聚，人以群分，人和人之间分圈子的。圈子和圈子之间有着界限分明的壁垒。</p>
<p>因此聪明人都知道，想要嫁给白马王子就得先让自己进入皇室得到认可；而不是苦哈哈的恳求老天开眼让白马王子微服私访来到自己的一亩三分地。</p>
<p>有着坚定的目标，把实现人生的价值列为自己的目标，专心的为自己的目标前行——你要知道，财富，爱情还有尊重都是实现自我价值的附属品罢了。</p>
<h4 id="4-说一不二的决绝态度"><a href="#4-说一不二的决绝态度" class="headerlink" title="4.说一不二的决绝态度"></a>4.说一不二的决绝态度</h4><p>我开过一个玩笑：其实百分之七十的情感问题，都能用一句无脑的“分手下一位”来解决。</p>
<p>但是你们做不到啊，她明明就是一个榨取你价值的吸血鬼，你却还把她视若珍宝；他明明就是一个天诛地灭的妈宝男，你还当他孝顺。人最擅长逆向合理化，你对他的感情渐渐由最初的纠结，变得为他开脱，甚至最后说服自己自己也就找个这样的了。</p>
<p>早就该扔得东西死活不扔，一边攥在手里一遍自我麻痹说这个东西有纪念意义，这种人叫囤积癖。</p>
<p>而早就该分手，却舍不得自己投资的时间精力情感，傻乎乎的指望浪子回头的人，叫情感囤积癖。</p>
<p>他们到了最后，被人拖下水，自己搭进去不说，也被折磨的早就没了当初的吸引力。</p>
<h4 id="5-“敢要”的底气"><a href="#5-“敢要”的底气" class="headerlink" title="5.“敢要”的底气"></a>5.“敢要”的底气</h4><p><code>敢要，一定要敢要</code>。</p>
<p>我们从小到大被教育的，真的太客气了，客气到连基本的保护自己应得的东西都不会了。</p>
<p>我们长大之后，又太有绅士风度，太独立太女权了，都不知道让对方适当的为我们付出了。</p>
<p>凭什么你为他做什么也乐意啊？你妈知道平时在家洗个碗都闹情绪的你在外面这么好说话吗？</p>
<p>凭什么你就喜欢给她花钱，她收礼物收的心安理得啊？你爹妈知道你这么大方，从你工作后没沾上一点光的老两口会不会被你气出病来？</p>
<p>我说过，人一定要知道自己几斤几两，不是你的东西，你看都不要看。</p>
<p>但是我也说过，人也应该有自己的底气，不是我的我不要，我应得的绝对不和你客气。</p>
<hr>
<p>以上这些话，看似颠覆，看似攻击性强，但殊不知人都是缺乏安全感的——他们理所应当的，会倾向于那些看起来有强硬生存价值，能够保护自己的人。</p>
<p>而我们现在所推崇的物质条件，内涵，甚至是外貌，都不过是这种气质的附属品——会所里最不缺的就是嫩的掐得出水的小姑娘，但是这些人一开口说话你就觉得哪里不对。</p>
<p>而修炼这种气质，总需要日复一日的坚持，甚至拒绝一些曾经你看起来重要无比的人情，减少一些油腻无意义的社交。</p>
<p>肯定有人不愿意的，肯定有人说太累了，也肯定有人说这不实际。</p>
<p>没有关系，知乎上每天都有不停地问题和答案明明白白的告诉你怎么成为更好的人，怎么让自己更受人尊重。但是人世间，总要有人住高堂有人住阴沟——人各有志，有的人追求的东西更贵罢了。</p>
<p>大家各走各的窄门好了。</p>
]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>男人心智成熟的表现有哪些？</title>
    <url>/2019/12/13/md/life/thinking/thinking-mature/</url>
    <content><![CDATA[<p>1、放弃了无效社交,也放弃了一些人.</p>
<p>2、知道不搭配锋芒的善良就是懦弱.</p>
<p>3、知道人生的标准不在别人手中,只在自己手中,不会活在别人的想法和评价里.</p>
<p>4、会合理维护自己的立场,懂得合理拒绝,不怕麻烦别人.</p>
<p>5、在价值上,把自己当一回事,在面子上,能把自己不当一回事.</p>
<p>6、自律且懂得保持让自己精力旺盛,知道任何事情到最后都是个人的坚持.</p>
<p>7、注意力很少再放到无目的娱乐消费上,而是找到了自己的方向开始为之奋斗,会放下不舍的事物,尽管曾经喜欢.</p>
<p>8、看待事物不再是绝对的对错,而是多方维度求解懂得拿捏分寸,但做决定又非常果断.</p>
<p>9、不轻易交浅言深,知道每个人都有每个人的难处,不再夸夸其谈,而是选择平静听人诉说</p>
<p>10、内方外圆,既能圆滑应对外在人际关系,又能守护内心真正的善良.</p>
<p>11、知道选择必须要放弃，放弃就会有痛苦，痛苦才会有撕裂般疼痛，才会长肌肉变得更加强大，而变坏只需要什么都不做就可以了。</p>
<p>12、从对谁都善良，到选择对谁善良。</p>
<p>13、对自我和现实的残酷有清醒的认知</p>
<p>14、对事物的态度不再抱有太高的期待,能坦然面对,很少再去抱怨不公.</p>
<p>15、能认清分开扮演社会、公司、制度赋予给我们被动的角色,完成附加给我们要遵守的规范和准则. 又能给自己重新定义一个自己,在自己的准则里活出自己的模样.</p>
<hr>
<p>2019.11.5更新</p>
<p>16、知世故而不世故，沉稳而不失活泼，</p>
<p>17、从杀死了自己内心的小孩那一刻变得冷血残暴,是豺狼. 后来内心的小男孩涅槃重生的那一刻,变成了仁慈的狮子.</p>
<p>18、你知道有些喜欢啊,只能默默放在心里,不一定需要去拥有.</p>
<p>19、如果你讨厌的人骂你,那你一定是做对了什么.</p>
<hr>
<p>2019.11.11更新</p>
<p>20、感情是靠吸引过来的,而不是做舔狗做来的,你能舔别人也能做舔.表白从来都是胜利的宣言,而不是冲锋的号角.</p>
<p>21、所谓少年感，不是无知而无畏，而是有知仍无畏。</p>
<p>22、“人的崩溃是悄无声息的,失望攒多后，真正的离开是不动声色的。”</p>
<p>降低期待值，强大自己的内心，靠自己。<br>23、想问题的第一时间是去了解别人的诉求,追求的是双赢,而不是展示自己很厉害.</p>
<hr>
<p>2019.11.12更新</p>
<p>24、保持谦卑之心,每个人都有你能学习的地方.</p>
<p>25、学会自嘲.</p>
<p>26、对己能驾驭人性,对人能顺应其人性</p>
<p>27、以上观点,不一定正确,所以不要盲目相信,人无完人,观点肯定是有错误的.最重要的锻炼独立思考能力,有质疑的能力,对事不对人.</p>
]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树</title>
    <url>/2019/12/12/md/develop/base/data-structure/binary-search-tree/</url>
    <content><![CDATA[<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>1、左子树上所有的节点的值均小于或等于他的根节点的值</li>
<li>2、右子数上所有的节点的值均大于或等于他的根节点的值</li>
<li>3、左右子树也一定分别为二叉排序树</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>o(1), o(n), o(logn), o(nlogn)</title>
    <url>/2019/12/12/md/develop/base/al/time-complexity/</url>
    <content><![CDATA[<p>在描述算法复杂度时,经常用到<code>o(1), o(n), o(logn), o(nlogn)</code>来表示对应算法的<code>时间复杂度</code>, 这里进行归纳一下它们代表的含义:<br>这是算法的时空复杂度的表示。不仅仅用于表示时间复杂度，也用于表示空间复杂度。<br>O后面的括号中有一个函数，指明某个算法的耗时/耗空间与数据增长量之间的关系。其中的n代表输入数据的量。 </p>
<ul>
<li>O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。 </li>
<li>O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。 </li>
<li>O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。 </li>
<li>O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。 </li>
<li>O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>穿衣尺码</title>
    <url>/2019/12/11/md/other/clothes-size/</url>
    <content><![CDATA[<h3 id="卫衣尺码"><a href="#卫衣尺码" class="headerlink" title="卫衣尺码"></a>卫衣尺码</h3><table>
<thead>
<tr>
<th>尺码</th>
<th>衣长</th>
<th>肩宽</th>
<th>胸围</th>
<th>袖长</th>
</tr>
</thead>
<tbody><tr>
<td>170/92A/M</td>
<td>68</td>
<td>46</td>
<td>56</td>
<td>61</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年12月日志</title>
    <url>/2019/12/10/md/problem/work/19-12/</url>
    <content><![CDATA[<h3 id="战网第三方登录时，请求的参数误写成json格式，当作body传入"><a href="#战网第三方登录时，请求的参数误写成json格式，当作body传入" class="headerlink" title="战网第三方登录时，请求的参数误写成json格式，当作body传入"></a>战网第三方登录时，请求的参数误写成json格式，当作body传入</h3><blockquote>
<p> 应该拼接到url后面</p>
</blockquote>
<h3 id="战网第三方登录时，提示“无效的grant-type或无效的回调地址“"><a href="#战网第三方登录时，提示“无效的grant-type或无效的回调地址“" class="headerlink" title="战网第三方登录时，提示“无效的grant_type或无效的回调地址“"></a>战网第三方登录时，提示“无效的grant_type或无效的回调地址“</h3><blockquote>
<p>在战网管理平台把回调地址与授权地址配置反了</p>
</blockquote>
<h4 id="restTemplate有并发问题-200ms内，连接返回错乱"><a href="#restTemplate有并发问题-200ms内，连接返回错乱" class="headerlink" title="restTemplate有并发问题  200ms内，连接返回错乱"></a>restTemplate有并发问题  200ms内，连接返回错乱</h4><h4 id="支付宝支付成功后，redirect出错"><a href="#支付宝支付成功后，redirect出错" class="headerlink" title="支付宝支付成功后，redirect出错"></a>支付宝支付成功后，redirect出错</h4><p>显示最终回调地址为<code>http://casaba-commerce-mall-sandbox.cloud.bz/casaba-mall/trade/sendRedirectUrl/philips-lighting-uat.baozun.com/pay.html?orderNo=119120518391148212</code><br>而真正服务器地址为: <code>casaba-commerce-mall-sandbox.cloud.bz</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.redirect(<span class="string">'philips-lighting-uat.baozun.com/pay.html?orderNo=119120518391148212'</span>);</span></pre></td></tr></table></figure>
<blockquote>
<p>重定向地址没有带协议，导致默认把当前mapper url拼接在前面</p>
</blockquote>
<p><code>反思</code></p>
<ul>
<li>为何当前mapping url的域名是错误的，是一个不存在的域名，导致排查困难</li>
<li>有其他正常的项目，没有去对比数据</li>
<li>redirect 没有搞清楚使用</li>
</ul>
<h3 id="网页微信第三方登录-回调路径的域名必须与微信商户后台授权域名一致"><a href="#网页微信第三方登录-回调路径的域名必须与微信商户后台授权域名一致" class="headerlink" title="网页微信第三方登录  回调路径的域名必须与微信商户后台授权域名一致"></a>网页微信第三方登录  回调路径的域名必须与微信商户后台授权域名一致</h3>]]></content>
      <tags>
        <tag>problem</tag>
      </tags>
  </entry>
  <entry>
    <title>paxos</title>
    <url>/2019/12/06/md/develop/base/al/paxos/</url>
    <content><![CDATA[<h4 id="1、Paxos算法的应用"><a href="#1、Paxos算法的应用" class="headerlink" title="1、Paxos算法的应用"></a>1、Paxos算法的应用</h4><p>Paxos算法及变种算法在分布式系统中应用广泛。<br>基于Paxos算法的变种有：ZAB、Raft<br>    • Zookeeper 中的ZAB协议也是Paxos算法的变种。Zookeeper通过ZAB协议实现数据一致性，以提供数据一致性。<br>    • Nutanix 中通过Paxos算法实施元数据在各节点的强一致性。</p>
<h4 id="2、什么是Paxos算法"><a href="#2、什么是Paxos算法" class="headerlink" title="2、什么是Paxos算法"></a>2、什么是Paxos算法</h4><p>Paxos算法解决的问题是在一个可能发生消息可能会延迟、丢失、重复的分布式系统中如何就<code>某个值达成一致</code>，保证不论发生以上任何异常，都不会破坏决议的一致性。这 个“值”可能是一个数据的某，也可能是一条LOG等；根据不同的应用环境这个“值”也不同。<br>一个典型的场景:在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。</p>
<h4 id="3、Paxos算法的原理"><a href="#3、Paxos算法的原理" class="headerlink" title="3、Paxos算法的原理"></a>3、Paxos算法的原理</h4><p>例如：公司商定年会举办的地点，每个人都可以提出建议。在现实环境中我们可以在一个会议室共同讨论或在微信群中讨论（基于内存共享方式）；但在基于消息传递的分布式环境中每个人只能通过手机短信与其它人通过。如何在这种会延迟、丢失的环境中确定一个年会举办地点；</p>
<p>Paxos算法是这样解决这个问题：</p>
<ul>
<li>1、每个人都可以提出建议、同意建议、接受建议</li>
<li>2、少数服从多数。只要建议被多数人同意即可确定该建议。</li>
</ul>
<p>于是确定以下讨论方式：</p>
<ul>
<li>1、只有被提出来的建议才能被大家同意。</li>
<li>2、最终只能确定一个建议</li>
<li>3、如果某个人认为大家同意了某 个建议，那么这个建议必须真的是被大家同意的</li>
</ul>
<h4 id="算法推论"><a href="#算法推论" class="headerlink" title="算法推论"></a>算法推论</h4><h5 id="情况一：如果只有一个人提出建议怎么办？"><a href="#情况一：如果只有一个人提出建议怎么办？" class="headerlink" title="情况一：如果只有一个人提出建议怎么办？"></a>情况一：如果只有一个人提出建议怎么办？</h5><p>如果只有一个建议被提出来那么大家必须同这个建议，因为如果不同意这个建议就无法确定一个年会举办地点。<br>所以得出这样的结论：<br>P1:<code>每一个人必须同意他收到的第一个建议</code><br>基于这样的结论会出现以下问题：<br><img src="https://www.mqiy.xyz/image/algorithm/paxos-example-01.jpg" alt=""><br>张三给王五发短信说：我建议去上海举办年会！<br>王五给李四发短信说：我建议去广州举办年会！<br>李四给张三发短信说：我建议去北京举办年会！</p>
<p>根据P1：每个人必须同意他收到的第一个建议，那么张三、李四、王五最终获得的信息是不一致的。</p>
<p>所以再次规定：一个提议必须被大多数人同意才能生效。<br>那么说明一个人可以同时同意多个建议，如果一个人可以同时同意多个建议最终可能出现拜占庭将军问题导致最终结果不一致。（例如：张三同意到北京举办也同意到广州举办，那么李四将获得2票一票自己的，一票张三的。他会认为自己获得多数人支持所以就确定最终是到北京举办，同理王五也会同时获得2票，也认为大家最终决定到广州举办）；</p>
<p>所以要避免出现这种问题，某个人只要同意的多个提议中的内容相同（公司举办的地址）就不会出现这种问题。<br><img src="https://www.mqiy.xyz/image/algorithm/paxos-example-02.jpg" alt=""><br>    最终协商结果是有2票是到同一个地方，这样就可以确认最终举办地！<br>    那么就会引出 这样的一个结论：<br>    P2:一旦同意某个建议，那么之后同意的建议中提议公司举办年会的地址必须一致。<br>    问题出来了：如何确定什么是“之前”，什么 是“之后”<br>    所以必须为提议分配一个编号，在提议之间建立一个全序关系。</p>
<h5 id="情况二：-其他节点失联"><a href="#情况二：-其他节点失联" class="headerlink" title="情况二： 其他节点失联"></a>情况二： 其他节点失联</h5><p>当张三、李四、王五三个人确定最终到郑州举办年会后。赵六、孙七2人由于手机没电，没收到通知，当他们2人开机后赵六给孙七发短信提议到海南举办，这个提议是孙七开机后第一次收到的提议，根据P1原则，他必须同意他接收到的第一个提议，所以孙七同意到海南举行年会。但这样就会导致孙七与张三、李四、王五他们确定的举办地点不一致。</p>
<p><img src="https://www.mqiy.xyz/image/algorithm/paxos-example-03.jpg" alt="">  </p>
<p>为了避免出现以上问题。对P2进行具体说明：<br>P2a:<code>一旦一个提议被大家同意，那么之后的人再次同意的提议中的公司举办年会的地址必须一致</code>。<br>也就是说，孙七在开机后同意的第一个提议必须是“到郑州举办”才不会出现信息不一致的现象。但孙七开机后必须得接受第一个提议（P1原则），并且无法干涉提议中的内容（公司举办年会的地址）。所以最好的办法通过某种方式让赵六的提议中的内容与张三、李四同意的地址相同（到郑州举行）。这样孙七同意的第一个提议就是“到郑州举办”</p>
<p>我们再次对P2a进行修改：<br>P2b:<code>一旦一个提议被大家同意，那么之后的人再次提议，提议中的公司举办年会的地址必须跟之前其它人同意的地址一致</code>。</p>
<p>如何让刚开机的赵六提议的内容必须与张三、李四、王五讨论出来的一致（到郑州举行）？</p>
<p>我们继续对P2b进行强化修改：<br>P2c:<code>如果有一个编号为N的提议具有V(提议的内容)，那么存在一个多数派，要么他们中所有人都没有同意编号小于N的任何提议，要么他们已经同意的所有编号小于N的提案中编号最大的那个提案具有V</code>。</p>
<p>要满足P2c的要求，提议人在提议之前，首先要和多数人通信并获得他们进行的最后一次同意的提议。之后根据反馈的信息决定这次提议的内容，形成提议开始投票！</p>
<p>所以整个投票决议分两个阶段：<br>1、准备阶段<br>    1、提议人选择一个编号N，并将准备信息发送给多数人。<br>    2、如果收信人收到准备消息后，如果提议的编号大于它已经回复的所有准备信息。那么收信人将自己上次接受的提议内容回复给提议人，并承诺不再回复小于N的提议。<br>2、同意阶段<br>    1、当一个提议人收到多数人反馈的信息后，就进入同意阶段。它要向反馈给它信息的人再次发送一个请同意该提议的请求。包含编号N和根据P2C决定的提议内容（如果回复中没有反馈他们已经接受过的提议内容，则可以自由决定提议内容）<br>    2、在不违背向其它人承诺的前提下，收到该提议请求后立即同意该请求。</p>
<hr>
<h4 id="举例说明一下："><a href="#举例说明一下：" class="headerlink" title="举例说明一下："></a>举例说明一下：</h4><p>假设：只有User1、User2、User3 三个人决定1+1等于几！</p>
<h5 id="1、准备阶段"><a href="#1、准备阶段" class="headerlink" title="1、准备阶段"></a>1、准备阶段</h5><p><img src="https://www.mqiy.xyz/image/algorithm/paxos-example-04.jpg" alt="">     </p>
<ul>
<li><p>1、User1  提案编号为1 并发送给User2和User3。<br>  因User2 和User3 根据P2c它们并没有接受过小于编号为1的提案。所以它们可以接受该提议，并反馈给User1 不再接受小于编号1的提案。这时User1收到多数人的回复，将进入第2阶段。（如果收到的回复并不能形成多数人，那么将再次进入阶段1）</p>
</li>
<li><p>2、User2 提案编号为2  ；并发送给User1和User3。<br>  因User1第一次收到提案，并且根据P2C它并没有同意过小于编号为2的提议，所以它可以接受该提议。User3由于接受过User1编号为1的提案，但User2的提案编号2&gt;1所以User3也可以同意User2的提议，并反馈不再接受小于2的提议。User2也收到多数人的回复，将进行第2阶段。</p>
</li>
<li><p>3、User3提案编号为3 ；并发送给user1 和user2 .<br>  因user1收到user3编号为3的提案&gt;user2编号为2的提案，所以接受user3的提案。<br>  因user2收到User3编号为3的提案&gt;user1 编号为1的提案，所以接受user3的提案。<br>  至些user3也收到多数人回复，将进行第2阶段。</p>
</li>
</ul>
<h5 id="2、提议阶段："><a href="#2、提议阶段：" class="headerlink" title="2、提议阶段："></a>2、提议阶段：</h5><ul>
<li><p>1、user1 发送编号为1的提议，提议内容为：1+1=1；并发送给user2和User3 。<br>  由于user2已经声明不再接受小于3的提案，所以拒绝user1的提案。<br>  由于User3已经声明不再接受小于2的提案，所以同样拒绝User1的提案。<br>  User1提议被多数人拒绝，再次进入阶段1.</p>
</li>
<li><p>2、user2 发送编号为2的提议，提议内容为：1+1=2；并发送给User1和User3<br>  由于User1已经声明不再接受小于3的提案，所以拒绝user2的提议。<br>  由于User3已经声明不再接受小于2的提案，该提案编号=2所以user3同意User2的提议。<br>  但User2并没有获得多数人的同意，所以同样进行阶段1.</p>
</li>
<li><p>3、User3 发送编号为3的提议，提议内容为：1+1=3；并发送给User1和User2;<br>  由于user1声明不再接受小于3的提案，所以同意User3的提议。<br>  由于 user2声明不再接受小于3的提案，所以同意User3的提议。</p>
</li>
</ul>
<p>至此最终User3可以获得多数人的同意。  </p>
<hr>
<h4 id="4、Paxos算法图解："><a href="#4、Paxos算法图解：" class="headerlink" title="4、Paxos算法图解："></a>4、Paxos算法图解：</h4><p><img src="https://www.mqiy.xyz/image/algorithm/paxos.png" alt="Paxos算法图"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>拜占庭将军问题</title>
    <url>/2019/12/06/md/develop/base/al/Byzantine-failures/</url>
    <content><![CDATA[<p>拜占庭将军问题（Byzantine failures）的本质：如何让众多完全<code>平等的节点针对某一状态达成共识</code></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 编程技巧之数据结构</title>
    <url>/2019/12/03/md/jdk/java-code-tip/</url>
    <content><![CDATA[<a id="more"></a>

<p>唐宋八大家之一欧阳修在《卖油翁》中写道：<br>翁取一葫芦置于地，以钱覆其口，徐以杓酌油沥之，自钱孔入，而钱不湿。因曰：“我亦无他，唯手熟尔。”<br>编写代码的”老司机”也是如此，”老司机”之所以被称为”老司机”，原因也是”无他，唯手熟尔”。编码过程中踩过的坑多了，获得的编码经验也就多了，总结的编码技巧也就更多了。总结的编码技巧多了，凡事又能够举一反三，编码的速度自然就上来了。笔者从数据结构的角度，整理了一些 Java 编程技巧，以供大家学习参考。</p>
<h4 id="使用HashSet判断主键是否存在"><a href="#使用HashSet判断主键是否存在" class="headerlink" title="使用HashSet判断主键是否存在"></a>使用HashSet判断主键是否存在</h4><p>HashSet 实现 Set 接口，由哈希表（实际上是 HashMap ）实现，但不保证 set  的迭代顺序，并允许使用 null 元素。HashSet 的时间复杂度跟 HashMap 一致，如果没有哈希冲突则时间复杂度为 O(1) ，如果存在哈希冲突则时间复杂度不超过 O(n) 。所以，在日常编码中，可以使用 HashSet 判断主键是否存在。</p>
<p>案例：给定一个字符串(不一定全为字母)，请返回第一个重复出现的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 查找第一个重复字符 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">findFirstRepeatedChar</span><span class="params">(String string)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 检查空字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (Objects.isNull(string) || string.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 查找重复字符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">char</span>[] charArray = string.toCharArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Set charSet = <span class="keyword">new</span> HashSet&lt;&gt;(charArray.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="keyword">char</span> ch : charArray) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (charSet.contains(ch)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span> ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       charSet.add(ch);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 默认返回为空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中，由于 Set 的 add 函数有个特性——如果添加的元素已经再集合中存在，则会返回 false 。可以简化代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!charSet.add(ch)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>




<h4 id="使用HashMap存取键值映射关系"><a href="#使用HashMap存取键值映射关系" class="headerlink" title="使用HashMap存取键值映射关系"></a>使用HashMap存取键值映射关系</h4><p>简单来说，HashMap 由数组和链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。如果定位到的数组位置不含链表，那么查找、添加等操作很快，仅需一次寻址即可，其时间复杂度为 O(1) ；如果定位到的数组包含链表，对于添加操作，其时间复杂度为 O(n) ——首先遍历链表，存在即覆盖，不存在则新增；对于查找操作来讲，仍需要遍历链表，然后通过key对象的 equals 方法逐一对比查找。从性能上考虑， HashMap 中的链表出现越少，即哈希冲突越少，性能也就越好。所以，在日常编码中，可以使用 HashMap 存取键值映射关系。</p>
<p>案例：给定菜单记录列表，每条菜单记录中包含父菜单标识（根菜单的父菜单标识为 null ），构建出整个菜单树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 菜单DO类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuDO</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 菜单标识 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 菜单父标识 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> Long parentId;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 菜单名称 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 菜单链接 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> String url;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 菜单VO类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuVO</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 菜单标识 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 菜单名称 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 菜单链接 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> String url;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 子菜单列表 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> List&lt;MenuVO&gt; childList;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 构建菜单树函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;MenuVO&gt; <span class="title">buildMenuTree</span><span class="params">(List&lt;MenuDO&gt; menuList)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 检查列表为空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (CollectionUtils.isEmpty(menuList)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> Collections.emptyList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 依次处理菜单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">int</span> menuSize = menuList.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   List&lt;MenuVO&gt; rootList = <span class="keyword">new</span> ArrayList&lt;&gt;(menuSize);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Map&lt;Long, MenuVO&gt; menuMap = <span class="keyword">new</span> HashMap&lt;&gt;(menuSize);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span> (MenuDO menuDO : menuList) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 赋值菜单对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       Long menuId = menuDO.getId();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       MenuVO menu = menuMap.get(menuId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (Objects.isNull(menu)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           menu = <span class="keyword">new</span> MenuVO();</span></pre></td></tr><tr><td class="code"><pre><span class="line">           menu.setChildList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">           menuMap.put(menuId, menu);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       menu.setId(menuDO.getId());</span></pre></td></tr><tr><td class="code"><pre><span class="line">       menu.setName(menuDO.getName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">       menu.setUrl(menuDO.getUrl());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 根据父标识处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       Long parentId = menuDO.getParentId();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (Objects.nonNull(parentId)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="comment">// 构建父菜单对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           MenuVO parentMenu = menuMap.get(parentId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">if</span> (Objects.isNull(parentMenu)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               parentMenu = <span class="keyword">new</span> MenuVO();</span></pre></td></tr><tr><td class="code"><pre><span class="line">               parentMenu.setId(parentId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               parentMenu.setChildList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">               menuMap.put(parentId, parentMenu);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           </span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="comment">// 添加子菜单对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           parentMenu.getChildList().add(menu);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="comment">// 添加根菜单对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           rootList.add(menu);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 返回根菜单列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> rootList;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="使用-ThreadLocal-存储线程专有对象"><a href="#使用-ThreadLocal-存储线程专有对象" class="headerlink" title="使用 ThreadLocal 存储线程专有对象"></a>使用 ThreadLocal 存储线程专有对象</h4><p>ThreadLocal 提供了线程专有对象，可以在整个线程生命周期中随时取用，极大地方便了一些逻辑的实现。</p>
<p>常见的 ThreadLocal 用法主要有两种：<br>1、保存线程上下文对象，避免多层级参数传递；<br>2、保存非线程安全对象，避免多线程并发调用。</p>
<p>保存线程上下文对象，避免多层级参数传递</p>
<p>这里，以 PageHelper 插件的源代码中的分页参数设置与使用为例说明。</p>
<p>设置分页参数代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 分页方法类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PageMethod</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 本地分页 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Page&gt; LOCAL_PAGE = <span class="keyword">new</span> ThreadLocal&lt;Page&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 设置分页参数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLocalPage</span><span class="params">(Page page)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       LOCAL_PAGE.set(page);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取分页参数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Page&lt;T&gt; <span class="title">getLocalPage</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> LOCAL_PAGE.get();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 开始分页 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Page&lt;E&gt; <span class="title">startPage</span><span class="params">(<span class="keyword">int</span> pageNum, <span class="keyword">int</span> pageSize, <span class="keyword">boolean</span> count, Boolean reasonable, Boolean pageSizeZero)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       Page&lt;E&gt; page = <span class="keyword">new</span> Page&lt;E&gt;(pageNum, pageSize, count);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       page.setReasonable(reasonable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       page.setPageSizeZero(pageSizeZero);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       Page&lt;E&gt; oldPage = getLocalPage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (oldPage != <span class="keyword">null</span> &amp;&amp; oldPage.isOrderByOnly()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           page.setOrderBy(oldPage.getOrderBy());</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       setLocalPage(page);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> page;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>使用分页参数代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 虚辅助方言类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHelperDialect</span> <span class="keyword">extends</span> <span class="title">AbstractDialect</span> <span class="keyword">implements</span> <span class="title">Constant</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取本地分页 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Page&lt;T&gt; <span class="title">getLocalPage</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> PageHelper.getLocalPage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取分页SQL */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getPageSql</span><span class="params">(MappedStatement ms, BoundSql boundSql, Object parameterObject, RowBounds rowBounds, CacheKey pageKey)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       String sql = boundSql.getSql();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       Page page = getLocalPage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       String orderBy = page.getOrderBy();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (StringUtil.isNotEmpty(orderBy)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           pageKey.update(orderBy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">           sql = OrderByParser.converToOrderBySql(sql, orderBy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (page.isOrderByOnly()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span> sql;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> getPageSql(sql, page, pageKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">使用分页插件代码：</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 查询用户函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageInfo&lt;UserDO&gt; <span class="title">queryUser</span><span class="params">(UserQuery userQuery, <span class="keyword">int</span> pageNum, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> PageHelper.startPage(pageNum, pageSize);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> List&lt;UserDO&gt; userList = userDAO.queryUser(userQuery);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> PageInfo&lt;UserDO&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(userList);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">return</span> pageInfo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>如果要把分页参数通过函数参数逐级传给查询语句，除非修改 MyBatis 相关接口函数，否则是不可能实现的。</p>
<p>保存非线程安全对象，避免多线程并发调用</p>
<p>在写日期格式化工具函数时，首先想到的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 日期模式 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATE_PATTERN = <span class="string">"yyyy-MM-dd"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 格式化日期函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(Date date)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(DATE_PATTERN).format(date);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>其中，每次调用都要初始化 DateFormat 导致性能较低，把 DateFormat 定义成常量后的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 日期格式 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateFormat DATE_FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 格式化日期函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(Date date)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> DATE_FORMAT.format(date);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>由于 SimpleDateFormat 是非线程安全的，当多线程同时调用 formatDate 函数时，会导致返回结果与预期不一致。如果采用 ThreadLocal 定义线程专有对象，优化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 本地日期格式 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; LOCAL_DATE_FORMAT = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 格式化日期函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(Date date)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> LOCAL_DATE_FORMAT.get().format(date);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这是在没有线程安全的日期格式化工具类之前的实现方法。在 JDK8 以后，建议使用 DateTimeFormatter 代替 SimpleDateFormat ，因为 SimpleDateFormat 是线程不安全的，而 DateTimeFormatter 是线程安全的。当然，也可以采用第三方提供的线程安全日期格式化函数，比如 apache 的 DateFormatUtils 工具类。</p>
<p>注意：ThreadLocal 有一定的内存泄露的风险，尽量在业务代码结束前调用 remove 函数进行数据清除。</p>
<h4 id="使用-Pair-实现成对结果的返回"><a href="#使用-Pair-实现成对结果的返回" class="headerlink" title="使用 Pair 实现成对结果的返回"></a>使用 Pair 实现成对结果的返回</h4><p>在 C/C++ 语言中， Pair （对）是将两个数据类型组成一个数据类型的容器，比如 std::pair 。</p>
<p>Pair 主要有两种用途：<br>1、把 key 和 value 放在一起成对处理，主要用于 Map 中返回名值对，比如 Map 中的 Entry 类；<br>2、当一个函数需要返回两个结果时，可以使用 Pair 来避免定义过多的数据模型类。</p>
<p>第一种用途比较常见，这里主要说明第二种用途。</p>
<p>定义模型类实现成对结果的返回</p>
<p>函数实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 点和距离类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PointAndDistance</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 点 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> Point point;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 距离 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> Double distance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 获取最近点和距离 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PointAndDistance <span class="title">getNearestPointAndDistance</span><span class="params">(Point point, Point[] points)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 检查点数组为空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (ArrayUtils.isEmpty(points)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 获取最近点和距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   Point nearestPoint = points[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">double</span> nearestDistance = getDistance(point, points[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">double</span> distance = getDistance(point, point[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (distance &lt; nearestDistance) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           nearestDistance = distance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           nearestPoint = point[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 返回最近点和距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> PointAndDistance(nearestPoint, nearestDistance);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>函数使用案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point point = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Point[] points = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">PointAndDistance pointAndDistance = getNearestPointAndDistance(point, points);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Objects.nonNull(pointAndDistance)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Point point = pointAndDistance.getPoint();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Double distance = pointAndDistance.getDistance();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>使用 Pair 类实现成对结果的返回</p>
<p>在 JDK 中，没有提供原生的 Pair 数据结构，也可以使用 Map::Entry 代替。不过， Apache 的 commons-lang3 包中的 Pair 类更为好用，下面便以 Pair 类进行举例说明。</p>
<p>函数实现代码：<br>/** 获取最近点和距离 */</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;Point, Double&gt; <span class="title">getNearestPointAndDistance</span><span class="params">(Point point, Point[] points)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 检查点数组为空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (ArrayUtils.isEmpty(points)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 获取最近点和距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   Point nearestPoint = points[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">double</span> nearestDistance = getDistance(point, points[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">double</span> distance = getDistance(point, point[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (distance &lt; nearestDistance) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           nearestDistance = distance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           nearestPoint = point[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 返回最近点和距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> Pair.of(nearestPoint, nearestDistance);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>函数使用案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point point = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Point[] points = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Pair&lt;Point, Double&gt; pair = getNearestPointAndDistance(point, points);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Objects.nonNull(pair)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Point point = pair.getLeft();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Double distance = pair.getRight();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="定义-Enum-类实现取值和描述"><a href="#定义-Enum-类实现取值和描述" class="headerlink" title="定义 Enum 类实现取值和描述"></a>定义 Enum 类实现取值和描述</h4><p>在 C++、Java 等计算机编程语言中，枚举类型（Enum）是一种特殊数据类型，能够为一个变量定义一组预定义的常量。在使用枚举类型的时候，枚举类型变量取值必须为其预定义的取值之一。</p>
<p>用 class 关键字实现的枚举类型</p>
<p>在 JDK5 之前， Java 语言不支持枚举类型，只能用类（class）来模拟实现枚举类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 订单状态枚举 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStatus</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 属性相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 状态取值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 状态描述 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String description;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 常量相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 已创建(1) */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OrderStatus CREATED = <span class="keyword">new</span> OrderStatus(<span class="number">1</span>, <span class="string">"已创建"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 进行中(2) */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OrderStatus PROCESSING = <span class="keyword">new</span> OrderStatus(<span class="number">2</span>, <span class="string">"进行中"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 已完成(3) */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OrderStatus FINISHED = <span class="keyword">new</span> OrderStatus(<span class="number">3</span>, <span class="string">"已完成"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">OrderStatus</span><span class="params">(<span class="keyword">int</span> value, String description)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.value = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.description = description;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取状态取值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取状态描述 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> description;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>用 enum 关键字实现的枚举类型</p>
<p>JDK5 提供了一种新的类型—— Java 的枚举类型，关键字 enum 可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常量使用，这是一种非常有用的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 订单状态枚举 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrderStatus &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 常量相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 已创建(1) */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   CREATED(<span class="number">1</span>, <span class="string">"已创建"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 进行中(2) */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   PROCESSING(<span class="number">2</span>, <span class="string">"进行中"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 已完成(3) */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   FINISHED(<span class="number">3</span>, <span class="string">"已完成"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 属性相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 状态取值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 状态描述 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String description;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">OrderStatus</span><span class="params">(<span class="keyword">int</span> value, String description)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.value = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.description = description;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取状态取值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取状态描述 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> description;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>其实，Enum 类型就是一个语法糖，编译器帮我们做了语法的解析和编译。通过反编译，可以看到 Java 枚举编译后实际上是生成了一个类，该类继承了  java.lang.Enum<E> ，并添加了 values()、valueOf() 等枚举类型通用方法。</p>
<p>定义 Holder 类实现参数的输出</p>
<p>在很多语言中，函数的参数都有输入（in）、输出（out）和输入输出（inout）之分。在 C/C++ 语言中，可以用对象的引用（&amp;）来实现函数参数的输出（out）和输入输出（inout）。但在 Java 语言中，虽然没有提供对象引用类似的功能，但是可以通过修改参数的字段值来实现函数参数的输出（out）和输入输出（inout）。这里，我们叫这种输出参数对应的数据结构为Holder（支撑）类。</p>
<p> Holder 类实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 长整型支撑类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongHolder</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 长整型取值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LongHolder</span><span class="params">()</span> </span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LongHolder</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.value = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Holder 类使用案例：</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 静态常量 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 页面数量 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_COUNT = <span class="number">100</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 最大数量 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">1000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 处理过期订单 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExpiredOrder</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  LongHolder minIdHolder = <span class="keyword">new</span> LongHolder(<span class="number">0L</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pageIndex = <span class="number">0</span>; pageIndex &lt; PAGE_COUNT; pageIndex++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!handleExpiredOrder(pageIndex, minIdHolder)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 处理过期订单 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleExpiredOrder</span><span class="params">(<span class="keyword">int</span> pageIndex, LongHolder minIdHolder)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 获取最小标识</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Long minId = minIdHolder.getValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 查询过期订单(按id从小到大排序)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  List&lt;OrderDO&gt; orderList = orderDAO.queryExpired(minId, MAX_COUNT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (CollectionUtils.isEmpty(taskTagList)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 设置最小标识</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> orderSize = orderList.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  minId = orderList.get(orderSize - <span class="number">1</span>).getId();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  minIdHolder.setValue(minId);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 依次处理订单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span> (OrderDO order : orderList) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 判断还有订单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> orderSize &gt;= PAGE_SIZE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>其实，可以实现一个泛型支撑类，适用于更多的数据类型。</p>
<p>定义 Union 类实现数据体的共存</p>
<p>在 C/C++ 语言中，联合体（union），又称共用体，类似结构体（struct）的一种数据结构。联合体（union）和结构体（struct）一样，可以包含很多种数据类型和变量，两者区别如下：</p>
<p>1、结构体（struct）中所有变量是“共存”的，同时所有变量都生效，各个变量占据不同的内存空间；<br>2、联合体（union）中是各变量是“互斥”的，同时只有一个变量生效，所有变量占据同一块内存空间。</p>
<p>当多个数据需要共享内存或者多个数据每次只取其一时，可以采用联合体（union）。</p>
<p>在Java语言中，没有联合体（union）和结构体（struct）概念，只有类（class）的概念。众所众知，结构体（struct）可以用类（class）来实现。其实，联合体（union）也可以用类（class）来实现。但是，这个类不具备“多个数据需要共享内存”的功能，只具备“多个数据每次只取其一”的功能。</p>
<p>这里，以微信协议的客户消息为例说明。根据我多年来的接口协议封装经验，主要有以下两种实现方式。</p>
<p>使用函数方式实现 Union</p>
<p>Union 类实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 客户消息类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerMessage</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 属性相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 消息类型 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> String msgType;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 目标用户 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> String toUser;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 共用体相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 新闻内容 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> News news;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 常量相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 新闻消息 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MSG_TYPE_NEWS = <span class="string">"news"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CustomerMessage</span><span class="params">()</span> </span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CustomerMessage</span><span class="params">(String toUser)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.toUser = toUser;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CustomerMessage</span><span class="params">(String toUser, News news)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.toUser = toUser;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.msgType = MSG_TYPE_NEWS;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.news = news;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 清除消息内容 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeMsgContent</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 检查消息类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (Objects.isNull(msgType)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 清除消息内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (MSG_TYPE_NEWS.equals(msgType)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           news = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       msgType = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 检查消息类型 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkMsgType</span><span class="params">(String msgType)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 检查消息类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (Objects.isNull(msgType)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"消息类型为空"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 比较消息类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (!Objects.equals(msgType, <span class="keyword">this</span>.msgType)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"消息类型不匹配"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 设置消息类型函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgType</span><span class="params">(String msgType)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 清除消息内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       removeMsgContent();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 检查消息类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (Objects.isNull(msgType)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"消息类型为空"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 赋值消息内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.msgType = msgType;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (MSG_TYPE_NEWS.equals(msgType)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           news = <span class="keyword">new</span> News();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"消息类型不支持"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取消息类型 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getMsgType</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 检查消息类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (Objects.isNull(msgType)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"消息类型无效"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 返回消息类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.msgType;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 设置新闻 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNews</span><span class="params">(News news)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 清除消息内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       removeMsgContent();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 赋值消息内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.msgType = MSG_TYPE_NEWS;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.news = news;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取新闻 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> News <span class="title">getNews</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 检查消息类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       checkMsgType(MSG_TYPE_NEWS);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// 返回消息内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.news;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<p>Union 类使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String accessToken = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">String toUser = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Article&gt; articleList = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">News news = <span class="keyword">new</span> News(articleList);</span></pre></td></tr><tr><td class="code"><pre><span class="line">CustomerMessage customerMessage = <span class="keyword">new</span> CustomerMessage(toUser, news);</span></pre></td></tr><tr><td class="code"><pre><span class="line">wechatApi.sendCustomerMessage(accessToken, customerMessage);</span></pre></td></tr></table></figure>
<p>主要优缺点:<br>优点：更贴近 C/C++ 语言的联合体（union）；<br>缺点：实现逻辑较为复杂，参数类型验证较多。</p>
<p>使用继承方式实现 Union</p>
<p>Union 类实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 客户消息类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerMessage</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 属性相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 消息类型 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> String msgType;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 目标用户 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> String toUser;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 常量相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 新闻消息 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MSG_TYPE_NEWS = <span class="string">"news"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CustomerMessage</span><span class="params">(String msgType)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.msgType = msgType;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CustomerMessage</span><span class="params">(String msgType, String toUser)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.msgType = msgType;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.toUser = toUser;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 新闻客户消息类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span>(callSuper = <span class="keyword">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsCustomerMessage</span> <span class="keyword">extends</span> <span class="title">CustomerMessage</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 属性相关 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 新闻内容 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> News news;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NewsCustomerMessage</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">super</span>(MSG_TYPE_NEWS);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NewsCustomerMessage</span><span class="params">(String toUser, News news)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">super</span>(MSG_TYPE_NEWS, toUser);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.news = news;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Union 类使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String accessToken = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">String toUser = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Article&gt; articleList = ...;</span></pre></td></tr><tr><td class="code"><pre><span class="line">News news = <span class="keyword">new</span> News(articleList);</span></pre></td></tr><tr><td class="code"><pre><span class="line">CustomerMessage customerMessage = <span class="keyword">new</span> NewsCustomerMessage(toUser, news);</span></pre></td></tr><tr><td class="code"><pre><span class="line">wechatApi.sendCustomerMessage(accessToken, customerMessage);</span></pre></td></tr></table></figure>
<p>主要优缺点:<br>优点：使用虚基类和子类进行拆分，各个子类对象的概念明确；<br>缺点：与 C/C++ 语言的联合体（union）差别大，但是功能上大体一致。</p>
<p>在 C/C++ 语言中，联合体并不包括联合体当前的数据类型。但在上面实现的 Java 联合体中，已经包含了联合体对应的数据类型。所以，从严格意义上说， Java 联合体并不是真正的联合体，只是一个具备“多个数据每次只取其一”功能的类。</p>
<h4 id="使用泛型屏蔽类型的差异性"><a href="#使用泛型屏蔽类型的差异性" class="headerlink" title="使用泛型屏蔽类型的差异性"></a>使用泛型屏蔽类型的差异性</h4><p>在 C++ 语言中，有个很好用的模板（template）功能，可以编写带有参数化类型的通用版本，让编译器自动生成针对不同类型的具体版本。而在 Java 语言中，也有一个类似的功能叫泛型（generic）。在编写类和方法的时候，一般使用的是具体的类型，而用泛型可以使类型参数化，这样就可以编写更通用的代码。</p>
<p>许多人都认为， C++ 模板（template）和 Java 泛型（generic）两个概念是等价的，其实实现机制是完全不同的。 C++ 模板是一套宏指令集，编译器会针对每一种类型创建一份模板代码副本； Java 泛型的实现基于”类型擦除”概念，本质上是一种进行类型限制的语法糖。</p>
<h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><p>以支撑类为例，定义泛型的通用支撑类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 通用支撑类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 通用取值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> T value;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span> </span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">(T value)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.value = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><p>定义泛型的数据提供者接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 数据提供者接口 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataProvider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 获取数据函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义泛型的浅拷贝函数：</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 浅拷贝函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">shallowCopy</span><span class="params">(Object source, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 判断源对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (Objects.isNull(source)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 新建目标对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   T target;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       target = clazz.newInstance();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> BeansException(<span class="string">"新建类实例异常"</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 拷贝对象属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   BeanUtils.copyProperties(source, target);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// 返回目标对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> target;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h5><p>泛型通配符一般是使用”？”代替具体的类型实参，可以把”？”看成所有类型的父类。当具体类型不确定的时候，可以使用泛型通配符 “？”；当不需要使用类型的具体功能，只使用Object类中的功能时，可以使用泛型通配符 “？”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 打印取值函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printValue</span><span class="params">(GenericHolder&lt;?&gt; holder)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   System.out.println(holder.getValue());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 主函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   printValue(<span class="keyword">new</span> GenericHolder&lt;&gt;(<span class="number">12345</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">   printValue(<span class="keyword">new</span> GenericHolder&lt;&gt;(<span class="string">"abcde"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">在 Java 规范中，不建议使用泛型通配符<span class="string">"？"</span>，上面函数可以改为：</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 打印取值函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(GenericHolder&lt;T&gt; holder)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   System.out.println(holder.getValue());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<h5 id="泛型上下界"><a href="#泛型上下界" class="headerlink" title="泛型上下界"></a>泛型上下界</h5><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。泛型上下界的声明，必须与泛型的声明放在一起 。</p>
<p>上界通配符（extends）：<br>上界通配符为 ”extends ”，可以接受其指定类型或其子类作为泛参。其还有一种特殊的形式，可以指定其不仅要是指定类型的子类，而且还要实现某些接口。例如： List&lt;? extends A&gt; 表明这是 A 某个具体子类的 List ，保存的对象必须是A或A的子类。对于 List&lt;? extends A&gt; 列表，不能添加 A 或 A 的子类对象，只能获取A的对象。</p>
<p>下界通配符（super）：<br>下界通配符为”super”，可以接受其指定类型或其父类作为泛参。例如：List&lt;? super A&gt; 表明这是 A 某个具体父类的 List ，保存的对象必须是 A 或 A 的超类。对于 List&lt;? super A&gt; 列表，能够添加 A 或 A 的子类对象，但只能获取 Object 的对象。<br>PECS（Producer Extends Consumer Super）原则：作为生产者提供数据（往外读取）时，适合用上界通配符（extends）；作为消费者消费数据（往里写入）时，适合用下界通配符（super）。</p>
<p>在日常编码中，比较常用的是上界通配符（extends），用于限定泛型类型的父类。例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 数字支撑类 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberHolder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 通用取值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> T value;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NumberHolder</span><span class="params">()</span> </span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/** 构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NumberHolder</span><span class="params">(T value)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">this</span>.value = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 打印取值函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Number&gt; <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(GenericHolder&lt;T&gt; holder)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   System.out.println(holder.getValue());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>笔者曾在通信行业从业十余年，接入了各类网管和设备的北向接口协议上百余种，涉及到传输、交换、接入、电源、环境等专业，接触了 CORBA、HTTP/HTTPS、WebService、Socket TCP/UDP、串口 RS232/485 等接口，总结出一套接口协议封装的”方法论”。其中，把接口协议文档中的数据格式转化为 Java 的枚举、结构体、联合体等数据结构，是接口协议封装中极其重要的一步。</p>
<p>本文作者：<br>陈昌毅，花名常意，高德地图技术专家，2018年加入阿里巴巴，一直从事地图数据采集的相关工作。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发下的接口幂等性解决方案</title>
    <url>/2019/12/03/md/part/distributed/idempotent/</url>
    <content><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>我们实际系统中有很多操作，是不管做多少次，都应该产生一样的效果或返回一样的结果。</p>
<p>例如：</p>
<p>前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果。<br>我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱；<br>发送消息，也应该只发一次，同样的短信发给用户，用户会哭的；<br>创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题。<br>等等很多重要的情况，这些逻辑都需要幂等的特性来支持。</p>
<h3 id="二、幂等性概念"><a href="#二、幂等性概念" class="headerlink" title="二、幂等性概念"></a>二、幂等性概念</h3><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p>
<p>在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。</p>
<p>这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数.</p>
<p>更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p>
<p>我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的</p>
<h3 id="三、技术方案"><a href="#三、技术方案" class="headerlink" title="三、技术方案"></a>三、技术方案</h3><h4 id="1-查询操作-查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作"><a href="#1-查询操作-查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作" class="headerlink" title="1. 查询操作 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作"></a>1. 查询操作 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</h4><h4 id="2-删除操作-删除操作也是幂等的，删除一次和多次删除都是把数据删除。-注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个"><a href="#2-删除操作-删除操作也是幂等的，删除一次和多次删除都是把数据删除。-注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个" class="headerlink" title="2. 删除操作 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)"></a>2. 删除操作 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</h4><h4 id="3-唯一索引，防止新增脏数据-比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录"><a href="#3-唯一索引，防止新增脏数据-比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录" class="headerlink" title="3.唯一索引，防止新增脏数据 比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录"></a>3.唯一索引，防止新增脏数据 比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</h4><p>要点： 唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）</p>
<h4 id="4-token机制，防止页面重复提交"><a href="#4-token机制，防止页面重复提交" class="headerlink" title="4. token机制，防止页面重复提交"></a>4. token机制，防止页面重复提交</h4><p>业务要求：</p>
<p>页面的数据只能被点击提交一次</p>
<p>发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交</p>
<p>解决办法：集群环境：采用token加redis（redis单线程的，处理需要排队） 单JVM环境：采用token加redis或token加jvm内存</p>
<p>处理流程：</p>
<p>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间<br>提交后后台校验token，同时删除token，生成新的token返回<br><code>token特点</code>：要申请，一次有效性，可以限流</p>
<blockquote>
<p>注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</p>
</blockquote>
<h4 id="5-悲观锁-获取数据的时候加锁获取"><a href="#5-悲观锁-获取数据的时候加锁获取" class="headerlink" title="5. 悲观锁 获取数据的时候加锁获取"></a>5. 悲观锁 获取数据的时候加锁获取</h4><p>select * from table_xxx where id=’xxx’ for update;</p>
<p>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的</p>
<p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p>
<h4 id="6-乐观锁-乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。"><a href="#6-乐观锁-乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。" class="headerlink" title="6. 乐观锁 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。"></a>6. 乐观锁 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</h4><p>乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p>
<p>1、通过版本号实现</p>
<p>update table_xxx set name=#name#,version=version+1 where version=#version#<br>如下图(来自网上)：</p>
<p>2、通过条件限制</p>
<p>update tablexxx set avaiamount=avaiamount-#subAmount# where avaiamount-#subAmount# &gt;= 0<br>要求：quality-#subQuality# &gt;= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高</p>
<p>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好</p>
<p>update tablexxx set name=#name#,version=version+1 where id=#id# and version=#version#</p>
<p>update tablexxx set avaiamount=avaiamount-#subAmount# where id=#id# and avai_amount-#subAmount# &gt;= 0</p>
<h4 id="7-分布式锁-还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定"><a href="#7-分布式锁-还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定" class="headerlink" title="7. 分布式锁 还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定"></a>7. 分布式锁 还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定</h4><p>这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁</p>
<p>这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</p>
<p>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)</p>
<h4 id="8-select-insert-并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了"><a href="#8-select-insert-并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了" class="headerlink" title="8. select + insert 并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了"></a>8. select + insert 并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</h4><p>注意：核心高并发流程不要用这种方法</p>
<h4 id="9-状态机幂等-在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机-状态变更图-，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机"><a href="#9-状态机幂等-在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机-状态变更图-，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机" class="headerlink" title="9. 状态机幂等 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机"></a>9. 状态机幂等 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机</h4><p>如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p>
<p>注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</p>
<h4 id="10-对外提供接口的api如何保证幂等"><a href="#10-对外提供接口的api如何保证幂等" class="headerlink" title="10. 对外提供接口的api如何保证幂等"></a>10. 对外提供接口的api如何保证幂等</h4><p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号</p>
<p>source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</p>
<p>重点对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引</p>
<p>这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。</p>
<p>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体验也不好</p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>kafa相关概念</title>
    <url>/2019/11/28/md/part/mq/kafka-concept/</url>
    <content><![CDATA[<h3 id="Kafka的特性"><a href="#Kafka的特性" class="headerlink" title="Kafka的特性:"></a>Kafka的特性:</h3><ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。(以o(1)的时间复杂度进行顺序写入或读取)</li>
<li>展性：kafka集群支持热扩展</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li>高并发：支持数千个客户端同时读写</li>
</ul>
<h3 id="Kafka的使用场景："><a href="#Kafka的使用场景：" class="headerlink" title="Kafka的使用场景："></a>Kafka的使用场景：</h3><ul>
<li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>
<li>消息系统：解耦和生产者和消费者、缓存消息等。</li>
<li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li>
<li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>
<li>流式处理：比如spark streaming和storm</li>
</ul>
<h3 id="kafka概念"><a href="#kafka概念" class="headerlink" title="kafka概念"></a>kafka概念</h3><p><img src="https://www.mqiy.xyz/image/distribute/kafka-concept-structure.png" alt="kafka-concept-structure.png"></p>
<p>上图中一个topic配置了3个partition。Partition1有两个offset：0和1。Partition2有4个offset。Partition3有1个offset。副本的id和副本所在的机器的id恰好相同。</p>
<p>如果一个topic的副本数为3，那么Kafka将在集群中为每个partition创建3个相同的副本。集群中的每个broker存储一个或多个partition。多个producer和consumer可同时生产和消费数据。</p>
<p>4.2　broker<br>Kafka 集群包含一个或多个服务器，服务器节点称为broker。</p>
<p>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</p>
<p>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</p>
<p>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p>
<p>4.3　Topic<br>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>
<p>类似于数据库的表名</p>
<p>4.3　Partition<br>topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</p>
<p>4.4　Producer<br>生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</p>
<p>4.5　Consumer<br>消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</p>
<p>4.6　Consumer Group<br>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>
<p>4.7　Leader<br>每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</p>
<p>4.8　Follower<br>Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</p>
<blockquote>
<p>kafka没有队列概念，与之对应的是分区(partition)</p>
</blockquote>
]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka环境搭建</title>
    <url>/2019/11/28/md/part/mq/kafka-test/</url>
    <content><![CDATA[<h3 id="启动单节点kafka"><a href="#启动单节点kafka" class="headerlink" title="启动单节点kafka"></a>启动单节点kafka</h3><p>kafka通过zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动zookeeper（也可以使用独立的zookeeper）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">zookeeper-server-start.sh config/zookeeper.properties</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 kafka</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kafka-server-start.sh config/server.properties</span></pre></td></tr></table></figure>


<h3 id="启动kafka集群（同台服务器）"><a href="#启动kafka集群（同台服务器）" class="headerlink" title="启动kafka集群（同台服务器）"></a>启动kafka集群（同台服务器）</h3><p>集群中broker.id不能有重复</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#复制配置文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">cp</span> <span class="string">config/server.properties config/server-1.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">config/server-1.properties</span>:<span class="string"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">broker.id</span>=<span class="string">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://192.168.85.143:9092</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">advertised.listeners</span>=<span class="string">PLAINTEXT://192.168.85.143:9092</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">default.replication.factor</span>=<span class="string">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">config/server-2.properties</span>:<span class="string"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">broker.id</span>=<span class="string">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">listeners</span>=<span class="string">PLAINTEXT://:9092</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">log.dirs</span>=<span class="string">/tmp/kafka-logs-2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">config/server-3.properties</span>:<span class="string"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">broker.id</span>=<span class="string">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">listeners</span>=<span class="string">PLAINTEXT://:9093</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">log.dirs</span>=<span class="string">/tmp/kafka-logs-23</span></span></pre></td></tr></table></figure>
<p>启动多个结点</p>
<blockquote>
<p>kafka-server-start.sh config/server-1.properties<br>kafka-server-start.sh config/server-2.properties<br>kafka-server-start.sh config/server-3.properties </p>
</blockquote>
<h3 id="模拟过程"><a href="#模拟过程" class="headerlink" title="模拟过程"></a>模拟过程</h3><h4 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询所有主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kafka-topics.sh --list --bootstrap-server localhost:9092</span></pre></td></tr></table></figure>

<h4 id="启动生产者"><a href="#启动生产者" class="headerlink" title="启动生产者"></a>启动生产者</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动后，单行输出做为一个消息发出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kafka-console-producer.sh --broker-list localhost:9092 --topic test</span></pre></td></tr></table></figure>

<h4 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span></pre></td></tr></table></figure>


<h3 id="演示leader节点炸，其他节点接手"><a href="#演示leader节点炸，其他节点接手" class="headerlink" title="演示leader节点炸，其他节点接手"></a>演示leader节点炸，其他节点接手</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建多复制节点的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 3 --partitions 1 --topic my-replicated-topic</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前主题的leader节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic my-replicated-topic</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">返回结果：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Topic:my-replicated-topic	PartitionCount:1	ReplicationFactor:3	Configs:segment.bytes=1073741824</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Topic: my-replicated-topic	Partition: 0	Leader: 3	Replicas: 3,1,2	Isr: 3,1,2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 干掉leader broker</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ps aux | grep server-1.properties</span></pre></td></tr><tr><td class="code"><pre><span class="line">kill -9 pid</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 再次查看主题信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic my-replicated-topic</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">返回结果：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Topic:my-replicated-topic	PartitionCount:1	ReplicationFactor:3	Configs:segment.bytes=1073741824</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Topic: my-replicated-topic	Partition: 0	Leader: 1	Replicas: 3,1,2	Isr: 1,2</span></pre></td></tr></table></figure>


<h3 id="2020-03-03-21-19-35-058-WARN-Consumer-clientId-consumer-console-consumer-84017-1-groupId-console-consumer-84017-Error-while-fetching-metadata-with-correlation-id-90-dahui-LEADER-NOT-AVAILABLE-org-apache-kafka-clients-NetworkClient"><a href="#2020-03-03-21-19-35-058-WARN-Consumer-clientId-consumer-console-consumer-84017-1-groupId-console-consumer-84017-Error-while-fetching-metadata-with-correlation-id-90-dahui-LEADER-NOT-AVAILABLE-org-apache-kafka-clients-NetworkClient" class="headerlink" title="[2020-03-03 21:19:35,058] WARN [Consumer clientId=consumer-console-consumer-84017-1, groupId=console-consumer-84017] Error while fetching metadata with correlation id 90 : {dahui=LEADER_NOT_AVAILABLE} (org.apache.kafka.clients.NetworkClient)"></a>[2020-03-03 21:19:35,058] WARN [Consumer clientId=consumer-console-consumer-84017-1, groupId=console-consumer-84017] Error while fetching metadata with correlation id 90 : {dahui=LEADER_NOT_AVAILABLE} (org.apache.kafka.clients.NetworkClient)</h3><p><strong>解决方案</strong> 添加配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://192.168.85.143:9092</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">advertised.listeners</span>=<span class="string">PLAINTEXT://192.168.85.143:9092</span></span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>项目中的实践</title>
    <url>/2019/11/22/md/part/project/project-practise/</url>
    <content><![CDATA[<h4 id="H5支付域名-：-前端域名"><a href="#H5支付域名-：-前端域名" class="headerlink" title="H5支付域名 ：  前端域名"></a>H5支付域名 ：  前端域名</h4><h4 id="docker镜像中sapshot版本的jar-重-启后，不会拉最新的代码"><a href="#docker镜像中sapshot版本的jar-重-启后，不会拉最新的代码" class="headerlink" title="docker镜像中sapshot版本的jar,重 启后，不会拉最新的代码"></a>docker镜像中sapshot版本的jar,重 启后，不会拉最新的代码</h4>]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2019/11/22/md/develop/base/data-structure/red-black-tree/</url>
    <content><![CDATA[<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>节点是红色或者黑色。</li>
<li>根节点是黑色。</li>
<li>每个叶子的节点都是黑色的空节点（NULL）。</li>
<li>每个红色节点的两个子节点都是黑色的。</li>
<li>从任意节点到其每个叶子的所有路径都包含相同的黑色节点。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>每日必读</title>
    <url>/2019/11/22/md/develop/read-every-day/</url>
    <content><![CDATA[<h3 id="全球统计一生后悔的五件事："><a href="#全球统计一生后悔的五件事：" class="headerlink" title="全球统计一生后悔的五件事："></a>全球统计一生后悔的五件事：</h3><ul>
<li>92%的人后悔年轻时努力不够一事无成  </li>
<li>73%的人后悔没有好好珍惜身边的亲人  </li>
<li>62%的人后悔跟错了人  </li>
<li>63%的人后悔年轻时选错了职业  </li>
<li>45%的人后悔没有善待自己身体  </li>
</ul>
<h3 id="永远为下周离职做准备"><a href="#永远为下周离职做准备" class="headerlink" title="永远为下周离职做准备"></a>永远为<code>下周离职</code>做准备</h3><h3 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h3><ul>
<li>不断增值自己，拥有更多选择权</li>
<li>互联网没有舒适圈，止步不前便是退步</li>
<li>学习是面对竞争、度过中年危机的最好方法</li>
</ul>
<h3 id="被淘汰"><a href="#被淘汰" class="headerlink" title="被淘汰"></a>被淘汰</h3><p>不思进取、放弃基本技能的程序员在34~9岁会被淘汰,保持乐观的精神、积极学习才是我们每天都该做的</p>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>只言片语-002</title>
    <url>/2019/11/22/md/life/part-aphorism-two/</url>
    <content><![CDATA[<h4 id="2020-06-04"><a href="#2020-06-04" class="headerlink" title="2020-06-04"></a>2020-06-04</h4><ul>
<li>到了那个时候,随着年龄的增加,他可能会变得越来越颓废,也越来越蹉跎,直到最后被岁月磨平了棱角,让年华腐蚀了心气,心甘情愿变成了社会中无数麻木群体里的一员</li>
<li>保持专注,保持热情;不记初心,方得始终</li>
<li>熔炉台词：我们一路奋战，不是为了改变这个世界，而是为了不让这个世界不改变我们</li>
<li>《团长》郝兽医一句话：”年纪轻轻的你就跟人比烂？”</li>
</ul>
]]></content>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>只言片语-001</title>
    <url>/2019/11/22/md/life/part-aphorism-one/</url>
    <content><![CDATA[<blockquote>
<p>希望你经历过人生坎坷与挫折后，依然能够保持赤字之心，积极乐观，自信坦荡。</p>
</blockquote>
<blockquote>
<p>男生找不到女朋友，只有这一个原因 男生找不到女朋友90%的原因都在这里第一总是当老好人，第二种是眼高手低，第三总是迎合女生的脚。第四总是表白，第五总是心眼好，但是说话不会拐弯抹角，容易好心办错事，第六总是见到女生就没有话题聊，显得很尴尬。</p>
</blockquote>
<blockquote>
<p>记着，你可以失望，但是不能绝望，累的时候就走得慢点，千万不要后退，你还没有拼尽全力，怎么知道没有奇迹？</p>
</blockquote>
<blockquote>
<p>世界上最惨的骗局 莫过于欺骗自己 人生不会有任何侥幸 任何侥幸所绕过的，都会在未来的生命中以某种形式的代价偿还 所以，用百分百的心做好每一件事情。</p>
</blockquote>
<blockquote>
<p>一辈子总在<code>差点</code>和<code>本该</code>中徘徊。</p>
</blockquote>
<h4 id="2019-06-21"><a href="#2019-06-21" class="headerlink" title="2019-06-21"></a>2019-06-21</h4><ul>
<li>勤加练习，必能得心应手！不期速成，日拱一卒 ！  </li>
<li>知人者智，自知者明。胜人者有力，自胜者强。知足者富。强行者有志。不失其所者久。死而不亡者寿。</li>
<li>权力者:长久以后，以权力为自己能力，自以为是  ;过于简单,过于宏观</li>
</ul>
<h4 id="2019-07-26-愿你走出半生，归来仍是少年"><a href="#2019-07-26-愿你走出半生，归来仍是少年" class="headerlink" title="2019-07-26   愿你走出半生，归来仍是少年"></a>2019-07-26   愿你走出半生，归来仍是少年</h4><p>希望你经历过人生坎坷与挫折后，依然能够保持赤字之心，积极乐观，自信坦荡。</p>
<ul>
<li>真正的精致，其实藏在别人看不见的地方。</li>
<li>真正的精致，是即使穷困潦倒，也要让生活过得有滋有味。</li>
<li>真正的精致，是给生活做减法，让心灵回归理性。</li>
</ul>
<p>《一代宗师》里有这样一句话：“人活在世上，有的人活成了面子，有的人活成了里子。”<br>别让自己为了面子而活，被假精致所绑架。<br>内心真正丰富充盈的人，才可以拥抱真正的精致。</p>
<ul>
<li>像个傻逼一样，明知道不应该做的事，还非要去做</li>
<li>能有点出息不，对自己狠一点</li>
<li>想想那些放弃自己的人，让她们后悔</li>
</ul>
<blockquote>
<p>可能不抽烟不喝酒的男人对智障的容忍度没那么高</p>
</blockquote>
<blockquote>
<p>看人的眼神就像看<code>白痴</code>,但是眼神柔和了，弱势群体需要爱护嘛</p>
</blockquote>
]]></content>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>五笔字</title>
    <url>/2019/11/14/md/other/input/messWord/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>象</th>
<th>行</th>
<th>段</th>
<th>物</th>
<th>应</th>
<th>跳</th>
</tr>
</thead>
<tbody><tr>
<td>半</td>
<td>必</td>
<td>永</td>
<td>失</td>
<td>规</td>
<td>涉及</td>
</tr>
<tr>
<td>骨</td>
<td>陆</td>
<td>心甘情愿</td>
<td>辈</td>
<td>花哨</td>
<td>制</td>
</tr>
<tr>
<td>离</td>
<td>辣椒</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>五笔</tag>
      </tags>
  </entry>
  <entry>
    <title>解决方法</title>
    <url>/2019/11/13/md/develop/learn/</url>
    <content><![CDATA[<h4 id="梳理完整的流程"><a href="#梳理完整的流程" class="headerlink" title="梳理完整的流程"></a>梳理完整的流程</h4><h4 id="从整体上看待问题"><a href="#从整体上看待问题" class="headerlink" title="从整体上看待问题"></a>从整体上看待问题</h4><h4 id="多画图"><a href="#多画图" class="headerlink" title="多画图"></a>多画图</h4><h4 id="先把模块流程搞清楚"><a href="#先把模块流程搞清楚" class="headerlink" title="先把模块流程搞清楚"></a>先把模块流程搞清楚</h4><h4 id="学习时，需要产出文档，总结"><a href="#学习时，需要产出文档，总结" class="headerlink" title="学习时，需要产出文档，总结"></a>学习时，需要产出文档，总结</h4><h4 id="短期与长期目标之间的平衡"><a href="#短期与长期目标之间的平衡" class="headerlink" title="短期与长期目标之间的平衡"></a>短期与长期目标之间的平衡</h4><h4 id="切记勿急功近利"><a href="#切记勿急功近利" class="headerlink" title="切记勿急功近利"></a>切记勿急功近利</h4><h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h3><p>　JAVA的基础知识：数据结构（Map,List,Set等）,设计模式，算法，线程相关，IO/NIO，序列化等等<br>　其次是高级特征：反射机制，并发与锁，JVM（GC策略，类加载机制，内存模型）等等</p>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>我的 Java 后端面试日记！</title>
    <url>/2019/11/12/md/interview/11-12-interview/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在老东家五年了，总共工作整七年，经历两家公司。2019-10-31日离职。公司规模较小，项目压力不大，非985/211毕业，统招本科，计算机专业。</p>
<p>目标：中大型公司，最好是大厂，嘿嘿，不过不抱希望，毕竟背景不太好。</p>
<h3 id="准备过程"><a href="#准备过程" class="headerlink" title="准备过程"></a>准备过程</h3><h4 id="2019-10-31-周四"><a href="#2019-10-31-周四" class="headerlink" title="2019-10.31 周四"></a>2019-10.31 周四</h4><p>提了离职已经二十多天了，今天老板签了字，办了离职手续，《某某直聘》上传简历，刷新简历。</p>
<p>《某东供应链部门》打电话问了问我的学历是否统招本科，约我明天下午去面试。不过他也算是大厂吧，没有面试经验咋办，心里很忐忑，没关系，开始加油吧！</p>
<p>咦，有条消息，我一看是我同学给我发的截图，原来他刷到我的简历了，他说帮我内推，内心还是挺激动的。内推公司：《打车》</p>
<h4 id="2019-11-01-周五"><a href="#2019-11-01-周五" class="headerlink" title="2019-11-01 周五"></a>2019-11-01 周五</h4><p>早上五点半爬起来了，开始看视频，刷资料，准备面试，一直到12:00，没吃饭。公司太远了，在亦庄，要两个小时才能到，出了地铁口，映入眼帘的便是他们的大楼。找到部门，给了张面试题。</p>
<h5 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h5><p>HashMap，HashTable，ConcurrentHashMap的共同点和区别？<br>Spring的 init-method，destroy-method的实现方式？<br>说几种实现幂等的方式？<br>说几种分布式锁的实现方式？<br>有一个List集合，多线程计算总和，说出你的思路和使用到的框架。<br>一个开放题目，数三角形的</p>
<p>做完题目，感觉还比较OK，来了一个面试官，大概三十多左右。</p>
<p>自我介绍<br>介绍一下项目<br>JVM内存模型<br>MySQL事务隔离的底层实现？<br>MySQL索引介绍一下？</p>
<p>命中索引要注意什么？<br>List去重，手写代码，考察基础</p>
<h5 id="二面：部门负责人"><a href="#二面：部门负责人" class="headerlink" title="二面：部门负责人"></a>二面：部门负责人</h5><p>简单聊聊，介绍团队业务，有什么要问的吗？等待通知。（说好的《打车》内推呢，咋还不给我打电话呀，算了，可能简历没过。）</p>
<p>总结：MySQL事务隔离底层实现细节还要多补充一下，JVM细节在多看看。</p>
<p>接到《某某租房》公司面试邀约。下周一下午面，正好周六日在准备准备。</p>
<h4 id="2019-11-04-周一"><a href="#2019-11-04-周一" class="headerlink" title="2019-11-04 周一"></a>2019-11-04 周一</h4><p>坐地铁辗转到了公司大楼。你好，来面试的。领到一份面试题，来到三楼休息室，一大堆人跟菜市场似的。我擦，竞争压力这么大啊，看了一眼面试题，好多不会的，来都来了，试试呗。开始做题。</p>
<p>String  new String 的关系 ==，equals<br>两个链表相交，求交点<br>三个线程顺序打印ABC<br>如果aab,aba相等，给两个字符串，判断是否相等<br>画一下RPC的架构图</p>
<p>一面：一位说话比较轻柔的技术官。</p>
<p>自我介绍<br>String ，new String 这道题为什么这么选？原因？<br>说一下项目<br>手写一个单例<br>JVM内存模型，JAVA 栈能分配对象吗？<br>说一下类加载过程，双亲委派模型源码看过吗？介绍一下<br>什么情况下栈会溢出？<br>栈帧介绍一下？<br>MySQL索引了解吗？画一下？<br>从业务角度出发，如何设计MySQL数据库？有哪些优化点？<br>垃圾回收了解吗？介绍一下？<br>讲一下AOP的原理？Cglib能代理final方法吗?</p>
<p>面试官对我说:我觉得还OK，你等一下，我们领导开会，让HR通知你改天二面吧</p>
<p>好的，启程回家。</p>
<p>同学微信：我们HR给你打电话了吗？：没有，那我让他约你。<br>HR：你好，为了不耽误时间，约您电话面试。（同学介入）<br>HR：你好，周五直接来公司面试。。。。</p>
<h4 id="2019-11-05-周二"><a href="#2019-11-05-周二" class="headerlink" title="2019-11-05 周二"></a>2019-11-05 周二</h4><p>下午去某公司面试，结果面试官没有接到电话，保安也不让我去问，算了，走人吧。</p>
<h4 id="2019-11-06-周三"><a href="#2019-11-06-周三" class="headerlink" title="2019-11-06 周三"></a>2019-11-06 周三</h4><p>《某某租房》复试。面试官很年轻，比我大两岁，人家已经是研发经理了，看看我。哎。。。。</p>
<p>项目为什么不用RPC框架？<br>了解RPC吗？，画一下流程图？<br>RPC和HTTP协议有什么区别？<br>长连接是物理真实存在的吗？<br>介绍一下项目？<br>MQ 消息丢了怎么办？发消息是原子操作吗？</p>
<p>三面：研发总监</p>
<p>锁介绍一下？有哪些？<br>线程阻塞从操作系统的角度介绍一下？<br>其他的记不清了</p>
<p>下午四面：技术总监</p>
<p>HTTPS的流程<br>你认为你还欠缺什么？<br>如何学习的？<br>瞎扯淡，行了，签字，录用了</p>
<p>HR谈offer，回家喽。   </p>
<h4 id="2019-11-07-周四"><a href="#2019-11-07-周四" class="headerlink" title="2019-11-07 周四"></a>2019-11-07 周四</h4><p>《某某优鲜》下午两点，找大楼找了半天。公司好几层，我擦，没见过这阵仗。上楼等一会，没有面试题。</p>
<p>一面：<br>你的项目如何拆分的？为什么这么拆？<br>如何保证服务高可用？<br>MySQL挂了怎么办？（挂就挂了，很惭愧，公司没实现数据库高可用。。。。）<br>项目经历有点差啊，就不问你互联网项目问题了<br>说一下 WebSocket协议<br>说一下HTTPS协议</p>
<p>二面：</p>
<p>SpringBoot了解吗？和Spring的区别？<br>如果想做定制化开发，怎么做？<br>@Conditional 说一下<br>事务的传播机制？<br>说说MySQL索引？<br>可重入锁的原理？（state ，AQS）<br>拆分服务，服务治理有了解吗？</p>
<p>HR：简单聊了一下，为什么五年不离职？你这样的很少见啊。还有一轮部门老大面试，你先回去吧，电话面。</p>
<p>晚上收到通知，周五6点电话面试。</p>
<h4 id="2019-11-08-周五"><a href="#2019-11-08-周五" class="headerlink" title="2019-11-08 周五"></a>2019-11-08 周五</h4><p>该来的终于来了，要面对最终BOSS了。不过还好不用坐地铁了，上午看了几个视频，准备了一下，中午12点，洗个澡，收拾收拾。骑车出发，心情很忐忑。</p>
<p>骑车到了地方，公司LOGO映入眼帘，两座大楼。给HR打电话，接待，上楼，等了一会，一个年轻的面试官过来了。</p>
<p>设计一个秒杀系统，讲一下你的思路。<br>如何设计限流？<br>库存怎么扣减？decrby 可以吗？<br>库存扣减失败怎么办？<br>画一下项目结构？<br>a,b,c 联合索引， a=1,b=1,c&gt;1 能命中索引吗？a=1,b&gt;1,c=1能命中索引吗？<br>JVM 堆说一下？触发Full GC 的场景有哪些？<br>说说G1垃圾回收器？老年代，年轻代如何分配？<br>Redis 锁出错怎么办？<br>Redis 扣减库存有问题怎么办？<br>设计一个转账系统? A-&gt;B转100块，有没有思路？<br>Redis 有哪些持久化方式？<br>Redis 数据会存放到磁盘吗？<br>Redis为什么这么快？<br>Linux 统计top10 IP访问日志，用到哪些命令？（不会）<br>Linux 自己用过哪些命令呢？<br>如何查看Dump日志？怎么产生的？命令有哪些？<br>一个线程池 ，10个核心，100个最大线程数，100个队列，10000个请求打过来，描述一下线程池如何运行？拒绝了怎么办？<br>考察一下基础知识吧，String  new String 的区别？（==  equals ）</p>
<p>二面：（和一面问了好几个重复的问题，害的我又讲了一遍）</p>
<p>项目你认为有哪些难点？（活动报名超员，联想到秒杀）<br>秒杀场景如何处理？<br>可以用Redis decrby 做库存扣减吗？如何做？（可以用 lua保证原子性）<br>lua太重，有别的方案吗？<br>库存如何恢复？<br>防止超卖还不行，未支付的订单如何处理？<br>用户名密码如何防止被盗？（js加密，不行，还是能破解，哦，https。。。。）<br>说说https的流程？<br>有了解过哪些非对称加密算法？对称加密算法呢？<br>c,b,a 索引问题，c=1,b=1,a=1 能命中索引吗? c&gt;1,b=1,c=1 能命中索引吗？为什么？<br>评论业务如何区分模块的？(bizId)<br>某个业务打爆数据库了怎么办？（分库，拆分服务，单独部署，还有呢？MQ）<br>了解限流吗？降级？算了，你也没接触过，不问了。（ORZ）<br>Linux 统计top10 IP访问日志，用到哪些命令？（不会）<br>说一说你对HashMap的结构理解，如果Key相同怎么办，链表是前插还是后插？红黑树呢？<br>用过哪些Linux命令？（mkdir，ll，等。。。。linux确实是我的弱项，以后要恶补了。）<br>1 2 2 3 3 4 4 5，如何确定3的索引位置？（计数统计，O(N) O(N),还有更好的方法吗？循环吧。（正确答案二分法，我提到了，但是思路却错了，被批了一顿）<br>GIT 团队开发如何去做？如果有个 feature 不用上线怎么办呢？<br>maven 如果包冲突，不解决会有什么问题？如何解决包冲突问题？<br>设计一下Dubbo的线程池？每次请求50ms  200 QPS，客户端500ms超时，如何设计？直接打入200个请求呢？队列多大？线程池多大？（回答的不好）<br>Integer a1=10000  Integer a2=10000，他俩 == 结果？怎么才能相等呢？（equals，== 比较的引用地址，考察Integer 缓存）<br>Integer a1=100 Integer a2=100 呢？  参数可以设置吗？如何设置？</p>
<p>部门老大面：</p>
<p>你是某某同学吧？（舍友）<br>说一下以后的打算？<br>技术成长？业务方面有哪些选择？<br>不能光看技术，要熟悉业务<br>如果DB要挂了，用哪些方式去解决？（说了一些我认为的方案，但是明显不是。。毕竟没接触过，所以只能自己理解）<br>如何统计QPS？有没有了解市面上的框架？如何实现，原理呢？<br>他们该问的都问了，聊聊非技术的吧<br>等一下，我让HR找你。</p>
<p>HR面：</p>
<p>离职原因？<br>五年怎么离职了呢？<br>期望薪资？<br>周一等消息吧。</p>
<p>和同学简单聊了聊。同学说我的回答还可以，只不过经验少一些。（哎，小公司业务量小，确实吃亏）。慢慢来！我说，有这次面试机会我已经知足了！！！要不然我的简历肯定是过不了的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试之前确实要多做准备，不过有实战经验的话更佳，怪不得大厂跳大厂较为容易一些。小公司也不要气馁，一些公司不看项目，看你对高并发项目的理解，哪怕自己没做过，有自己的方案也可以。</p>
<p>另外，基础必须扎实，不要只背理论，深入了解，了解的越深越好，虽说面试造火箭，工作拧螺丝，你有造火箭的能力还怕拧不好螺丝吗？</p>
<p>面了整整一周，总共四家公司，最终结果自己还是可以接受的。<code>JVM</code>,<code>MySQL</code>必须掌握，其他基础知识要牢固，并且要用到实战上，要不然学再多也是理论，Linux操作系统要恶补一下,由于自己高并发场景经验较少，这个只能在业务量较大的公司才能学到。</p>
<p>另外，市场上的资料，不管是付费的还是非付费的确实对面试很有帮助，但是如果自己有个好项目搭配的话，更好一些，要不然面试官都没法问。</p>
<p>别问我为什么五年不离职，我也不知道是好事还是坏事？</p>
<p>整体面下来，感觉自己准备的勉强及格了，但还是不够好，应该能回答的更好的，让我想起了一句话，你本来可以做的更好。所以，告诫自己不要再浪费时间，多学习，多总结。很幸运，再次感谢同学的内推，谢谢你。<br>END</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发技术</title>
    <url>/2019/11/07/md/jdk/mulThread/base/</url>
    <content><![CDATA[<h4 id="1-并发编程三要素"><a href="#1-并发编程三要素" class="headerlink" title="1.并发编程三要素"></a>1.并发编程三要素</h4><p> 原子性原子，即一个不可再被分割的颗粒。在Java中原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。<br> 有序性程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）<br> 可见性当多个线程访问同一个变量时，如果其中一个线程对其作了修改，其他线程能立即获取到最新的值。</p>
<h4 id="2-线程的五大状态"><a href="#2-线程的五大状态" class="headerlink" title="2. 线程的五大状态"></a>2. 线程的五大状态</h4><ul>
<li>创建状态 当用 new 操作符创建一个线程的时候</li>
<li>就绪状态 调用 start 方法，处于就绪状态的线程并不一定马上就会执行 run 方法，还需要等待CPU的调度</li>
<li>运行状态 CPU 开始调度线程，并开始执行 run 方法</li>
<li>阻塞状态 线程的执行过程中由于一些原因进入阻塞状态比如：调用 sleep 方法、尝试去得到一个锁等等</li>
<li>死亡状态  run 方法执行完 或者 执行过程中遇到了一个异常</li>
</ul>
<h4 id="3-悲观锁与乐观锁"><a href="#3-悲观锁与乐观锁" class="headerlink" title="3.悲观锁与乐观锁"></a>3.悲观锁与乐观锁</h4><p> 悲观锁：每次操作都会加锁，会造成线程阻塞。<br> 乐观锁：每次操作不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，不会造成线程阻塞。</p>
<h4 id="4-线程之间的协作：wait-notify-notifyAll等"><a href="#4-线程之间的协作：wait-notify-notifyAll等" class="headerlink" title="4.线程之间的协作：wait/notify/notifyAll等"></a>4.线程之间的协作：wait/notify/notifyAll等</h4><h4 id="5-synchronized-关键字"><a href="#5-synchronized-关键字" class="headerlink" title="5.synchronized 关键字"></a>5.synchronized 关键字</h4><h4 id="6-CAS"><a href="#6-CAS" class="headerlink" title="6.CAS"></a>6.CAS</h4><p>CAS全称是Compare And Swap，即比较替换，是实现并发应用到的一种技术。操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p>
<h4 id="7-线程池"><a href="#7-线程池" class="headerlink" title="7.线程池"></a>7.线程池</h4><p>如果我们使用线程的时候就去创建一个线程，虽然简单，但是存在很大的问题。如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。线程池通过复用可以大大减少线程频繁创建与销毁带来的性能上的损耗。</p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>知识大纲</title>
    <url>/2019/11/07/md/develop/outline/</url>
    <content><![CDATA[<h4 id="md作用"><a href="#md作用" class="headerlink" title="md作用"></a>md作用</h4><ul>
<li>解耦</li>
<li>消峰</li>
<li>最终一致性</li>
<li>广播</li>
</ul>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul>
<li>TCC</li>
<li>最大努力通知型事务</li>
</ul>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>线上问题</title>
    <url>/2019/11/07/md/problem/pro/</url>
    <content><![CDATA[<h3 id="CPU100-问题如何快速定位"><a href="#CPU100-问题如何快速定位" class="headerlink" title="CPU100%问题如何快速定位"></a>CPU100%问题如何快速定位</h3><h4 id="找到占用cpu最高的进程"><a href="#找到占用cpu最高的进程" class="headerlink" title="找到占用cpu最高的进程"></a>找到占用cpu最高的进程</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> P 排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">top -c</span></pre></td></tr></table></figure>

<h4 id="取上一歩的进程pid-查询-占用cpu最高的线程"><a href="#取上一歩的进程pid-查询-占用cpu最高的线程" class="headerlink" title="取上一歩的进程pid,查询 占用cpu最高的线程"></a>取上一歩的进程pid,查询 占用cpu最高的线程</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> P 排序    11647上一歩的线程pid</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">top -Hp 11647</span></pre></td></tr></table></figure>

<h4 id="线程pid转16进制"><a href="#线程pid转16进制" class="headerlink" title="线程pid转16进制"></a>线程pid转16进制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> %x 表示 16进制 ;  \n  强制刷新缓冲区到屏幕   11656上一歩的线程pid</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">printf '%x\n' 11656</span></pre></td></tr></table></figure>

<h4 id="查看java栈信息-定位代码"><a href="#查看java栈信息-定位代码" class="headerlink" title="查看java栈信息,定位代码"></a>查看java栈信息,定位代码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">   11647第一歩的进程pid   2d88  占用的线程16进制   -c30 指打印出30行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">jstack 11647 | grep '2d88' -C30 --color</span></pre></td></tr></table></figure>
<p><img src="https://www.mqiy.xyz/image/problem/out-of-cpu.png" alt="out-of-cpu.png"></p>
]]></content>
      <tags>
        <tag>problem</tag>
      </tags>
  </entry>
  <entry>
    <title>SaaS</title>
    <url>/2019/11/06/md/part/project/saas/</url>
    <content><![CDATA[<p>SaaS产品与生俱来的的几个缺陷</p>
<ul>
<li>软件控制权</li>
<li>消费者基数</li>
<li>性能瓶颈</li>
<li>安全问题 (数据的隔离、敏感数据的加密、数据访问权限控制)</li>
</ul>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>vpn</title>
    <url>/2019/11/06/md/tool/vpn/</url>
    <content><![CDATA[<h3 id="安装v2ray"><a href="#安装v2ray" class="headerlink" title="安装v2ray"></a>安装v2ray</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span></pre></td></tr></table></figure>



<h3 id="MTProxy"><a href="#MTProxy" class="headerlink" title="MTProxy"></a>MTProxy</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/mtproxy.sh &amp;&amp; chmod +x mtproxy.sh &amp;&amp; bash mtproxy.sh</span></pre></td></tr></table></figure>



<h3 id="Brook"><a href="#Brook" class="headerlink" title="Brook"></a>Brook</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># https://github.com/txthinking/brook</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wget https://github.com/txthinking/brook/releases/download/v20190601/brook</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chmod</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod u+x brook</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## Shadowsocks</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">nohup brook ssserver -l :3072 -p Admin123# &gt; /dev/null 2&gt;&amp;1  &amp; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> brook server</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">nohup brook server -l :2222 -p Admin123#  &gt; /dev/null 2&gt;&amp;1  &amp;</span></pre></td></tr></table></figure>



<h3 id="youtube-dl"><a href="#youtube-dl" class="headerlink" title="youtube-dl"></a>youtube-dl</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> youtube</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wget http://www.youtube-dl.org/downloads/latest/youtube-dl</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod u+x youtube-dl</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要安装yasm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tar -zxvf yasm-1.3.0.tar.gz</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> yasm-1.3.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./configure</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> make &amp;&amp; make install</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> install ffmpep</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget https://ffmpeg.org/releases/ffmpeg-4.1.3.tar.bz2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tar -zxvf ffmpeg-4.1.tar.gz</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ffmpeg-4.1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span>/ffmpeg</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> make &amp;&amp; make install</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">vi /etc/profile</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在最后PATH添加环境变量：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">PATH=$PATH:/usr/local/ffmpeg/bin</span></pre></td></tr><tr><td class="code"><pre><span class="line">export PATH</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">保存退出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> source /ect/profile   设置生效</span></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">blog</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">nohup mvn spring-boot:run  &gt; /dev/null 2&gt;&amp;1 &amp;</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>撩妹</title>
    <url>/2019/11/06/md/life/pua/</url>
    <content><![CDATA[<h3 id="男票需做到"><a href="#男票需做到" class="headerlink" title="男票需做到"></a>男票需做到</h3><p>1、记得你的生日；</p>
<p>2、手机保持畅通让你能够联系得到他；</p>
<p>3、在乎你穿的暖不暖，有没有按时吃饭；</p>
<p>4、和他微信聊天时，态度积极，不会敷衍了事或总是隔很久才回复；</p>
<p>5、对你大方从不吝啬；</p>
<p>6、不嫌弃你；</p>
<p>7、一有时间就会抽空陪着你；</p>
<p>8、带你见过他最要好的朋友，甚至是家长；</p>
<p>9、憧憬你们的未来，计划里一定有你；</p>
<p>10、当你生病时，他会担心不已，亲自照顾你。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>撩妹</title>
    <url>/2019/11/06/md/life/flirt/pua/</url>
    <content><![CDATA[<h3 id="男票需做到"><a href="#男票需做到" class="headerlink" title="男票需做到"></a>男票需做到</h3><p>1、记得你的生日；</p>
<p>2、手机保持畅通让你能够联系得到他；</p>
<p>3、在乎你穿的暖不暖，有没有按时吃饭；</p>
<p>4、和他微信聊天时，态度积极，不会敷衍了事或总是隔很久才回复；</p>
<p>5、对你大方从不吝啬；</p>
<p>6、不嫌弃你；</p>
<p>7、一有时间就会抽空陪着你；</p>
<p>8、带你见过他最要好的朋友，甚至是家长；</p>
<p>9、憧憬你们的未来，计划里一定有你；</p>
<p>10、当你生病时，他会担心不已，亲自照顾你。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>男生找不到女朋友,90%的原因都这里</title>
    <url>/2019/11/06/md/life/flirt/why-alone/</url>
    <content><![CDATA[<p>1,总是当老好人<br>2,眼高手低<br>3,总是迎合女生的脚<br>4,总是表白<br>5,总是心眼好,但是说话不会拐弯抹角,容易好心办错事<br>6,总是见到女生,就没有话题聊,显得尴尬</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>男女</tag>
      </tags>
  </entry>
  <entry>
    <title>失败者的十大特点</title>
    <url>/2019/11/06/md/life/best-practice/failure/</url>
    <content><![CDATA[<p><strong>失败者的十大特点：</strong><br>一、脸皮薄<br>二、清高<br>三、懒惰<br>四、不喜欢学习<br>五、没情商<br>六、不舍得吃亏<br>七、不爱社交<br>八、不愿意求助他人<br>九、没有目标<br>十、胆小，不敢拼</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>一个男人永远不要做的事</title>
    <url>/2019/11/06/md/life/best-practice/never-done/</url>
    <content><![CDATA[<p>1.跟知己上床<br>2.和情人结婚<br>3.把同事当朋友<br>4.喜怒哀乐都挂在脸上<br>5.期待没有<em>经济基础<em>的爱情<br>6指望前女友</em>回心转意</em><br>7久病床前无孝子是正确的<br>8旧情复燃的结果,就是重蹈覆辙<br>9人际关系的核心不是你多好,而是你的实力有多强.</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐书籍</title>
    <url>/2019/11/06/md/tool/recommon-book/</url>
    <content><![CDATA[<h3 id="阿里毕玄：推荐给Java程序员的7本好书"><a href="#阿里毕玄：推荐给Java程序员的7本好书" class="headerlink" title="阿里毕玄：推荐给Java程序员的7本好书"></a>阿里毕玄：推荐给Java程序员的7本好书</h3><h4 id="Java相关的。"><a href="#Java相关的。" class="headerlink" title="Java相关的。"></a>Java相关的。</h4><p>《Java并发编程实战》<br>并发是高级语言里都需要掌握的稍微高级一些的技巧，这本书尽管是2012年的书了，但我觉得仍然是无比经典，绝对是必读书。<br>《Netty实战》<br>Netty是Java中通信框架实现的典范，非常值得通过这个来学习好语言中IO相关的知识，以及优秀的通信框架的写法。<br>《深入理解Java虚拟机（第2版）》<br>这本书我自己没看过，但听很多读过的同学的评价都是不错的，要真正的理解Java语言，就必须真正的去了解Java虚拟机，这样才能知道它的运行机制，例如Java编译、Java线程机制、Java内存管理等。<br>《Java性能优化权威指南》<br>这书是大神级人物写的，绝对值得一看，对排查问题、性能优化都有不小的帮助。<br>《Oracle JRockit: The Definitive Guide》<br>这书也是一本老书了，2010年写的，同样也是大神级人物写的，只有英文版，当年读这书对我学习JVM起到了很大的帮助，尽管Java同学主要用的是OpenJDK，而不是JRockit，而正因为有了对比，会对Java语言的实现有更深的理解。<br>《垃圾回收算法手册：自动内存管理的艺术》<br>中文版是2016年的，英文版是2011年的，这书对深刻的理解自动内存管理会有很大的帮助，毕竟其实自动内存管理这个领域的实现原理很多年是没有太大改变的，但实现的细节上有了很多的优化。<br>《性能之巅：洞悉系统、企业与云计算》<br>这书放在自己的想读列表里很久了，看评价应该是不错的，之前也说过，对于编程进阶的能力而言，查问题的能力是非常重要的一方面，这书应该有帮助，看过的同学也欢迎回复评价下。<br>还有很多书，先就推荐这些了，不过发现如果是论编程进阶相关的书，看起来还真有点缺，大部分书都是多年前写的。</p>
<h4 id="系统设计相关"><a href="#系统设计相关" class="headerlink" title="系统设计相关"></a>系统设计相关</h4><p>《架构即未来：现代企业可扩展的Web架构、流程和组织(原书第2版)》<br>这书没看过，不过英文版我记得有点印象，评价好像不错的，欢迎看过的同学来说说。<br>《大型网站系统与Java中间件开发实践》<br>老伙伴华黎几年前写的书，对于开发大型的Web系统的同学而言是很值得学习的。<br>《SRE：Google运维解密》<br>理论上这不算系统设计的书，但运维其实是系统设计中很重要的要考虑的环节，我以前见过有些架构师设计的系统到上线的时候才发现少考虑了东西，导致上线没法上，我自己其实也干过这样的书，所以对于架构师而言，通过读这些书来扩充视野是非常重要的。<br>系统设计相关的书写的好的还真是有点少，当然也有原因是我看这方面的书很少。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>《智能时代》吴军<br>很值得推荐，看这书能更充分的感受到智能时代带来的冲击，例如智能+工业可能会发生什么。<br>看这些类型的书对自己在技术方向的判断上是能有不错的帮助的。</p>
<p>《人类简史》<br>很多地方都在推荐，对我来说是看了后才更加明白了人类发展，例如人类的协同演进。<br>《大学之路》 吴军<br>可能很多人都觉得这书是在讲怎么选美国的大学，以及怎么考，但看了后我觉得最值得推荐的是看这书才明白了高等教育的两个主流理念，以及美国、英国这些大学是怎么建设的，为什么和国内的高等教育会不同，强烈推荐。<br>《鞋狗》<br>看Nike的创始人是怎么把Nike做起来的，挺有意思的，可能是也很对胃口吧，兴趣和专业，是能做起来的关键。</p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>几条也许有用的生活建议</title>
    <url>/2019/11/06/md/life/best-practice/sevel-lift-advice/</url>
    <content><![CDATA[<p>1、坚持锻炼</p>
<p>你不一定非要去健身房撸铁，也不用非要去报瑜伽班，只要能保持一周3-4天的锻炼就可以，锻炼的方式有很多种，建议最好可以选择跑步，一开始可以从一公里、两公里慢慢坚持，设立目标，不必追求速度，慢跑即可，渐渐你会发现坚持十公里也不是多困难的事情。</p>
<p>2、阅读</p>
<p>你不一定非要有多高的学历，不一定非要名校毕业，但是希望你养成天天阅读的习惯，根据自己的爱好，买上几本名著，每晚入睡前阅读上几页，你会睡的更香，而且慢慢你会发现再和朋友聊天，不论朋友们聊到什么样的话题，你都不再无话可接。</p>
<p>3、不要把幸福寄托在别人身上</p>
<p>这或许很难，但是一定要明白人会变、情会散，人生的路就是要自己走，没有人可以代替我们的幸福，也不能有人夺走我们的幸福，自给自足的幸福才不会患得患失。</p>
<p>4、沉稳</p>
<p>比如任何事情，不要太早急于下结论；不随意表露自己的情绪；遇到事情，都要强制自己冷静下来，只有冷静，才会想到更好的应对方法。如果一开始做不到，压制不住内心的激动或紧张，那就装，使劲装，直到做到。</p>
<p>5、及时止损</p>
<p>不要在一个不爱你或者你不爱的人身上浪费时间；不要在你不喜欢且毫无好处的事情上浪费精力。一个人或者一件事，如果发现不对，要及时暂停付出，这样才能不会让自己的时间、经历甚至金钱白白浪费。</p>
<p>6、不和别人比较</p>
<p><code>一辈子都要和别人比较是人生悲剧的源头。</code>不要拿自己的缺点和别人的优点比较；可以去羡慕别人，不要去嫉妒别人，我们遇到的每个人，要去发现别人的优点，然后去学习，看到别人的缺点，要联想到自己，在自身避免。</p>
<p>7、培养有一个爱好</p>
<p>它可以是唱歌、跳舞、乐器、画画、篮球、羽毛球等等，因为它可以让你在遇到挫折的时候转移注意力；还可以在高兴的时候更加放飞自我；也可以让你在朋友面前更好的展现自己。</p>
<p>8、拥有另一份收入</p>
<p>除了工作，一定要再有一个挣钱的技能，“挑水的同时不要忘记挖井”，这可以增加你的收入，况且任何职业都没有真正的“铁饭碗”，一旦有一天你失去工作，你会庆幸你还有一份可以维持生计的收入。</p>
<p>9、控制情绪</p>
<p>这一条或许你觉得与第四条相似，但相似绝不重复，这一点我想说的是与家人、朋友、同事相处，都可能会产生摩擦或矛盾，这个时候我希望你不论多生气，都先冷静30秒再说话，带着愤怒的情绪处理一件事只会让这件事最后变的更加糟糕。反之也是一样，得意但不要忘形。</p>
<p>10、万恶淫为首</p>
<p>这里的“淫”不是指淫欲或淫秽的意思，而是指“放纵、没有节制”，意思是讲这个世界上最大的恶是做事没有节制且放纵自己，不论好事还是坏事，适度最好，正如《论语•八佾》关雎中所说：“乐而不淫，哀而不伤”。</p>
<p>11、知行合一</p>
<p>最后一条算是对以上十条的再次叮嘱，王阳明提出“知行合一”，是要告诉我们“知道做不到，等于不知道”。再多的道理如果只是停留在知道的层面，而没有去付出实践，那这一切都将只是徒劳。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员，活得是本事：30 岁后的 20 条人生建议</title>
    <url>/2019/11/06/md/life/best-practice/thirty-year-advice/</url>
    <content><![CDATA[<p>一个程序员看待职业的方式，决定了他能走多远。</p>
<p>有的人把职业当游戏，不论 buff 还是 bug 都要闯过去；有的人把职业当对手，不是一心想赢，只是不想输；有的人，活得是造型；有的人，活得是人设；程序员，活得是本事。</p>
<p>今天，我们采访了 10 多位程序员，并将他们的经验整理成这篇《程序员的 20 条职业感悟》。请查阅。</p>
<h3 id="关于-Work-life-balance"><a href="#关于-Work-life-balance" class="headerlink" title="关于 Work life balance"></a>关于 Work life balance</h3><p>❶ 把身体锻炼好，只要你有一个健康的身体和健康的生活观，这个世界就饿不死人。</p>
<p>❷ 最好能够做到早起，一方面早上人的头脑比较清晰，另一方面可以在没有人打扰的时间里多学点东西。</p>
<p>❸ 自己的发展路线应该是最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。主要是通过实践，其次是要有意识地构造。</p>
<p>❹ 学习的能力和阅读的习惯，是从大学毕业后最该带到工作里的两样东西。</p>
<p>❺ 不要做个纯码农，多抽空做点其他自己感兴趣的事情。</p>
<h3 id="于技术"><a href="#于技术" class="headerlink" title="于技术"></a>于技术</h3><p>❶ 编程是一件需要技术积累的工作。涉及的不仅仅是写程序，还有对系统的了解，对工具的熟悉，工作方法，经验很重要。</p>
<p>❷ 学习新技术的时候多看“官方文档”。编写文档的人群，通常就是这些技术或者软件的开发者，他们是对这些东西最了解的人。因此，官方文档质量是很高的，通常也是最新的。</p>
<p>❸ 把觉得不靠谱的需求放到最后做，也许到时候需求就变了。</p>
<p>❹ 宁愿终止程序也不要带着错误运行下去。</p>
<p>❺ 隔一段时间就回去看看自己几个月之前写的代码，这能够让你认识到代码的可读性有多重要，亲身体会才能懂得。</p>
<p>❻ 程序不等于数据结构加算法，而等于搜索引擎加英语。</p>
<h3 id="关于年龄"><a href="#关于年龄" class="headerlink" title="关于年龄"></a>关于年龄</h3><p>❶ 所谓的年龄歧视是在给自己设定心理障碍，你真正应该担心的不是年龄，在于你是否有职业规划，是否朝职业目标努力，你的年龄是否达到了相应的能力及经验。</p>
<p>❷ 如果你坚持持续学习，不管在哪一个行业都会越老越香的。</p>
<p>❸ 无论年龄多大，需要学习的东西有很多，在专业的道路上还是要继续尝试做技术创新。</p>
<p>❹ 条条大路通罗马，选择一个自己热爱的行业很重要。</p>
<p>04</p>
<h3 id="关于情商"><a href="#关于情商" class="headerlink" title="关于情商"></a>关于情商</h3><p>❶ 心要皮实，但话语和脸皮要柔软，记住有句老话叫，伸手不打笑脸人。</p>
<p>❷ 编码的时候只思考同一个思维层次的逻辑，在这层完成之后再思考下一层。</p>
<p>❸ 千万别真的认为别人都是傻逼，否则会降低你的可合作性，可合作性在团队里是项很重要的能力。</p>
<p>❹ 真正的领导能力不是令人服从，而是让大家用正确高效的方法完成任务。</p>
<p>❺ 永远别小看程序媛。</p>
<p>对了，还有一条最重要的感悟是几位程序员共同提到的</p>
<p>一定要记录自己的技术积累</p>
<p>才能获得技术的提升</p>
<p>不论是写文章还是做分享</p>
<p>或许你资历尚浅，技术思路和技术方向还很难摸清。这时学习与模仿对你来说至关重要，学习别人思考问题的角度，分析成熟的技术文章的知识脉络。</p>
<p>这样做的意义在于：</p>
<ul>
<li>从自身学习出发：从别人的思路里看到自己的技术边界，找到一个方向学习；</li>
<li>从业务方向出发：看看别人输出成熟的技术实践，帮助你解决业务难题</li>
<li>比如说，各大社区技术达人、技术大佬的那些高质量文章，总有一篇能够戳中当下现状的你，汲取他们的技术经验和技术思想，应用在自己的学习与项目中。</li>
</ul>
<p><strong>加油，不给自己留遗憾~</strong></p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>你之所以感到不快乐，其实是因为你还不够自私</title>
    <url>/2019/11/06/md/life/thinking/need-self/</url>
    <content><![CDATA[<p>人是自然的产物，所有对于人性的研究自然要从人与自然说起。</p>
<p>达尔文的生物进化论、社会心理学、生物学、生理学等多个领域的研究都一致表明：</p>
<p>人类的本性不仅仅存在生理需求还存在情感需求，情感需求即快乐以及痛苦的情绪表达。</p>
<p>追求快乐是人的天性，而造成快乐与痛苦的因素其实有很多，适当的自私也的确可以让人更快乐。</p>
<p>当然，这里所讲的自私，并不是让你去做一个遭人厌弃之人，而是在保证别人利益的前提下，多为自己考虑，更多的去关注自己的情绪变化及心理需求。</p>
<p>心理学：你之所以感到不快乐，其实是因为你还不够自私<br>我们习惯给那些自私的人贴上标签：以自我为中心，贪婪，冷酷，吝啬，敏感，多疑，性格孤僻。总之，自私在群体意识中属于贬义词，然而，人的本性其实是是自私的，因为追求快乐是生存的意义，具有生物适应性。</p>
<p>社会心理学观点认为，人在社会群体中的幸福指数高低，不是权利，更不是财富，而是保持良好的心态，即拥有一个好心情。所以，通过适度的自私让自己保持快乐是非常有必要的。</p>
<p>心理学：你之所以感到不快乐，其实是因为你还不够自私<br>高尚的无私</p>
<p>相比于自私，无私则是一种崇高的精神，指的是对别人无私奉献，没有私心。你有没有过这样的经历。</p>
<p>下班回来，爱人翘着二郎腿，玩着手机，享受着美好的游戏时光，你用“无私”告诉自己，要做一个贤妻良母，做着家务，照顾着孩子，还要为家人准备一顿可口的饭菜。</p>
<p>假期里，老板的一个电话催促你回去义务加班，你用“无私”告诉自己做一个好员工，提前结束了自己的假期生活。</p>
<p>当父母打着为你好的旗号，不去顾虑的意愿，强行左右你的人生之时，你用“无私”告诉自己做一个好儿女，放弃了自己的坚持。</p>
<p>心理学：你之所以感到不快乐，其实是因为你还不够自私<br>但是，在你无私的做了这些事情以后，你会发现，自己并不开心。这些通过强制手段去扭曲自身意识的事情，压的你喘不过气，让你根本快乐不起来。</p>
<p>重点是，我们一边在做着“无私”的事情，压抑着自己的心性，委屈着自己，一边又自私的在心里为自己鸣不平。其实，你完全可以更自私一点。</p>
<p>心理学：你之所以感到不快乐，其实是因为你还不够自私<br>高尚的自私</p>
<p>尼采曾经说过：最高尚的人恰恰是最自私的人。美国心理学博士大卫·西伯里提出“高尚的自私”这个概念，大卫认为，现代人最大的苦恼在于过度迎合，讨好别人，以至于逐渐丧失了自我。</p>
<p>他崇尚“自私”，是一种尊重自我内心，强调自我价值的“自私”，以免让人们在“无私”中失去了自我。因为，所有装出来崇高的“无私”，最后都会以最自私的形式表现出来。</p>
<p>最终伤害的不仅仅是你，还有被你宠坏的对方。所以，西伯里博士所说的崇尚自私，其实是在教你如何关注自我，回归自我。</p>
<p>心理学：你之所以感到不快乐，其实是因为你还不够自私<br>适度自私，尊重人性</p>
<p>与其为了别人委屈自己，逼自己去做一个“无私”的人，不如，适当的放开心性，让自己适度“自私”，获得快乐和开心。</p>
<p>当然，此自私非彼自私，那些只考虑自己，而忽略别人感受的人，是令人厌恶的，排斥的，那是真正自私的人。而为了保障自身利益，适度的对别人自私一点，这不算真正的自私，最多只是人性的体现而已。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>你骨子里的自卑，源自于这4个坏习惯</title>
    <url>/2019/11/06/md/life/best-practice/four-bad-habbit/</url>
    <content><![CDATA[<p>人的大脑是一个神奇的存在，因为当身体都发育完全时，它却仍在发育。大脑的发育就是大脑各条神经元连接的过程，而脑发育不单单是自我完成的，更是要接受外部的刺激，共同完成的，所以说最具有可塑性的部位就是我们的大脑了。</p>
<p>大脑不但支配我们的行为和动作，还作用于我们的心理、认知、知觉、个性和情绪等等。一个人想要有美好的梦想，就需要一步步努力实现，在这个过程中，还需要克服很多心理固有的负面而错误的情绪和认知习惯，我们要探讨的这4个习惯是我们前行道路上面的绊脚石，人们需要一步一步除去，否则会发生恶性循环，造成自卑情结。</p>
<p>心理学家：你骨子里的自卑，源自于这4个坏习惯</p>
<h2 id="一、讨好型人格"><a href="#一、讨好型人格" class="headerlink" title="一、讨好型人格"></a>一、讨好型人格</h2><p>很多时候，我们都想做一个人人喜欢的人，一点都不希望自己和别人发生冲突，哪怕一个反驳的眼神，我们都不愿意给别人。即使这种活法让我们付出很多代价，我们也在所不惜。好像自己就是给别人活的，自己的精力和体力，还有快乐和伤悲都是以别人的一个眼神，一句评价为转移的。</p>
<p>我们用尽自己的力气讨好别人，生怕自己被拒绝。但是要知道这种讨好型人格持续时间久了，会让你陷入一种心理障碍中，对于外界压力会产生一种不耐受，久而久之就会影响你的身心健康。</p>
<p>其实讨好型人格的形成，大多和原生家庭有关。在幼年的时候，家庭中的照顾者可能是比较强势的人，或者他们有虐待孩子的倾向。抑或是照顾者是某类精神疾病的罹患者，你接受到的讯号就是，你需要满足照顾者不正常的欲望和需求才能得到他们的肯定和关注，这样就造成了孩子安全感的缺失，需要从讨好别人中获得片刻的安全和安慰。</p>
<p>心理学家：你骨子里的自卑，源自于这4个坏习惯</p>
<h3 id="二、时时有罪恶感和挫败感"><a href="#二、时时有罪恶感和挫败感" class="headerlink" title="二、时时有罪恶感和挫败感"></a>二、时时有罪恶感和挫败感</h3><p>在自己做某一样事情的时候，时时涌现出一种莫名的罪恶感。也许是在高压强的工作后，想要片刻的放松，立刻有一个声音提醒你：你还不够成功，你这样就觉得累吗，很多人都比你强的多，人家还在努力。</p>
<p>于是你马上就生发出一种，别人工作努力，你在闲着的罪恶感觉。这种罪恶感在一定界限里面的时候诚然能够激发我们更多的斗志，但是如果过了的话，就会让我们处于一种高度紧张和压力的状态下，对我们各方面都是一种伤害的。</p>
<p>有的人经历一次失败了，就被打到了，总是有一种挫败的感觉。做什么事情都是小心翼翼的，他会把某一个领域的挫败感推及过各个领域中，让自己活得如同惊弓之鸟。</p>
<p>时间久了，你的这种挫败感会给你更多的暗示，让你不敢尝试很多事情。这个时候，你需要认清这种现实，抛弃那些太过于追求极致的心情，客观评价面临的情况，然后抓住机会，勇于迈开步伐，你会发现原来一些并不是你所看到的那样沮丧。</p>
<p>心理学家：你骨子里的自卑，源自于这4个坏习惯</p>
<h3 id="三、总是觉得自己得到的不完美"><a href="#三、总是觉得自己得到的不完美" class="headerlink" title="三、总是觉得自己得到的不完美"></a>三、总是觉得自己得到的不完美</h3><p>有的人在别人眼中获得的已经很多了，也是相当成功的，但是他总是感觉自己所得到的和自己的能力不匹配，总是活在一种有缺憾的感觉里。他们会为了这个缺憾而忽视自己所得到的，时间久了，会让自己更加沮丧和失落。</p>
<p>殊不知些许的缺憾感，会让你获得一些前行的动力，也会让你总结教训失败，鞭策自己调整自己的目标。但如果人沉浸其中不能自拔的话，就是一种相当危险的情况了。这种缺憾感会蒙蔽你的眼睛，让你失去动力。关注当下，抓住当下，过好每一天，感恩每一天才是生活的真谛。</p>
<p>心理学家：你骨子里的自卑，源自于这4个坏习惯</p>
<h3 id="四、让自己沉湎于无意义的对比情绪中"><a href="#四、让自己沉湎于无意义的对比情绪中" class="headerlink" title="四、让自己沉湎于无意义的对比情绪中"></a>四、让自己沉湎于无意义的对比情绪中</h3><p>想必人活在这个世界，最常做的事情就是拿自己和别人比较了。这种比较的生活已经成为一部分人的生活质量、成功程度和富有程度的一个衡量标准了。当然，这个比较包括向上性的和向下性的。也就是我们通常所说的，比上不足，比下有余。当人们向上比较的时候，总是感觉自己不如别人有钱，不如别人过得好。</p>
<p>可能会生发出一种失落、失望的情绪。而向下比较的时候，又会觉得自己过得比别人好，有一种优越感。殊不知，在光鲜亮丽之下，也会有着不足为外人道的心酸和痛苦，这些你真的有去想过吗？说白了，这种时刻总想比较的心态真的是毫无意义。</p>
<p>心理学家：你骨子里的自卑，源自于这4个坏习惯<br>因为人们在得到一些的同时，也必将失去一些，这些不在一个水平上的比较有何意思呢。即使是同一个家庭走出来的孩子，也是不相同的，不是吗。所以尽早放下这种比较情节，让自己活得更轻松吧。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>最全BAT面试精华汇总</title>
    <url>/2019/11/06/md/interview/baidu-most-interview/</url>
    <content><![CDATA[<p><strong>这些题目百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐等一线互联网公司面试被问到的题目,熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。</strong></p>
<h3 id="java基础面试知识点"><a href="#java基础面试知识点" class="headerlink" title="java基础面试知识点"></a>java基础面试知识点</h3><p>java中==和equals和hashCode的区别<br>int、char、long各占多少字节数<br>int与integer的区别<br>探探对java多态的理解<br>String、StringBuffer、StringBuilder区别<br>什么是内部类？内部类的作用<br>抽象类和接口区别<br>抽象类的意义<br>抽象类与接口的应用场景<br>抽象类是否可以没有方法和属性？<br>接口的意义<br>泛型中extends和super的区别<br>父类的静态方法能否被子类重写<br>进程和线程的区别<br>final，finally，finalize的区别<br>序列化的方式<br>Serializable 和Parcelable 的区别<br>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？<br>静态内部类的设计意图<br>成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用<br>谈谈对kotlin的理解<br>闭包和局部内部类的区别<br>string 转换成 integer的方式及原理</p>
<h3 id="java深入面试题"><a href="#java深入面试题" class="headerlink" title="java深入面试题"></a>java深入面试题</h3><p>哪些情况下的对象会被垃圾回收机制处理掉？<br>讲一下常见编码方式？<br>utf-8编码中的中文占几个字节；int型几个字节？<br>静态代理和动态代理的区别，什么场景使用？<br>Java的异常体系<br>谈谈你对解析与分派的认识。<br>修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？<br>Java中实现多态的机制是什么？<br>如何将一个Java对象序列化到文件里？<br>说说你对Java反射的理解<br>说说你对Java注解的理解<br>说说你对依赖注入的理解<br>说一下泛型原理，并举例说明<br>Java中String的了解<br>String为什么要设计成不可变的？<br>Object类的equal和hashCode方法重写，为什么？</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>常用数据结构简介<br>并发集合了解哪些？<br>列举java的集合以及集合之间的继承关系<br>集合类以及集合框架<br>容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类）<br>List,Set,Map的区别<br>List和Map的实现方式以及存储方式<br>HashMap的实现原理<br>HashMap数据结构？<br>HashMap源码理解<br>HashMap如何put数据（从HashMap源码角度讲解）？<br>HashMap怎么手写实现？<br>ConcurrentHashMap的实现原理<br>ArrayMap和HashMap的对比<br>HashTable实现原理<br>TreeMap具体实现<br>HashMap和HashTable的区别<br>HashMap与HashSet的区别<br>HashSet与HashMap怎么判断集合元素重复？<br>集合Set实现Hash怎么防止碰撞<br>ArrayList和LinkedList的区别，以及应用场景<br>数组和链表的区别<br>二叉树的深度优先遍历和广度优先遍历的具体实现<br>堆的结构<br>堆和树的区别<br>堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？<br>什么是深拷贝和浅拷贝<br>手写链表逆序代码<br>讲一下对树，B+树的理解<br>讲一下对图的理解<br>判断单链表成环与否？<br>链表翻转（即：翻转一个单项链表）<br>合并多个单有序链表（假设都是递增的）</p>
<h3 id="线程、多线程和线程池"><a href="#线程、多线程和线程池" class="headerlink" title="线程、多线程和线程池"></a>线程、多线程和线程池</h3><p>开启线程的三种方式？<br>线程和进程的区别？<br>为什么要有线程，而不是仅仅用进程？<br>run()和start()方法区别<br>如何控制某个方法允许并发访问线程的个数？<br>在Java中wait和seelp方法的不同；<br>谈谈wait/notify关键字的理解<br>什么导致线程阻塞？<br>线程如何关闭？<br>讲一下java中的同步的方法<br>数据一致性如何保证？<br>如何保证线程安全？<br>如何实现线程同步？<br>两个进程同时要求写或者读，能不能实现？如何防止进程的同步？<br>线程间操作List<br>Java中对象的生命周期<br>Synchronized用法<br>synchronize的原理<br>谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解<br>static synchronized 方法的多线程访问和作用<br>同一个类里面两个synchronized方法，两个线程同时访问的问题<br>volatile的原理<br>谈谈volatile关键字的用法<br>谈谈volatile关键字的作用<br>谈谈NIO的理解<br>synchronized 和volatile 关键字的区别<br>synchronized与Lock的区别<br>ReentrantLock 、synchronized和volatile比较<br>ReentrantLock的内部实现<br>lock原理<br>死锁的四个必要条件？<br>怎么避免死锁？<br>对象锁和类锁是否会互相影响？<br>什么是线程池，如何使用?<br>Java的并发、多线程、线程模型<br>谈谈对多线程的理解<br>多线程有什么要注意的问题？<br>谈谈你对并发编程的理解并举例说明<br>谈谈你对多线程同步机制的理解？<br>如何保证多线程读写文件的安全？<br>多线程断点续传原理<br>断点续传的实现</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>排序算法有哪些？<br>最快的排序算法是哪个？<br>手写一个冒泡排序<br>手写快速排序代码<br>快速排序的过程、时间复杂度、空间复杂度<br>手写堆排序<br>堆排序过程、时间复杂度及空间复杂度<br>写出你所知道的排序算法及时空复杂度，稳定性<br>二叉树给出根节点和目标节点，找出从根节点到目标节点的路径<br>给阿里2万多名员工按年龄排序应该选择哪个算法？<br>GC算法(各种算法的优缺点以及应用场景)<br>蚁群算法与蒙特卡洛算法<br>子串包含问题(KMP 算法)写代码实现<br>一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法<br>万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射-&gt;hash分组-&gt;多文件读写效率-&gt;磁盘寻址以及应用层面对寻址的优化)</p>
<h3 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h3><p>MySQL InnoDB、Mysaim的特点？<br>乐观锁和悲观锁的区别？<br>数据库隔离级别是什么？有什么作用？<br>MySQL主备同步的基本原理。<br>select * from table t where size &gt; 10 group by size order by size的sql语句执行顺序？<br>如何优化数据库性能（索引、分库分表、批量操作、分页算法、升级硬盘SSD、业务优化、主从部署）<br>SQL什么情况下不会使用索引（不包含，不等于，函数）<br>一般在什么字段上建索引（过滤数据最多的字段）<br>如何从一张表中查出name字段不包含“XYZ”的所有行？<br>MySQL，B+索引实现，行锁实现，SQL优化<br>Redis，RDB和AOF，如何做高可用、集群<br>如何解决高并发减库存问题<br>mysql存储引擎中索引的实现机制；<br>数据库事务的几种粒度；<br>行锁，表锁；乐观锁，悲观锁</p>
<h3 id="Redis等缓存系统中间件"><a href="#Redis等缓存系统中间件" class="headerlink" title="Redis等缓存系统中间件"></a>Redis等缓存系统中间件</h3><p>列举一个常用的Redis客户端的并发模型。<br>HBase如何实现模糊查询？<br>列举一个常用的消息中间件，如果消息要保序如何实现？<br>如何实现一个Hashtable？你的设计如何考虑Hash冲突？如何优化？<br>分布式缓存，一致性hash<br>LRU算法，slab分配，如何减少内存碎片<br>如何解决缓存单机热点问题<br>什么是布隆过滤器，其实现原理是？ False positive指的是？<br>memcache与redis的区别<br>zookeeper有什么功能，选举算法如何进行<br>map/reduce过程，如何用map/reduce实现两个数据源的联合统计</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>最全BAT数据库面试89题</title>
    <url>/2019/11/06/md/interview/baidu-db-interview/</url>
    <content><![CDATA[<h4 id="数据库-mysql面试题目："><a href="#数据库-mysql面试题目：" class="headerlink" title="数据库 mysql面试题目："></a>数据库 mysql面试题目：</h4><p>MySQL InnoDB、Mysaim的特点？<br>乐观锁和悲观锁的区别？？<br>行锁和表锁的区别？<br>数据库隔离级别是什么？有什么作用？<br>MySQL主备同步的基本原理。<br>如何优化数据库性能（索引、分库分表、批量操作、分页算法、升级硬盘SSD、业务优化、主从部署）<br>SQL什么情况下不会使用索引（不包含，不等于，函数）<br>一般在什么字段上建索引（过滤数据最多的字段）<br>MySQL，B+索引实现，行锁实现，SQL优化<br>如何解决高并发减库存问题<br>数据库事务的几种粒度</p>
<h4 id="数据库-题目："><a href="#数据库-题目：" class="headerlink" title="数据库 题目："></a>数据库 题目：</h4><p>事务四大特性（ACID）<br>数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别<br>MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景<br>数据库的优化（从sql语句优化和索引两个部分回答）<br>索引有B+索引和hash索引，各自的区别<br>B+索引数据结构，和B树的区别<br>索引的分类（主键索引、唯一索引），最左前缀原则，哪些情况索引会失效<br>聚集索引和非聚集索引区别。<br>有哪些锁（乐观锁悲观锁），select时怎么加排它锁<br>关系型数据库和非关系型数据库区别<br>MVCC机制</p>
<h4 id="数据库实战"><a href="#数据库实战" class="headerlink" title="数据库实战"></a>数据库实战</h4><p>数据库三范式，根据秒杀场景设计数据表<br>数据库的主从复制<br>死锁怎么解决<br>mysql并发情况下怎么解决（通过事务、隔离级别、锁）</p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>redis数据结构有哪些<br>redis队列应用场景<br>redis和Memcached（支持数据持久化）<br>Redis，RDB和AOF，如何做高可用、集群</p>
<h4 id="大数据："><a href="#大数据：" class="headerlink" title="大数据："></a>大数据：</h4><p>mapreduce过程<br>hbase和传统数据库的区别<br>hbase读数据过程<br>hbase master和regionserver的交互<br>hbase的ha，zookeeper在其中的作用，master宕机的时候，哪些能正常工作，读写数据？region分裂？<br>数据倾斜<br>mysql索引，哪些索引？实现原理？哪些存储引擎支持B树索引，哪些支持hash索引？<br>为啥mysql索引要用B+树而MongoDB用B树？<br>Mysql查询优化？<br>主键和唯一索引的区别<br>事务的隔离机制，mysql默认是哪一级<br>MyISAM和InnoDB存储引擎的区别<br>mysql查询优化，慢查询怎么去定位？<br>mysql中的各种锁，乐观锁，悲观锁（排他锁，共享锁）；行锁，表锁是怎么实现的？<br>mapreduce支持哪些join，map端？reduce端？semi join？semi join你可以通过什么算法去优化？<br>mapreduce实现二次排序<br>用mapreduce实现两表join<br>用mapreduce实现一个存储kv数据的文件，对里面的v进行全量排序<br>zookeeper实现原理，zab协议以及原子广播协议<br>paxos协议，multi-paxos，zab，raft各种分布式协议内容，使用场景<br>hadoop namenode的ha，主备切换实现原理，日志同步原理，QJM中用到的分布式一致性算法（就是paxos算法）<br>spark运行架构<br>spark运行原理，从提交一个jar到最后返回结果，整个过程<br>spark的stage划分是怎么实现的？拓扑排序？怎么实现？还有什么算法实现？<br>spark rpc，spark2.0为啥舍弃了akka，而用netty?<br>spark的各种shuffle，与mapreduce的对比<br>spark的各种ha，master的ha，worker的ha，executor的ha，driver的ha,task的ha,在容错的时候对集群或是task有什么影响？<br>spark的内存管理机制，spark1.6前后对比分析<br>spark2.0做出了哪些优化？tungsten引擎？cpu与内存两个方面分别说明<br>spark rdd、dataframe、dataset区别<br>callable runnable 区别<br>synchronized与lock区别<br>类加载机制<br>gc算法<br>spark数据倾斜<br>spark shuffle<br>spark 内存管理<br>各种排序算法，时间复杂度，空间复杂度，spark和hadoop中shuffle中各个阶段用到的排序算法把这几种排序算法的使用场景表现得淋漓尽致啊。</p>
<h4 id="常见数据库面试题目和答案："><a href="#常见数据库面试题目和答案：" class="headerlink" title="常见数据库面试题目和答案："></a>常见数据库面试题目和答案：</h4><p>1、触发器的作用？</p>
<blockquote>
<p>触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
</blockquote>
<p>2、什么是存储过程？用什么来调用？</p>
<blockquote>
<p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 调用： 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序。</p>
</blockquote>
<p>3、存储过程的优缺点？</p>
<p>优点： 1）存储过程是预编译过的，执行效率高。 2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 3）安全性高，执行存储过程需要有一定权限的用户。 4）存储过程可以重复使用，可减少数据库开发人员的工作量。 缺点：移植性差</p>
<p>4、存储过程与函数的区别</p>
<p>存储过程函数用于在数据库中完成特定的操作或者任务（如插入、删除等）用于特定的数据（如选择）程序头部声明用procedure程序头部声明用function程序头部声明时不需描述返回类型程序头部声明时要描述返回类型，而且PL/SQL块中至少要包括一个有效的return语句可以使用in/out/in out 三种模式的参数可以使用in/out/in out 三种模式的参数可作为一个独立的PL/SQL语句来执行不能独立执行，必须作为表达式的一部分调用可以通过out/in out 返回零个或多个值通过return语句返回一个值，且改值要与声明部分一致，也可以是通过out类型的参数带出的变量SQL语句(DML 或SELECT)中不可调用存储过程SQL语句(DML 或SELECT)中可以调用函数</p>
<p>5、索引的作用？和它的优点缺点是什么？</p>
<p>索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。</p>
<p>6、什么样的字段适合建索引</p>
<p>唯一、不为空、经常被查询的字段</p>
<p>7、索引类型有哪些？</p>
<p>逻辑上：</p>
<p>Single column 单行索引</p>
<p>Concatenated 多行索引</p>
<p>Unique 唯一索引</p>
<p>NonUnique 非唯一索引</p>
<p>Function-based 函数索引</p>
<p>Domain 域索引 物理上：</p>
<p>Partitioned 分区索引</p>
<p>NonPartitioned 非分区索引</p>
<p>B-tree ：</p>
<p>Normal 正常型B树</p>
<p>Rever Key 反转型B树 Bitmap 位图索引</p>
<p>8、什么是事务？什么是锁？</p>
<p>事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。 锁：在所以的DBMS中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。</p>
<p>9、什么叫视图？游标是什么？</p>
<p>视图：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
<p>10、视图的优缺点</p>
<p>优点： 1）对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。 2 ）用户通过简单的查询可以从复杂查询中得到结果。 3 ）维护数据的独立性，试图可从多个表检索数据。 4 ）对于相同的数据可产生不同的视图。 缺点： 性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</p>
<p>11、列举几种表连接方式,有什么区别？</p>
<p>内连接、自连接、外连接（左、右、全）、交叉连接 内连接：只有两个元素表相匹配的才能在结果集中显示。 外连接： 左外连接:左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 全外连接：连接的表中不匹配的数据全部会显示出来。 交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。</p>
<p>12、主键和外键的区别？</p>
<p>主键在本表中是唯一的、不可唯空的，外键可以重复可以唯空；外键和另一张表的主键关联，不能创建对应表中不存在的外键。</p>
<p>13、在数据库中查询语句速度很慢，如何优化？</p>
<p>1.建索引 2.减少表之间的关联 3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面 4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 5.尽量用PreparedStatement来查询，不要用Statement</p>
<p>14、数据库三范式是什么?</p>
<p>第一范式：列不可再分 第二范式：行可以唯一区分，主键约束 第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束 且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上</p>
<p>15、union和union all有什么不同?</p>
<p>UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。 UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。 从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL。</p>
<p>16、Varchar2和varchar有什么区别？</p>
<p>Char的长度是固定的，而varchar2的长度是可以变化的，比如，存储字符串“abc”对于char(20)，表示你存储的字符将占20个字节，包含17个空，而同样的varchar2（20）只占了3个字节，20只是最大值，当你存储的字符小于20时，按实际长度存储。 char的效率要被varchar2的效率高。 目前varchar是varchar2的同义词，工业标准的varchar类型可以存储空字符串，但是oracle不能这样做，尽管它保留以后这样做的权利。Oracle自己开发了一个数据类型varchar2,这个类型不是一个标准的varchar，他将在数据库中varchar列可以存储空字符串的特性改为存储null值，如果你想有向后兼容的能力，oracle建议使用varchar2而不是varchar</p>
<p>17、Oracle和Mysql的区别？</p>
<p>1）库函数不同。 2）Oracle是用表空间来管理的，Mysql不是。 3）显示当前所有的表、用户、改变连接用户、显示当前连接用户、执行外部脚本的语句的不同。 4）分页查询时候时候，mysql用limit oracle用rownum</p>
<p>21、order by与group by的区别</p>
<blockquote>
<p>order by 排序查询、asc升序、desc降序 group by 分组查询、having 只能用于group by子句、作用于组内，having条件子句可以直接跟函数表达式。使用group by 子句的查询语句需要使用聚合函数。</p>
</blockquote>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>百度高级java工程师面试实拍59题：高并发+中间件+分布式架构</title>
    <url>/2019/11/06/md/interview/distributed-high-use/</url>
    <content><![CDATA[<h3 id="百度一面面试题目"><a href="#百度一面面试题目" class="headerlink" title="百度一面面试题目"></a>百度一面面试题目</h3><h4 id="Java面试题目"><a href="#Java面试题目" class="headerlink" title="Java面试题目:"></a>Java面试题目:</h4><ul>
<li>Java读取一个文件, 有哪些方法, 考虑性能, 用哪一个类</li>
<li>BIO, NIO, AIO区别<br>Java 类加载机制<br>为什么使用双亲委派模型<br>NIO的组件, Selector<br>什么是序列化, IO的序列化方式, 为什么需要序列化(包括在网络传输的情况下)<br>Error和Exception区别<br>RuntimeException和非RuntimeException区别<br>什么叫线程安全, 保证线程安全的方法<br>加锁的方式, synchronized作用在方法上和代码块区别<br>synchronized(this)和synchronized(Xx.class)区别<h4 id="Web方面"><a href="#Web方面" class="headerlink" title="Web方面:"></a>Web方面:</h4>Spring AOP实现原理<br>一个页面, 一个提交按钮, 如何防止重复提交, 我说验证码, 还有其它方式吗?<br>ajax实现跨域请求(前端或者后台实现方法)<br>cookie和session区别<br>forward和redirect区别<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4>你建过索引吗? 建索引的原则<br>索引的类型, 如主键索引<br>查看SQL执行计划<br>有十万条数据, 写SQL语句查询其中某字段较大值的几条数据<br>子查询与关联查询的区别<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4>你用过的JVM命令有哪些<br>如果一个程序发生OOM, 该怎么处理<br>JVM内存模型<br>JDK7与JDK8的JVM内存模型区别<br>回收算法<br>回收器<br>虚拟机client和server的区别<br>对象和引用之间一般用什么连接？句柄池的作用是什么。<h4 id="网络"><a href="#网络" class="headerlink" title="网络:"></a>网络:</h4>HTTP1.0与HTTP1.1区别<br>TCP与UDP区别<h4 id="容器方面"><a href="#容器方面" class="headerlink" title="容器方面"></a>容器方面</h4>介绍线程安全的list（copyonwritelist）<br>线程安全的map，具体是怎么实现的，与Hashtable什么区别。<br>CAS<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4>知道的线程池（ThreadPoolExecutor属于一类，forkjoin知道吗）<br>线程池怎么自己去实现？给你一个Runnable、一个容器怎么实现。<br>AQS中线程等待怎么做的（线程挂起状态怎么做的）？<h4 id="nio、bio"><a href="#nio、bio" class="headerlink" title="nio、bio"></a>nio、bio</h4>阻塞非阻塞的区别？<br>异步和同步的区别？异步是使用的内核级线程还是用户态线程。<br>AIO在Java中应用到了吗？<h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4>redis<br>rabbitMq<br>memcached等的使用场景和设计原理<br>redis:<br>redis部署方式。<br>redis怎么加入节点<br>redis持久化。<h3 id="百度二面面试题目"><a href="#百度二面面试题目" class="headerlink" title="百度二面面试题目"></a>百度二面面试题目</h3></li>
</ul>
<p>1.手撕字符串转int</p>
<p>2.数据库事务隔离级别</p>
<p>3.spring 事务</p>
<p>4.数据库索引失效的场景</p>
<p>5.组合索引（A,B）若查询B列是否用到了索引</p>
<p>6.如果A是string类型，而查询的时候是1314151617 用到了索引吗？能查到这条数据吗？</p>
<p>7.数据库怎么实现乐观锁？</p>
<p>8.redis pipeline了解吗？</p>
<p>9.秒杀场景？怎么实现。redis怎么限流，限流算法。</p>
<p>10.redis实现队列、实现优先级队列。</p>
<p>11.分布式锁。</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里p7笔试116题</title>
    <url>/2019/11/06/md/interview/ali-p7/</url>
    <content><![CDATA[<p><strong>阿里p7笔试116题</strong></p>
<ol>
<li><p>junit用法，before,beforeClass,after, afterClass的执行顺序</p>
</li>
<li><p>分布式锁</p>
</li>
<li><p>nginx的请求转发算法，如何配置根据权重转发</p>
</li>
<li><p>用hashmap实现redis有什么问题（死锁，死循环，可用ConcurrentHashmap）</p>
</li>
<li><p>线程的状态</p>
</li>
<li><p>线程的阻塞的方式</p>
</li>
<li><p>sleep和wait的区别</p>
</li>
<li><p>hashmap的底层实现</p>
</li>
<li><p>一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁</p>
</li>
<li><p>java内存模型，垃圾回收机制，不可达算法</p>
</li>
<li><p>两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化</p>
</li>
<li><p>aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理</p>
</li>
<li><p>是否用过maven install。 maven test。git（make install是安装本地jar包）</p>
</li>
<li><p>tomcat的各种配置，如何配置docBase</p>
</li>
<li><p>spring的bean配置的几种方式</p>
</li>
<li><p>web.xml的配置</p>
</li>
<li><p>spring的监听器。</p>
</li>
<li><p>zookeeper的实现机制，有缓存，如何存储注册服务的</p>
</li>
<li><p>IO会阻塞吗？readLine是不是阻塞的</p>
</li>
<li><p>用过spring的线程池还是java的线程池？</p>
</li>
<li><p>字符串的格式化方法 （20，21这两个问题问的太低级了）</p>
</li>
<li><p>时间的格式化方法</p>
</li>
<li><p>定时器用什么做的</p>
</li>
<li><p>线程如何退出结束</p>
</li>
<li><p>java有哪些锁？乐观锁 悲观锁 synchronized 可重入锁 读写锁,用过reentrantlock吗？reentrantlock与synmchronized的区别</p>
</li>
<li><p>ThreadLocal的使用场景</p>
</li>
<li><p>java的内存模型，垃圾回收机制</p>
</li>
<li><p>为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）</p>
</li>
<li><p>qmq消息的实现机制(qmq是去哪儿网自己封装的消息队列)</p>
</li>
<li><p>遍历hashmap的三种方式</p>
</li>
<li><p>jvm的一些命令</p>
</li>
<li><p>memcache和redis的区别</p>
</li>
<li><p>mysql的行级锁加在哪个位置</p>
</li>
<li><p>ConcurrentHashmap的锁是如何加的？是不是分段越多越好</p>
</li>
<li><p>myisam和innodb的区别（innodb是行级锁，myisam是表级锁）</p>
</li>
<li><p>mysql其他的性能优化方式</p>
</li>
<li><p>linux系统日志在哪里看</p>
</li>
<li><p>如何查看网络进程</p>
</li>
<li><p>统计一个整数的二进制表示中bit为1的个数</p>
</li>
<li><p>jvm内存模型，java内存模型</p>
</li>
<li><p>如何把java内存的数据全部dump出来</p>
</li>
<li><p>如何手动触发全量回收垃圾，如何立即触发垃圾回收</p>
</li>
<li><p>hashmap如果只有一个写其他全读会出什么问题</p>
</li>
<li><p>git rebase</p>
</li>
<li><p>mongodb和hbase的区别</p>
</li>
<li><p>如何解决并发问题</p>
</li>
<li><p>volatile的用途</p>
</li>
<li><p>java线程池（好像之前我的理解有问题）</p>
</li>
<li><p>mysql的binlog</p>
</li>
<li><p>代理模式</p>
</li>
<li><p>mysql是如何实现事务的</p>
</li>
<li><p>读写分离何时强制要读主库，读哪个从库是通过什么方式决定的，从库的同步mysql用的什么方式</p>
</li>
<li><p>mysql的存储引擎</p>
</li>
<li><p>mysql的默认隔离级别，其他隔离级别</p>
</li>
<li><p>将一个链表反转（用三个指针，但是每次只发转一个）</p>
</li>
<li><p>spring Aop的实现原理，具体说说</p>
</li>
<li><p>何时会内存泄漏，内存泄漏会抛哪些异常</p>
</li>
<li><p>是否用过Autowire注解</p>
</li>
<li><p>spring的注入bean的方式</p>
</li>
<li><p>sql语句各种条件的执行顺序，如select， where， order by， group by</p>
</li>
<li><p>select xx from xx where xx and xx order by xx limit xx； 如何优化这个（看explain）</p>
</li>
<li><p>四则元算写代码</p>
</li>
<li><p>统计100G的ip文件中出现ip次数最多的100个ip</p>
</li>
<li><p>zookeeper的事物，结点，服务提供方挂了如何告知消费方</p>
</li>
<li><p>5台服务器如何选出leader(选举算法)</p>
</li>
<li><p>适配器和代理模式的区别</p>
</li>
<li><p>读写锁</p>
</li>
<li><p>static加锁</p>
</li>
<li><p>事务隔离级别</p>
</li>
<li><p>门面模式，类图(外观模式)</p>
</li>
<li><p>mybatis如何映射表结构</p>
</li>
<li><p>二叉树遍历</p>
</li>
<li><p>主从复制</p>
</li>
<li><p>mysql引擎区别</p>
</li>
<li><p>静态内部类加载到了哪个区？方法区</p>
</li>
<li><p>class文件编译后加载到了哪</p>
</li>
<li><p>web的http请求如何整体响应时间变长导致处理的请求数变少，该如何处理？用队列，当处理不了那么多http请求时将请求放到队列</p>
</li>
</ol>
<p>中慢慢处理，web如何实现队列</p>
<ol start="77">
<li><p>线程安全的单例模式</p>
</li>
<li><p>快速排序性能考虑</p>
</li>
<li><p>volatile关键字用法</p>
</li>
<li><p>求表的size，或做数据统计可用什么存储引擎</p>
</li>
<li><p>读多写少可用什么引擎</p>
</li>
<li><p>假如要统计多个表应该用什么引擎</p>
</li>
<li><p>concurrenhashmap求size是如何加锁的，如果刚求完一段后这段发生了变化该如何处理</p>
</li>
<li><p>1000个苹果放10个篮子，怎么放，能让我拿到所有可能的个数</p>
</li>
<li><p>可重入的读写锁，可重入是如何实现的？</p>
</li>
<li><p>是否用过NIO</p>
</li>
<li><p>java的concurrent包用过没</p>
</li>
<li><p>sting s=new string(“abc”)分别在堆栈上新建了哪些对象</p>
</li>
<li><p>java虚拟机的区域分配，各区分别存什么</p>
</li>
<li><p>分布式事务（JTA）</p>
</li>
<li><p>threadlocal使用时注意的问题（ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享）</p>
</li>
<li><p>java有哪些容器(集合，tomcat也是一种容器)</p>
</li>
<li><p>二分查找算法</p>
</li>
<li><p>myisam的优点，和innodb的区别</p>
</li>
<li><p>redis能存哪些类型</p>
</li>
<li><p>http协议格式，get和post的区别</p>
</li>
<li><p>可重入锁中对应的wait和notify</p>
</li>
<li><p>redis能把内存空间交换进磁盘中吗(这个应该是可以的，但是那个面试官非跟我说不可以)</p>
</li>
<li><p>java线程池中基于缓存和基于定长的两种线程池，当请求太多时分别是如何处理的？定长的事用的队列，如果队列也满了呢？交换进磁盘？基于缓存的线程池解决方法呢？</p>
</li>
<li><p>synchronized加在方法上用的什么锁</p>
</li>
<li><p>可重入锁中的lock和trylock的区别</p>
</li>
<li><p>innodb对一行数据的读会枷锁吗？不枷锁，读实际读的是副本</p>
</li>
<li><p>redis做缓存是分布式存的？不同的服务器上存的数据是否重复？guava cache呢？是否重复？不同的机器存的数据不同</p>
</li>
<li><p>用awk统计一个ip文件中top10</p>
</li>
<li><p>对表做统计时可直接看schema info信息，即查看表的系统信息</p>
</li>
<li><p>mysql目前用的版本</p>
</li>
<li><p>公司经验丰富的人给了什么帮助？(一般boss面会问这些)</p>
</li>
<li><p>自己相对于一样的应届生有什么优势</p>
</li>
<li><p>自己的好的总结习惯给自己今后的工作带了什么帮助，举例为证</p>
</li>
<li><p>原子类，线程安全的对象，异常的处理方式</p>
</li>
<li><p>4亿个int数，如何找出重复的数（用hash方法，建一个2的32次方个bit的hash数组，每取一个int数，可hash下2的32次方找到它在hash数组中的位置，然后将bit置1表示已存在）</p>
</li>
<li><p>4亿个url，找出其中重复的（考虑内存不够，通过hash算法，将url分配到1000个文件中，不同的文件间肯定就不会重复了，再分别找出重复的）</p>
</li>
</ol>
<p>有1万个数组，每个数组有1000个整数，每个数组都是降序的，从中找出最大的N个数，N&lt;1000</p>
<ol start="113">
<li><p>LinkedHashmap的底层实现</p>
</li>
<li><p>类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？</p>
</li>
<li><p>Override和Overload的区别，分别用在什么场景</p>
</li>
<li><p>java的反射是如何实现的</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>蚂蚁金服的一次面试经历分享</title>
    <url>/2019/11/06/md/interview/ali-ant-interview/</url>
    <content><![CDATA[<p><strong>一次有把握的面试，需要经过长时间的准备！</strong></p>
<h3 id="电话一面"><a href="#电话一面" class="headerlink" title="电话一面"></a>电话一面</h3><p>1、自我介绍、自己做的项目和技术领域</p>
<p>2、项目中的监控：那个监控指标常见的有哪些？</p>
<p>3、微服务涉及到的技术以及需要注意的问题有哪些？</p>
<p>4、注册中心你了解了哪些？</p>
<p>5、consul 的可靠性你了解吗？</p>
<p>6、consul 的机制你有没有具体深入过？有没有和其他的注册中心对比过？</p>
<p>7、项目用 Spring 比较多，有没有了解 Spring 的原理？AOP 和 IOC 的原理</p>
<p>8、Spring Boot除了自动配置，相比传统的 Spring 有什么其他的区别？</p>
<p>9、Spring Cloud 有了解多少？</p>
<p>10、Spring Bean 的生命周期</p>
<p>11、HashMap 和 hashTable 区别？</p>
<p>12、Object 的 hashcode 方法重写了，equals 方法要不要改？</p>
<p>13、Hashmap 线程不安全的出现场景</p>
<p>14、线上服务 CPU 很高该怎么做？有哪些措施可以找到问题</p>
<p>15、JDK 中有哪几个线程池？顺带把线程池讲了个遍</p>
<p>16、SQL 优化的常见方法有哪些</p>
<p>17、SQL 索引的顺序，字段的顺序</p>
<p>18、查看 SQL 是不是使用了索引？（有什么工具）</p>
<p>19、TCP 和 UDP 的区别？TCP 数据传输过程中怎么做到可靠的？</p>
<p>20、说下你知道的排序算法吧</p>
<p>21、查找一个数组的中位数？</p>
<p>22、你有什么问题想问我的吗？</p>
<h3 id="电话二面（85-分钟）"><a href="#电话二面（85-分钟）" class="headerlink" title="电话二面（85 分钟）"></a>电话二面（85 分钟）</h3><p>1、自我介绍、工作经历、技术栈</p>
<p>2、项目中你学到了什么技术？（把三项目具体描述了很久）</p>
<p>3、微服务划分的粒度</p>
<p>4、微服务的高可用怎么保证的？</p>
<p>5、常用的负载均衡，该怎么用，你能说下吗？</p>
<p>6、网关能够为后端服务带来哪些好处？</p>
<p>7、Spring Bean 的生命周期</p>
<p>8、xml 中配置的 init、destroy 方法怎么可以做到调用具体的方法？</p>
<p>9、反射的机制</p>
<p>10、Object 类中的方法</p>
<p>11、hashcode 和 equals 方法常用地方</p>
<p>12、对象比较是否相同</p>
<p>13、hashmap put 方法存放的时候怎么判断是否是重复的</p>
<p>14、Object toString 方法常用的地方，为什么要重写该方法</p>
<p>15、Set 和 List 区别？</p>
<p>16、ArrayList 和 LinkedList 区别</p>
<p>17、如果存取相同的数据，ArrayList 和 LinkedList 谁占用空间更大？</p>
<p>18、Set 存的顺序是有序的吗？</p>
<p>19、常见 Set 的实现有哪些？</p>
<p>20、TreeSet 对存入对数据有什么要求呢？</p>
<p>21、HashSet 的底层实现呢</p>
<p>22、TreeSet 底层源码有看过吗？</p>
<p>23、HashSet 是不是线程安全的？为什么不是线程安全的？</p>
<p>24、Java 中有哪些线程安全的 Map？</p>
<p>25、Concurrenthashmap 是怎么做到线程安全的？</p>
<p>26、HashTable 你了解过吗？</p>
<p>27、如何保证线程安全问题？</p>
<p>28、synchronized、lock</p>
<p>29、volatile 的原子性问题？为什么 i++ 这种不支持原子性？从计算机原理的设计来讲下不能保证原子性的原因</p>
<p>30、happens before 原理</p>
<p>31、cas 操作</p>
<p>32、lock 和 synchronized 的区别？</p>
<p>33、公平锁和非公平锁</p>
<p>34、Java 读写锁</p>
<p>35、读写锁设计主要解决什么问题？</p>
<p>36、你项目除了写 Java 代码，还有前端代码，那你知道前端有哪些框架吗？</p>
<p>37、MySQL 分页查询语句</p>
<p>38、MySQL 事务特性和隔离级别</p>
<p>39、不可重复读会出现在什么场景？</p>
<p>40、sql having 的使用场景</p>
<p>41、前端浏览器地址的一个 http 请求到后端整个流程是怎么样？能够说下吗？</p>
<p>42、http 默认端口，https 默认端口</p>
<p>43、DNS 你知道是干嘛的吗？</p>
<p>44、你们开发用的 ide 是啥？你能说下 idea 的常用几个快捷键吧？</p>
<p>45、代码版本管理你们用的是啥？</p>
<p>46、git rebase 和 merge 有什么区别？</p>
<p>47、你们公司加班多吗？</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>你还有什么问题要问我吗</title>
    <url>/2019/11/06/md/interview/ask/</url>
    <content><![CDATA[<p>整个面试过程中跟面试官聊得特别嗨</p>
<p>面试结束前的最后一个问题，“你还有什么问题问我吗？”</p>
<p>“没有。”</p>
<p>结果就bye了,不再见啦…………</p>
<p>巧解面试最后一问：“你还有什么问题要问我吗？”</p>
<p>面试达人</p>
<p>####考察目的</p>
<ul>
<li><p>面试官让你提问，是在考察你的情商，你是否知道面对什么人要问什么问题？</p>
</li>
<li><p>对这个公司或者行业、岗位了解程度。要问出一个好问题，背后需要做很多的准备工作，要对这个行业有足够深入的了解，才能问出“洞见”。</p>
</li>
</ul>
<h4 id="回答思路："><a href="#回答思路：" class="headerlink" title="回答思路："></a>回答思路：</h4><ul>
<li>要问好问题，一个问题要好，它需要符合以下三个要求：不是难题可以回答，对象合适，双方互动。</li>
</ul>
<blockquote>
<p>向面试官提问不是一场角力，不是在比拼谁的智商更高。而是一次交流，希望通过问与答来达到一个最好的面试结束效果。</p>
</blockquote>
<h5 id="向对的人问对的问题。"><a href="#向对的人问对的问题。" class="headerlink" title="向对的人问对的问题。"></a>向对的人问对的问题。</h5><ul>
<li>HR</li>
</ul>
<p>HR最擅长并且最关心的问题肯定是公司的架构，文化，价值观，岗位设置等问题。</p>
<p>所以当你向HR提问的时候，最好是关于岗位情况：</p>
<p>例如:这个岗位为什么会开放出来？这个部门的人员设置是怎样的，我应该向谁汇报，有多少个子部门？</p>
<ul>
<li>部门经理</li>
</ul>
<p>部门经理很可能是你以后的直属上司，他最擅长和最关心的是工作内容。</p>
<p>你的问题应该紧扣这个意向岗位的工作内容，问题可以涉及：</p>
<p>这份工作最大的挑战是什么？</p>
<p>你觉得能胜任这份工作的人最关键的能力是什么？</p>
<p>你现在最急需你的下属帮你解决的困难是？</p>
<ul>
<li>大Boss</li>
</ul>
<p>当你通过HR面，部门经理面，证明你和岗位、公司文化、薪酬比较匹配了。大Boss在终面的时不会再着重考察你的能力，更多地是想和你讨论对于整个行业的问题。</p>
<p>所以你问的问题应该紧扣这个行业的态势，例如：</p>
<p>你对这个行业未来的发展持什么态度？</p>
<p>贵公司与xxx竞争对手在未来的发展策略上会有什么不同？</p>
<h5 id="你问问题不是为了问而问，而是为了互动而问。"><a href="#你问问题不是为了问而问，而是为了互动而问。" class="headerlink" title="你问问题不是为了问而问，而是为了互动而问。"></a>你问问题不是为了问而问，而是为了互动而问。</h5><p>即你问得问题其实自己心目中也要有一个答案，以便在面试官回答完以后你再表达一下自己的见解，然后和面试官讨论。</p>
<h4 id="提问的雷区："><a href="#提问的雷区：" class="headerlink" title="提问的雷区："></a>提问的雷区：</h4><p>提问环节中假如表现不好，就很有可能给面试官留下坏印象，因为人的记忆最容易记得的是开头和结尾。所以提问环节假如你表现糟糕，那么面试官印象就会特别深刻，比中间环节的面试题目更加深刻，那么你就很有可能因为这个问题就被翻盘，所以有些雷区一定不要踩。</p>
<ul>
<li>不要问薪资</li>
</ul>
<p>薪资永远不要自己提出来，要等面试官问你了才去讨论。 假如你主动问，这会是很不礼貌的一个举动。面试直接pass</p>
<p>而且在大公司，决定你薪资的不是部门经理，不是大boss，而是一面的HR，但是一面一般都不会问你薪资要求，所以一般是终面以后，公司决定应聘你了才开始谈薪资的。试想一下，假如对你都不满意，那么快谈薪资有什么用？</p>
<ul>
<li>不要问隐私问题</li>
</ul>
<p>面试是职场中很正规的一件事，不是私人交流，所以不要问面试官比较隐私的问题以免引起尴尬。</p>
<ul>
<li>不要问让人误会你的问题</li>
</ul>
<p>有些问题问出来以后会让别人质疑你的求职动机，这些敏感问题尽量不要问。</p>
<p>例：贵公司加班多吗？面试官会马上认为你不是一个努力工作的人。</p>
<ul>
<li>没有价值的问题</li>
</ul>
<p>这么重要的一个环节，你就不要拿来去问一些无关紧要的，平常都能解答的问题。</p>
<ul>
<li>问的问题不要超过三个</li>
</ul>
<p>两个是最合适的，三个就让面试官觉得你啰嗦了。</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>做好这10点让你越来越自律</title>
    <url>/2019/11/06/md/life/best-practice/make-autonomy/</url>
    <content><![CDATA[<p>1,关闭朋友圈,卸载所有游戏<br>2,蹲马桶不要超过5分钟<br>3,手机响5秒再接<br>4,想发火先忍耐10秒钟<br>5,每天锻炼30分钟以上<br>6,坚决不带手机上床<br>7,睡前泡脚20分钟<br>8,睡前阅读半个小时<br>9,每天都有总结的好习惯<br>10,趁年轻,一定要尽早提高自控力,这会改变你的一年</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>一些值得长期坚持下去的好习惯！</title>
    <url>/2019/11/06/md/life/best-practice/well-habbit/</url>
    <content><![CDATA[<p>1、早起空腹一杯温水，雷打不动。每天晚上用快壶烧一壶开水，倒在水杯里晾凉，第二天早起再烧开水，兑在凉水里面，直接就可以喝一大杯。<br>2、每天解决一个实在忍受不了的问题。比如更换昏暗的灯泡，比如专门治疗拖延症，慢慢的生活就会变成你想要的样子。<br>3、坚持锻炼身体。瑜伽、跑步、哑铃等，不到万不得已，不要间断。<br>4、坚持腹式呼吸。开会可以练，坐车可以练，随时随地练。你呼吸的长度就是你生命的长度。<br>5、坚持睡前泡脚。一年四季，泡脚都很舒服，可以让人很放松。<br>6、再晚再累也要护肤，男女都一样。护肤是一项你付出多少就会得到多少回报的事情，不要偷懒。<br>7、勤换洗衣服。健康的身体，就应该搭配干净衣服，保持身体内外洁净。<br>8、认真刷牙，最好买电动牙刷，并不是电动牙刷比普通牙刷刷的干净，而是因为电动牙刷有时间限制，不会偷工减料。<br>9、睡觉前一个小时看书。学习需要静心，知识需要源源不断的汲取，每天进步一点点就好。<br>10、睡前转动眼球，可以有效地放松眼部肌肉，缓解眼睛干涩酸胀，坚持下来会让眼睛更有神。而且眼睛放松了，人体就放松了三分之二，睡觉很香。<br>11、保持床单、枕巾清洁，既可以减少皮肤问题。<br>12、勤晒被子，勤通风，阳光的味道会让人幸福感爆棚。<br>13、洗头发，不要相信头发越洗越爱出油，一天下来头发吸收很多灰尘，洗干净了才会对头皮健康有益。<br>14、多吃水果，番茄、猕猴桃等富含维生素C的水果，真的会变白。而且多吃水果真的可以预防和治疗口腔溃疡。<br>15、早起拉伸，睡前拉伸，坐办公室久了要起来拉伸一下，尤其对人的体态非常友好！<br>16、坚持写日记，写下自己的所有心事，肆无忌惮，想写啥写啥，和自己对话，慢慢会人变得更了解自己，更平和，也可以防止自己和别人抱怨。<br>17、多给家里人打电话，你不知道你的电话会让父母有多开心。而且每天给家里打电话，会让自己不孤单，被爱包围。得到足够的爱，可以让我更自信，也更有能力爱别人。<br>18、学会放下，原谅自己。谁都难免会为自己的行为后悔，不要揪着不放，原谅自己，让自己轻松一点。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2019/11/05/md/develop/base/pattern/iterator/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p><strong>主要解决</strong>：不同的方式来遍历整个整合对象。</p>
<p><strong>何时使用</strong>：遍历一个聚合对象。</p>
<p><strong>如何解决</strong>：把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p><strong>关键代码</strong>：定义接口：hasNext, next。</p>
<p><strong>应用实例</strong>：JAVA 中的 iterator。</p>
<p><strong>优点</strong>： </p>
<ul>
<li>它支持以不同的方式遍历一个聚合对象。 </li>
<li>迭代器简化了聚合类。 </li>
<li>在同一个聚合上可以有多个遍历。 </li>
<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
</ul>
<p><strong>缺点</strong>：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p><strong>使用场景</strong>： </p>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。 </li>
<li>需要为聚合对象提供多种遍历方式。 </li>
<li>为遍历不同的聚合结构提供一个统一的接口。</li>
</ul>
<p><strong>注意事项</strong>：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<p>实现<br>我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。</p>
<p>IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。</p>
<p>迭代器模式的 UML 图<br>步骤 1<br>创建接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h4><p>创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameRepository</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> String names[] = &#123;<span class="string">"Robert"</span> , <span class="string">"John"</span> ,<span class="string">"Julie"</span> , <span class="string">"Lora"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> NameIterator();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">int</span> index;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">if</span>(index &lt; names.length)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> names[index++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;     </span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h4><p>使用 NameRepository 来获取迭代器，并打印名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPatternDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      NameRepository namesRepository = <span class="keyword">new</span> NameRepository();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         String name = (String)iter.next();</span></pre></td></tr><tr><td class="code"><pre><span class="line">         System.out.println(<span class="string">"Name : "</span> + name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h4><p>执行程序，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name : Robert</span></pre></td></tr><tr><td class="code"><pre><span class="line">Name : John</span></pre></td></tr><tr><td class="code"><pre><span class="line">Name : Julie</span></pre></td></tr><tr><td class="code"><pre><span class="line">Name : Lora</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2019/11/05/md/develop/base/pattern/template/</url>
    <content><![CDATA[<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>主要解决</strong>：一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p><strong>何时使用</strong>：有一些通用的方法。</p>
<p><strong>如何解决</strong>：将这些通用算法抽象出来。</p>
<p><strong>关键代码</strong>：在抽象类实现，其他步骤在子类实现。</p>
<p><strong>应用实例</strong>： </p>
<ul>
<li>在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 </li>
<li>西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 </li>
<li>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li>
</ul>
<p><strong>优点</strong>： </p>
<ul>
<li>封装不变部分，扩展可变部分。 </li>
<li>提取公共代码，便于维护。 </li>
<li>行为由父类控制，子类实现。</li>
</ul>
<p><strong>缺点</strong>：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<p><strong>使用场景</strong>： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p>
<p><strong>注意事项</strong>：为防止恶意操作，一般模板方法都加上 final 关键词</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。</p>
<p>TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h4><p>创建一个抽象类，它的模板方法被设置为 final。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//初始化游戏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      initialize();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//开始游戏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      startPlay();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//结束游戏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      endPlay();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h4><p>创建扩展了上述类的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Cricket Game Finished!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Cricket Game Initialized! Start playing."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Cricket Game Started. Enjoy the game!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Football Game Finished!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Football Game Initialized! Start playing."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Football Game Started. Enjoy the game!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h4><p>使用 Game 的模板方法 play() 来演示游戏的定义方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      Game game = <span class="keyword">new</span> Cricket();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      game.play();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      game = <span class="keyword">new</span> Football();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      game.play();      </span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h4><p>执行程序，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cricket Game Initialized! Start playing.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cricket Game Started. Enjoy the game!</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cricket Game Finished!</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Football Game Initialized! Start playing.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Football Game Started. Enjoy the game!</span></pre></td></tr><tr><td class="code"><pre><span class="line">Football Game Finished!</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2019/11/05/md/develop/base/pattern/decorator/</url>
    <content><![CDATA[<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p><strong>主要解决</strong>：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p><strong>何时使用</strong>：在不想增加很多子类的情况下扩展类。</p>
<p><strong>如何解决</strong>：将具体功能职责划分，同时继承装饰者模式。</p>
<p><strong>关键代码</strong>： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p>
<p><strong>应用实例</strong>： </p>
<ul>
<li>孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 </li>
<li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</li>
</ul>
<p><strong>优点</strong>：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p><strong>缺点</strong>：多层装饰比较复杂。</p>
<p><strong>使用场景</strong>： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<blockquote>
<p>注意事项：可代替继承。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。</p>
<p>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。</p>
<p>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<p>装饰器模式的 UML 图</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h4><p>创建一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h4><p>创建实现接口的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Shape: Rectangle"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Shape: Circle"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h4><p>创建实现了 Shape 接口的抽象装饰类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">protected</span> Shape decoratedShape;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">this</span>.decoratedShape = decoratedShape;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      decoratedShape.draw();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h4><p>创建扩展了 ShapeDecorator 类的实体装饰类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">super</span>(decoratedShape);     </span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      decoratedShape.draw();         </span></pre></td></tr><tr><td class="code"><pre><span class="line">      setRedBorder(decoratedShape);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Border Color: Red"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h4><p>使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPatternDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      Shape circle = <span class="keyword">new</span> Circle();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ShapeDecorator redCircle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ShapeDecorator redRectangle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Rectangle());</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//Shape redCircle = new RedShapeDecorator(new Circle());</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//Shape redRectangle = new RedShapeDecorator(new Rectangle());</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Circle with normal border"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      circle.draw();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Circle of red border"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      redCircle.draw();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Rectangle of red border"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      redRectangle.draw();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h4><p>执行程序，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Circle with normal border</span></pre></td></tr><tr><td class="code"><pre><span class="line">Shape: Circle</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Circle of red border</span></pre></td></tr><tr><td class="code"><pre><span class="line">Shape: Circle</span></pre></td></tr><tr><td class="code"><pre><span class="line">Border Color: Red</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Rectangle of red border</span></pre></td></tr><tr><td class="code"><pre><span class="line">Shape: Rectangle</span></pre></td></tr><tr><td class="code"><pre><span class="line">Border Color: Red</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2019/11/05/md/develop/base/pattern/chain-of-responsibility/</url>
    <content><![CDATA[<p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p><strong>主要解决</strong>：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p><strong>何时使用</strong>：在处理消息的时候以过滤很多道。</p>
<p><strong>如何解决</strong>：拦截的类都实现统一接口。</p>
<p><strong>关键代码</strong>：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
<p><strong>应用实例</strong>： </p>
<ul>
<li>红楼梦中的”击鼓传花”。 </li>
<li>JS 中的事件冒泡。</li>
<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</li>
</ul>
<p><strong>优点</strong>： </p>
<ul>
<li>降低耦合度。它将请求的发送者和接收者解耦。 </li>
<li>简化了对象。使得对象不需要知道链的结构。 </li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 </li>
<li>增加新的请求处理类很方便。</li>
</ul>
<p><strong>缺点</strong>： </p>
<ul>
<li>不能保证请求一定被接收。 </li>
<li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 </li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ul>
<p><strong>使用场景</strong>： </p>
<ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 </li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 </li>
<li>可动态指定一组对象处理请求。</li>
</ul>
<p><strong>注意事项</strong>：在 JAVA WEB 中遇到很多应用。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h4><p>创建抽象的记录器类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">protected</span> <span class="keyword">int</span> level;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//责任链中的下一个元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">protected</span> AbstractLogger nextLogger;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">this</span>.nextLogger = nextLogger;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         write(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         nextLogger.logMessage(level, message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h4><p>创建扩展了该记录器类的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">this</span>.level = level;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Standard Console::Logger: "</span> + message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">this</span>.level = level;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">this</span>.level = level;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"File::Logger: "</span> + message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h4><p>创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      errorLogger.setNextLogger(fileLogger);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      fileLogger.setNextLogger(consoleLogger);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> errorLogger;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      AbstractLogger loggerChain = getChainOfLoggers();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      loggerChain.logMessage(AbstractLogger.INFO, <span class="string">"This is an information."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, <span class="string">"This is a debug level information."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      loggerChain.logMessage(AbstractLogger.ERROR, <span class="string">"This is an error information."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h4><p>执行程序，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Standard Console::Logger: This is an information.</span></pre></td></tr><tr><td class="code"><pre><span class="line">File::Logger: This is a debug level information.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Standard Console::Logger: This is a debug level information.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Error Console::Logger: This is an error information.</span></pre></td></tr><tr><td class="code"><pre><span class="line">File::Logger: This is an error information.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Standard Console::Logger: This is an error information.</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2019/11/05/md/develop/base/pattern/adaptor/</url>
    <content><![CDATA[<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p>
<p>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图</strong>：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>主要解决</strong>：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p><strong>何时使用</strong>： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p>
<p><strong>如何解决</strong>：继承或依赖（推荐）。</p>
<p><strong>关键代码</strong>：适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<p><strong>应用实例</strong>： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p>
<p><strong>优点</strong>： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p>
<p><strong>缺点</strong>： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p>
<p><strong>使用场景</strong>：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<p><strong>注意事项</strong>：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<p>分享一个例子：笔记本通过读卡去读取TF卡；</p>
<h3 id="一、先模拟计算机读取SD卡："><a href="#一、先模拟计算机读取SD卡：" class="headerlink" title="一、先模拟计算机读取SD卡："></a>一、先模拟计算机读取SD卡：</h3><h4 id="1、先创建一个SD卡的接口："><a href="#1、先创建一个SD卡的接口：" class="headerlink" title="1、先创建一个SD卡的接口："></a>1、先创建一个SD卡的接口：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SDCard</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//读取SD卡方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">String <span class="title">readSD</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//写入SD卡功能</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeSD</span><span class="params">(String msg)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="2、创建SD卡接口的实现类，模拟SD卡的功能："><a href="#2、创建SD卡接口的实现类，模拟SD卡的功能：" class="headerlink" title="2、创建SD卡接口的实现类，模拟SD卡的功能："></a>2、创建SD卡接口的实现类，模拟SD卡的功能：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span>    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String msg = <span class="string">"sdcard read a msg :hello word SD"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> msg;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span>  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;      </span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"sd card write msg : "</span> + msg);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="3、创建计算机接口，计算机提供读取SD卡方法："><a href="#3、创建计算机接口，计算机提供读取SD卡方法：" class="headerlink" title="3、创建计算机接口，计算机提供读取SD卡方法："></a>3、创建计算机接口，计算机提供读取SD卡方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="4、创建一个计算机实例，实现计算机接口，并实现其读取SD卡方法："><a href="#4、创建一个计算机实例，实现计算机接口，并实现其读取SD卡方法：" class="headerlink" title="4、创建一个计算机实例，实现计算机接口，并实现其读取SD卡方法："></a>4、创建一个计算机实例，实现计算机接口，并实现其读取SD卡方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThinkpadComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span>    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span> </span>&#123;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(sdCard == <span class="keyword">null</span>)<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"sd card null"</span>);        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sdCard.readSD();    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="5、这时候就可以模拟计算机读取SD卡功能："><a href="#5、这时候就可以模拟计算机读取SD卡功能：" class="headerlink" title="5、这时候就可以模拟计算机读取SD卡功能："></a>5、这时候就可以模拟计算机读取SD卡功能：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerReadDemo</span> </span>&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        Computer computer = <span class="keyword">new</span> ThinkpadComputer();        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        SDCard sdCard = <span class="keyword">new</span> SDCardImpl();       </span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(computer.readSD(sdCard));    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="二、接下来在不改变计算机读取SD卡接口的情况下，通过适配器模式读取TF卡："><a href="#二、接下来在不改变计算机读取SD卡接口的情况下，通过适配器模式读取TF卡：" class="headerlink" title="二、接下来在不改变计算机读取SD卡接口的情况下，通过适配器模式读取TF卡："></a>二、接下来在不改变计算机读取SD卡接口的情况下，通过适配器模式读取TF卡：</h3><h4 id="1、创建TF卡接口："><a href="#1、创建TF卡接口：" class="headerlink" title="1、创建TF卡接口："></a>1、创建TF卡接口：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TFCard</span> </span>&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">String <span class="title">readTF</span><span class="params">()</span></span>;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeTF</span><span class="params">(String msg)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="2、创建TF卡实例："><a href="#2、创建TF卡实例：" class="headerlink" title="2、创建TF卡实例："></a>2、创建TF卡实例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">TFCard</span> </span>&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span>    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readTF</span><span class="params">()</span> </span>&#123;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        String msg =<span class="string">"tf card reade msg : hello word tf card"</span>;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> msg;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span>    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeTF</span><span class="params">(String msg)</span> </span>&#123;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"tf card write a msg : "</span> + msg);        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="3、创建SD适配TF-（也可以说是SD兼容TF，相当于读卡器）："><a href="#3、创建SD适配TF-（也可以说是SD兼容TF，相当于读卡器）：" class="headerlink" title="3、创建SD适配TF （也可以说是SD兼容TF，相当于读卡器）："></a>3、创建SD适配TF （也可以说是SD兼容TF，相当于读卡器）：</h4><p>实现SDCard接口，并将要适配的对象作为适配器的属性引入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> TFCard tfCard;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> </span>&#123;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.tfCard = tfCard;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span>    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"adapter read tf card "</span>);        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> tfCard.readTF();    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span>    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"adapter write tf card"</span>);        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> tfCard.writeTF(msg);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="4、通过上面的例子测试计算机通过SD读卡器读取TF卡："><a href="#4、通过上面的例子测试计算机通过SD读卡器读取TF卡：" class="headerlink" title="4、通过上面的例子测试计算机通过SD读卡器读取TF卡："></a>4、通过上面的例子测试计算机通过SD读卡器读取TF卡：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerReadDemo</span> </span>&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        Computer computer = <span class="keyword">new</span> ThinkpadComputer();        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        SDCard sdCard = <span class="keyword">new</span> SDCardImpl();        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(computer.readSD(sdCard));        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"===================================="</span>);        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        TFCard tfCard = <span class="keyword">new</span> TFCardImpl();        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        SDCard tfCardAdapterSD = <span class="keyword">new</span> SDAdapterTF(tfCard);        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(computer.readSD(tfCardAdapterSD));    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">输出：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">sdcard read a msg :hello word SD</span></pre></td></tr><tr><td class="code"><pre><span class="line">====================================</span></pre></td></tr><tr><td class="code"><pre><span class="line">adapter read tf card </span></pre></td></tr><tr><td class="code"><pre><span class="line">tf card reade msg : hello word tf card</span></pre></td></tr></table></figure>
<p>在这种模式下，计算机并不需要知道具体是什么卡，只需要负责操作接口即可，具体操作的什么类，由适配器决定。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>学习方法</title>
    <url>/2019/11/05/md/develop/it-learn-method/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>一直想谈谈学习方法的一些东西，终于耗费了一周时间写完了。本文篇幅较长，如果耐心读完我想一定会对你多少有一定帮助。</p>
<p>个人的知识水平受限，理解一定是具有局限性的。希望我的一些经历可以帮助到大家，也是自我的一次反思和总结。学习是一个不断的过程，若是若干时间后有更多的学习感悟，我也会一直更新。</p>
<p>有不对的地方欢迎留言指正 🙏🏼</p>
<h3 id="一、为什么要讲学习方法"><a href="#一、为什么要讲学习方法" class="headerlink" title="一、为什么要讲学习方法"></a>一、为什么要讲学习方法</h3><p>在学习技术这条路上并不是一帆风顺，也一直在探索一条适合自己的学习方法。从一开始的技术小白，到现在还比较上道的老鸟，在这个过程中走了太多的弯路，想在这里和大家分享一些我的经历和学习方法。</p>
<p>对于立志成为一个技术达人，或者对于技术有执着追求的，学习一定是伴随着终生。所谓的互联网还是国企养老的说法更是根本不存在的，一旦进入所谓的舒适区，很可能下一个末位淘汰的就是你。我不认为从业者过度的关注什么互联网寒冬的说法，应该从提升技术素养出发，找到自己感兴趣的方向。要相信大部分金子都可以发光发热的，当然伯乐很重要。</p>
<p>技术是科学、是工具、更是理论应用于实践的途径。技术学习是无止境的，人的精力也是有限的，我们不应该一味的追求新技术。基础很重要，特别是数据结构与算法、操作系统原理、计算机网络、Linux 基础，这些在如今应用层编码的过程中或许不会被过多的关注，但是计算机的基础决定了你能走多远。从某一个技术点的深度着手，同时不断扩展自己知识的广度。项目需要什么就用什么学什么，业余时间当然可以扩展一下自己感兴趣的技术栈。</p>
<p>在本文想和大家分享一些我的学习方法和经验，希望对大家有所启发。</p>
<h3 id="二、和技术有关的日子"><a href="#二、和技术有关的日子" class="headerlink" title="二、和技术有关的日子"></a>二、和技术有关的日子</h3><h4 id="1-从懵懂到想做技术"><a href="#1-从懵懂到想做技术" class="headerlink" title="1. 从懵懂到想做技术"></a>1. 从懵懂到想做技术</h4><p>从我的个人学习经历说起吧，学习的过程挺曲折的，但是回首过去发现这些经历的都将成为你未来的谈资。从进入大学开始，个人的对于摄像与平面有浓厚的兴趣，也花了整整三年的时间投身于学生工作（主要是平面设计、视频后期、微信公众号运营相关的），一度的规划是希望成为一个设计师或是视频后期工作者。也跟随很多摄制组拍摄过广告、做过平面设计物料、微信公众号媒体运管，我认为一个好的设计一定是给人带来美的享受，对于追求完美主义的我，深深的爱上了这个角色。</p>
<p>与此同时，本科作为软件工程专业出身的我，同时被各种计算机的学科熏陶着，自认为技术掌握的还不错。那个时候对于 Web 特别感兴趣，特别现在的人们打开计算机，大部分时间都是和你的浏览器相处。那个时候开始学习一些 HTML/CSS/JavaScript 相关的一些东西，可以自己做一些简单的静态网页，很快不久就写了一个非常简陋的个人主页。后来，接触了动态网页写过 JSP、ASP.NET、PHP 网页，但是那时候大部分还是前后台混合渲染的方式，开发效率倒是很高但是一旦想要从新设计前端界面，就会陷入重构的泥塘。后来，慢慢接触到了前后台分离的开发方式，知道了 Vue、React 相关的一些 MVVM 框架。</p>
<p>在 2015 年的学生工作中，马上迎来了学代会的换届选举，在过程中发现纸质选票效率低，通常中场投票和检票也耗费大量的时间。我算是一个善于发现问题的人，两天时间泡在图书馆中，搭建了一个学代会投票系统。在后来的投票过程中，我将原来的 30 分钟，缩短到了 5 分钟，并在大屏实时滚动显示投票柱状图。这个投票系统也得到了团委老师的一致认可，在后来的 4 年中一直使用了我的投票系统，并且保持了很好的稳定性和效果。在每一年的系统中，我也不断的升级投票系统，在这几年的升级过程中也记录了自己的成长轨迹。虽然毕业了，但口碑的也在各个学院中流传开了，也正在计划将它升级为一个平台，可以让所有注册到平台上的人都可以使用我的投票平台。</p>
<p>在设计师和技术研发人员的角色选择中，纠结过很长一段时间。会发现，设计师可以设计出很简洁、美观、善心悦目的作品，但是只有技术研发人员才能实实在在的为它赋能，真正的实现一个具有功能性、体验性的东西。他们都是艺术家，都在各自的领域增添异彩。我从来不认为开发的是功能，每一行代码都有它的灵魂，都是我的产品，更是我的尊严。在后来的日子里，我发现这两个角色对于逐渐开始并存，为什么不能够同时应用和学习呢？做设计中最懂技术的，做技术中最懂设计的。</p>
<p>同时在过去三年的学生工作中，也很好的锻炼了我的团队领导能力和技术分享能力。这些软实力，也许和很多的代码能力都无关，但是在后来的项目团队协作和管理中有着潜移默化的帮助。</p>
<h4 id="2-我的成长与技术路线"><a href="#2-我的成长与技术路线" class="headerlink" title="2. 我的成长与技术路线"></a>2. 我的成长与技术路线</h4><p>从大三的暑假到目前的研究生阶段，开始学习前端开发技、跨平台应用、后台开发技术、了解系统架构的一些东西、机器学习算法应用、产品设计思维等等相关的东西。我开始了技术广度的挖掘，很多东西不敢说是精通，但至少一定是入门到进阶的水平，当然目前还在技术深度不断学习的路上。</p>
<p>我很认可一句话，“人人都是产品经理”，“人人都是架构师”。我们不应该为自己打上太多的标签，“我是一个算法工程师”、“我是一个 XX 语言开发工程师”、“我是一个产品经理”。在学习这条路上，我们应该首先抓好自己的本职工作，也就是技术深度的学习(例如：开始学会重构自己的项目代码、开始看项目源码)，从而在工作之余不断的拓展自己技术的广度和思维的广度。这里说一个题外话，谷歌宣扬的 80% 的时间用来工作，20% 的时间用来学习，大名鼎鼎的 Go 语言就是三位科学家利用 20% 时间里创造的。</p>
<p>一个追求用户极致体验的你，为产品而创造的你，未来也可能成为乔布斯一样优秀的产品经理。执着追求技术，那么未来你可能成为某个领域的技术专家或是某个维度的系统架构师。在追求技术的同时，有长远的战略眼光，有可能成为一个技术总监。有广阔胸怀的，赏识人才，能有调理的管理好一批人，有市场洞察力，能将技术变现，那未来离财务自由不远了。</p>
<p>后来的我读研了，由于是专硕，两年的读研时间显的好短暂，才短暂接触了几个月的机器学习算法，都才刚刚入门了 Python 和会使用 Tensorflow 和 Scikit-learn 框架进行一些简单的机器学习分类工作，马上又要着手于校招，让我措手不及。在机器学习算法等相关学科，对于数学功底要求比较高，对于快速就业让我十分的无助。由于之前也写过几年的 PHP 后台开发相关的工作，大概在很长的一段时间内一直在纠结究竟是找机器学习岗位或是后台开发方向。</p>
<p>思考了很久，我对自己未来的规划是希望成为架构师方向，在技术达到一定高度，并有很好的想法的时候会有创业做产品的打算。于是我还是回到了自己的老本行，后台开发的方向，当然不仅仅只会关注后台相关的技术点，也会在业余时间学习一些算法和前端技术栈。逐渐的，不断在不同维度中学习技术，不断成长。</p>
<p>总之在技术快跑的过程中，我们不仅仅要学会一门精通的手艺，同时也要有自己的辅助第二技术或是第三技术。要学会用后台思维写前端，算法思维写后台，产品思维写算法。我们做的不仅仅是功能，要让每一行代码都具备灵魂。</p>
<p>个人对于产品是非常热爱的，这几年互联网的高速发展，整个中国发生了翻天覆地的变化。国民的衣食住行都发生了巨变，吃饭——美团、点评、饿了么，买衣服——淘宝、唯品会、京东，出行——哈啰单车、各种共享电动车、滴滴出行、曹操专车，住房——自如、贝壳找房、58 同城，还有改变生活方式的微信和支付宝。他们都将逐步成为我们生活中的水电煤，逐步融入人们的血液。在技术水平和思维格局到达已经层次，十分希望在未来的日子，在某个对的时刻能够创造一个影响一个时代的产品。</p>
<p><img src="https://www.mqiy.xyz/image/develop/teac-leader.png" alt="teac-leader.png"></p>
<p>(图：技术路线与管理路线)</p>
<h3 id="三、如何学习与技术快跑"><a href="#三、如何学习与技术快跑" class="headerlink" title="三、如何学习与技术快跑"></a>三、如何学习与技术快跑</h3><p>上文通过自身经验举例，说了一些自己的技术成长路线。下面来谈谈技术学习的一些方法论，主要围绕以下四个部分进行讨论：</p>
<ul>
<li>技术架构</li>
<li>极限编程</li>
<li>学习总结</li>
<li>技术分享<h4 id="1-技术架构"><a href="#1-技术架构" class="headerlink" title="1. 技术架构"></a>1. 技术架构</h4>在学习技术前，我不知道大家是怎样的一种心态。我喜欢把技术比作一栋大厦，大部分人都会从大门进入，一步一步往上走，技术也在一点点的提高，但很多人大部分时候都会质疑自己学来到底有什么用，或是会遇到一些技术瓶颈，或是很多时候迷茫了也不知道该学习哪些东西。  </li>
</ul>
<p>技术的成长我认为分成三个层次：我不知道我不知道，我知道我不知道，我知道我知道。从技术的小白，到技术小达人，再到技术牛人。</p>
<p>在这栋技术大厦中，在技术小白阶段，就是按部就班的往上爬，但是当你技术学习到一定程度的时候，你必须开始了解整栋大厦的框架结构。所以在这里，必须要开始转向系统架构。这里摘抄一段《许式伟：架构设计的宏观视角》中的话，也正是我们想要表达的思想。</p>
<p>如同造房子有建筑工人（负责搬砖）和建筑师（负责架构设计）一样，软件系统的开发过程同样需要有程序员（负责搬“砖”）和架构师（负责架构设计）。作为架构师，我们需要的第一个能力是宏观的全局掌控能力。</p>
<p>如果把应用程序比作一座大厦，那么我们作为大厦的架构师，需要把大厦的结构搭建好，让程序员可以把砖填充进去，我们都知道，一个大厦的结构建得是否稳固，与地基密不可分。</p>
<p>所以，我们首先就需要从大厦的地基开始，熟悉这座大厦。毕竟，你对所依赖的基础架构了解得越全面，做业务架构设计就会越发从容。</p>
<p>技术想要成长，必须首先在思想上成长，提升自己的技术思想高度。一个不想成为建筑师的包工头不是一个好的架构师，在学习这条往上的路上，必须要学会用宏观视角来解决问题。在技术成长的过程中，有时候不需要太多的注意某个细节是怎么实现的，而是要有技术判断力，技术是否可行，技术如何选型。</p>
<p>下面给大家列一下，后台开发工程师需要达到的一个高度吧，做一个简单的感知。</p>
<p><strong>数据结构与算法实战</strong></p>
<ul>
<li>Leetcode</li>
<li>剑指 Offer</li>
</ul>
<p><strong>内功修炼</strong></p>
<ul>
<li>数据结构与算法</li>
<li>海量数据处理方法</li>
<li>Linux 基础与命令</li>
<li>计算机网络（应用层，传输层，网络层等相关协议）</li>
<li>Web 网络和 HTTP/HTTPS 协议</li>
<li>数据库（MySQL，Redis）</li>
<li>操作系统原理</li>
<li>Git 版本管理工具使用</li>
<li>正则表达式</li>
</ul>
<p><strong>Java 核心技术</strong></p>
<ul>
<li>语法与基础概念</li>
<li>面向对象与 23 种设计模式</li>
<li>Java 容器源码（数据结构 &amp; 源码分析：ArrayList、Vector、LinkedList、HashMap、ConcurrentHashMap、HashSet、LinkedHashSet and LinkedHashMap）</li>
<li>Java 并发编程（线程状态、线程机制、线程通信、J.U.C 组件、JMM、线程安全、锁优化）</li>
<li>Java IO（磁盘操作、字节操作、字符操作、对象操作、网络操作、NIO）</li>
<li>Java 虚拟机（运行时数据区域、垃圾收集、内存分配机制、类加载机制、性能调优监控工具）</li>
<li>Java Web（学习 SSM + SpringBoot 框架和设计模式思想）</li>
</ul>
<p><strong>分布式解决方案</strong></p>
<ul>
<li>SpringCloud</li>
<li>Zookeeper（分布式协调服务）</li>
<li>Dubbo（分布式服务治理）</li>
<li>分布式事务解决方案</li>
<li>ActiveMQ、Kafka、RabbitMQ（分布式消息通信）</li>
<li>Redis（分布式缓存与集群搭建）</li>
<li>mycat（数据库路由）</li>
<li>Nginx（反向代理）</li>
<li>Docker（容器技术）</li>
<li>Tomcat<br>最后推荐一些阅读脚本<br>一张<a href="https://www.mqiy.xyz/image/develop/backend-skill.svg" target="_blank" rel="noopener" title="后台开发技能图谱">后台开发技能图谱</a>分享给大家<br>整理了一些阅读清单与学习课程<a href="https://www.frankfeekr.cn/2019/04/19/cs-learning-list" target="_blank" rel="noopener">计算机学习的“武林秘籍”</a>，欢迎大家学习<h4 id="2-极限编程"><a href="#2-极限编程" class="headerlink" title="2. 极限编程"></a>2. 极限编程</h4>接着，来聊聊极限编程。极限，就一个字”快”！</li>
</ul>
<p>身边也经常有很多人，常常在每次项目中，都没来得及系统学习技术栈就要开始项目开发了；大部分的时间都在复制粘贴，面向搜索引擎编程，找不到自己的技术核心点。</p>
<p>包括自己在内，很多时候也都希望当自己掌握了完整的一套技术栈以后再开始你的项目编码。经历过很多项目之后，我会发现其实这并不是正确的做法。同样的，这也遵循二八定律，在技术中我们只要花少量的时间学会 20% 的技术，就可以开始项目开发，剩下的 80% 大部分都应该在项目实践中去学习的。</p>
<p>在很多的项目中，根本来不及有太多的时间让我们学习。很可能一个新的技术，通过短短 5-7 天的学习，就必须要应用到项目中去，很难有太多的时间让你系统学习。特别在互联网的应用场景中，时间就是金钱，一个好的想法，必须在最短的时间内上线。极限编程正是这样一种敏捷快速的开发方式，要求团队成员拥有很高的技术素养，在很短时间内就可以学会并且应用。</p>
<p>在这里，我们从个人的经验，分享我在极限编程学习过程中的路线：</p>
<p>先看技术效果</p>
<p>学会检索一些牛逼的项目，看看通过这个技术可以达到什么样的效果，判断是否满足自己的需求。<br>结果导向的学习，更加能提升我们的学习兴趣。<br>快速视频学习入门(10小时以内)</p>
<p>特别像我一样学习不太喜欢看书，感觉到很枯燥的同学，我推荐直接找视频快速入门，视频不宜太长，10小时左右(2.0x 速度看)。快速的了解技术的状况，掌握基本的核心技术，会的部分直接跳过。<br>这里推荐一些好的学习网站：慕课网、极客时间、哔哩哔哩、极客学院、实验楼、学堂在线。<br>开源小项目</p>
<p>在视频学习入门之后我们可能还不具备一个项目的编码能力，这时候我们可以找一些开源项目来跑一跑（学会使用 GitHub），项目不宜太复杂，一个简单的小项目即可。<br>配合文档同步学习</p>
<p>技术文档不像小说，一定更不要从头到尾的读，选择有必要的部分尝试通读，但是大部分的文档应该作为字典一样的查询工具书。<br>开始投入项目生产</p>
<p>终于可以正式开始项目实践了，选择好自己的项目框架，配合文档、视频，不会的部分当然还得靠搜索引擎。<br>项目复盘与重构</p>
<p>重新审视自己的代码，有条件的应该让大神给你看看，指点一下代码，以便在未来升级改进。<br>技术进阶，重新回到书本(或是项目文档)</p>
<p>无论你在搜索引擎找到的答案，都是比较碎片化的知识。当你想要深入到底层或是原理相关的部分，你应该选择一本大众认可的书籍进行深入阅读，大部分的书才是一个最系统和深入的学习。当然要看技术点的感兴趣和必要成分，不是所有的技术都需要深入了解，但是在自己的技术领域应该还是需要不断精通和升华。</p>
<h4 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3. 学习总结"></a>3. 学习总结</h4><p>在技术学习的过程中，我们可能会遇到很多的技术难点，还会遇到很多碎片化的检索工作，很多技术点我们肯定是不可能都记住甚至背下来。经常，我们会遇到一些常见遇到一些常见的东西，每次见到我们都要重新谷歌检索一遍，浪费了大量的时间。所以，学习总结是非常有必要。</p>
<p>都说好记性不如烂笔头，定期的学习和整理必然对学习巩固有所帮助，这里通过索引的方式对技术做一个系统分类，方便随时巩固和学习，当然还有面试。在学习这条路上难免会有很多盲点和学不完的知识。有道无术，术尚可求，掌握好思维能力才能应对千变万化的技术。不要把大脑当成硬盘，也不要做高速运转的 CPU，而修行自己的大脑成为一个搜索引擎，学会分析解决问题。</p>
<p>个人也是因为 MarkDown 而爱上的写作，这里盘点一些学习总结的方式：</p>
<p>技术博客 &amp; 微信订阅号<br>首先技术博客是一个非常好的途径，可以通过掘金、CSDN、知乎专栏、知识星球等等途径编写自己的技术博客。<br>稍微极客一点的同学可以自己搭建一个自己的博客，例如：WordPress、Hexo、Hugo 这样的博客。(推荐使用 Hexo + GitHub + Typora + MD 来写自己的技术博客)。欢迎来我的博客逛逛：<a href="https://www.frankfeekr.cn/" target="_blank" rel="noopener">https://www.frankfeekr.cn/</a><br>在技术博客的编写过程中，首先对你知识的回顾是很有帮助的，其次也将成为你的个人检索宝库，把自己常见的一些问题都记录在你的博客中，再下一次遇到的时候就可以信手捏来。<br>很多著名的技术书籍早期都是通过博客来积累自己的素材，当你的技术和文字达到一定功底，我想出书也是非常自然而然的事情。<br>此外还可以申请个人的微信订阅号来编写自己的技术博客，这也是一个很好的传播途径，慢慢的积累自己的粉丝哈哈。欢迎关注我的微信公众号，“全栈开发社区”。<br>GitHub 开源项目<br>GitHub 不仅仅可以分享代码性质的项目，当然在上面你还可以开源自己博客项目，你可以通过 .md 来记录自己的技术博客。<br>很多开源的书籍、文档翻译项目都可以通过 GitHub 来托管<br>通过 GitHub 你还获取到了版本控制的文本和图床，这相比自己搭建服务器来构建博客更加的方便和安全，并且永不丢失。<br>欢迎看看我在 GitHub 上的技术项目：<a href="https://github.com/frank-lam/fullstack-tutorial" target="_blank" rel="noopener">https://github.com/frank-lam/fullstack-tutorial</a><br>其他<br>此外你还可以通过诸如：为知笔记、有道云笔记等方式进行学习总结<br>最后建议大家不要再用你的 txt 或是 word 来记录你的笔记</p>
<h4 id="4-分享技术"><a href="#4-分享技术" class="headerlink" title="4. 分享技术"></a>4. 分享技术</h4><p>学习金字塔是美国缅因州的国家训练实验室研究成果，它用数字形式形象显示了：采用不同的学习方式，学习者在两周以后还能记住内容（平均学习保持率）的多少。</p>
<p>在金字塔基座位置的学习方式，是“教别人”或者“马上应用”，可以记住 90% 的学习内容。通过学习金字塔，我们会发现学习最好的方式应该是主动学习并且学会分享教授别人如何学习。在教授别人的过程中，我们在输出知识，也在不断的输入别人的疑惑，看似单向学习的过程中实际上也是双向的学习，不断的巩固自己的知识。</p>
<p>那么在技术学习中呢？没错我们不仅要学会倾听别人的技术，很多时候我们要学会分享技术。要知道一个好的技术管理者，必须要学会根据团队成员的不同情况，制定不一样的培养方案，这也是很重要的一个能力。通过分享你的技术，同时你也会不断的巩固自己的逻辑能力和技术表达能力。</p>
<p><img src="https://www.mqiy.xyz/image/develop/lean-pyramid.jpg" alt="lean-pyramid.jpg"></p>
<p>(图：学习金字塔，图片来源网络)</p>
<h4 id="5-看源码"><a href="#5-看源码" class="headerlink" title="5. 看源码"></a>5. 看源码</h4><h5 id="基础的源码慢慢都啃了一遍"><a href="#基础的源码慢慢都啃了一遍" class="headerlink" title="基础的源码慢慢都啃了一遍"></a><code>基础的源码慢慢都啃了一遍</code></h5><ul>
<li>最基本的HashMap 和 ConcurrentHashMap</li>
<li>线程池的源码实现</li>
<li>阻塞队列BlockingQueue相关实现</li>
<li>ReentrantLock 实现，以及其内部同步器Sync的实现原理</li>
<li>Future的实现原理</li>
<li>AtomicXXX是如何运转的</li>
</ul>
<h5 id="看源码的几个好处："><a href="#看源码的几个好处：" class="headerlink" title="看源码的几个好处："></a>看源码的几个好处：</h5><ul>
<li>从源码中学习如何性能优化、设计模式等</li>
<li>深入源码，才能了解真相</li>
<li>了解源码，才能更好的解决问题</li>
<li>你懂源码，面试官更懂你</li>
</ul>
<h5 id="源码怎么读，才比较有效率？"><a href="#源码怎么读，才比较有效率？" class="headerlink" title="源码怎么读，才比较有效率？"></a>源码怎么读，才比较有效率？</h5><ul>
<li>从问题出发，带着问题看源码</li>
<li>面向debug学源码</li>
<li>写写写，做笔记</li>
</ul>
<h3 id="四、最后几句话"><a href="#四、最后几句话" class="headerlink" title="四、最后几句话"></a>四、最后几句话</h3><p>技术学习的路是很长的，需要我们掌握好高效的学习方式，终身学习。</p>
<p>你要相信自己，可以通过 20 小时学会任何技能，也能通过 10000 小时成为某个领域的资深专家。在立足于本身技术深度学习的同时，也记得拓展自己思维的广度。</p>
<p>只有一个好的技术学习方法 ，才能让你在如今不断动荡的互联网江湖中，屹立不倒、处变不惊。</p>
]]></content>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2019/11/05/md/develop/base/pattern/memento/</url>
    <content><![CDATA[<h2 id="备忘录（Memento）"><a href="#备忘录（Memento）" class="headerlink" title="备忘录（Memento）"></a>备忘录（Memento）</h2><h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p>
<h3 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<p><img src="https://www.mqiy.xyz/image/pattern/memento-class.png" alt="memento-class.png"></p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p>
<p>实现参考：<a href="https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html" target="_blank" rel="noopener">Memento Pattern - Calculator Example - Java Sourcecode</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Originator Interface</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Create Memento</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">PreviousCalculationToCareTaker <span class="title">backupLastCalculation</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// setMemento</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restorePreviousCalculation</span><span class="params">(PreviousCalculationToCareTaker memento)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCalculationResult</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFirstNumber</span><span class="params">(<span class="keyword">int</span> firstNumber)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSecondNumber</span><span class="params">(<span class="keyword">int</span> secondNumber)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Originator Implementation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImp</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> firstNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> secondNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> PreviousCalculationToCareTaker <span class="title">backupLastCalculation</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// create a memento object used for restoring two numbers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PreviousCalculationImp(firstNumber, secondNumber);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restorePreviousCalculation</span><span class="params">(PreviousCalculationToCareTaker memento)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalculationResult</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// result is adding two numbers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> firstNumber + secondNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstNumber</span><span class="params">(<span class="keyword">int</span> firstNumber)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.firstNumber = firstNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecondNumber</span><span class="params">(<span class="keyword">int</span> secondNumber)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.secondNumber = secondNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Memento Interface to Originator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * This interface allows the originator to restore its state</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PreviousCalculationToOriginator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirstNumber</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSecondNumber</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *  Memento interface to CalculatorOperator (Caretaker)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PreviousCalculationToCareTaker</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// no operations permitted for the caretaker</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Memento Object Implementation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * &lt;p&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Note that this object implements both interfaces to Originator and CareTaker</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreviousCalculationImp</span> <span class="keyword">implements</span> <span class="title">PreviousCalculationToCareTaker</span>,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        <span class="title">PreviousCalculationToOriginator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> firstNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> secondNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PreviousCalculationImp</span><span class="params">(<span class="keyword">int</span> firstNumber, <span class="keyword">int</span> secondNumber)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.firstNumber = firstNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.secondNumber = secondNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNumber</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> firstNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSecondNumber</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> secondNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * CareTaker object</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// program starts</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Calculator calculator = <span class="keyword">new</span> CalculatorImp();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// assume user enters two numbers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        calculator.setFirstNumber(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        calculator.setSecondNumber(<span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// find result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(calculator.getCalculationResult());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Store result of this calculation in case of error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        PreviousCalculationToCareTaker memento = calculator.backupLastCalculation();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// user enters a number</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        calculator.setFirstNumber(<span class="number">17</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// user enters a wrong second number and calculates result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        calculator.setSecondNumber(-<span class="number">290</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// calculate result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(calculator.getCalculationResult());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// user hits CTRL + Z to undo last operation and see last result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        calculator.restorePreviousCalculation(memento);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// result restored</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(calculator.getCalculationResult());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">110</span></pre></td></tr><tr><td class="code"><pre><span class="line">-273</span></pre></td></tr><tr><td class="code"><pre><span class="line">110</span></pre></td></tr></table></figure>

<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><ul>
<li>java.io.Serializable</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2019/11/04/md/develop/base/pattern/Proxy/</url>
    <content><![CDATA[<h2 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h2><h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>控制对其它对象的访问。</p>
<p><strong>优点</strong>： 1、职责清晰。 2、高扩展性。 3、智能化。</p>
<p><strong>缺点</strong>： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
<p><strong>使用场景</strong>：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p>
<p><strong>注意事项</strong>： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<h3 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>代理有以下四类：</p>
<ul>
<li>远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li>
<li>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li>
<li>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li>
<li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li>
</ul>
<p><img src="https://www.mqiy.xyz/image/pattern/proxy-class.png" alt="proxy-class.png"></p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showImage</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighResolutionImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> URL imageURL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> height;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> width;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighResolutionImage</span><span class="params">(URL imageURL)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.imageURL = imageURL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.width = <span class="number">600</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.height = <span class="number">600</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLoad</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 模拟图片加载，延迟 3s 加载完成</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> endTime - startTime &gt; <span class="number">3000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showImage</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Real Image: "</span> + imageURL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProxy</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> HighResolutionImage image;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageProxy</span><span class="params">(HighResolutionImage image)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.image = image;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showImage</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!image.isLoad()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(<span class="string">"Image: "</span> + image.getWidth() + <span class="string">" "</span> + image.getHeight());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Thread.sleep(<span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        image.showImage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String image = <span class="string">"http://image.jpg"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        URL url = <span class="keyword">new</span> URL(image);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HighResolutionImage highResolutionImage = <span class="keyword">new</span> HighResolutionImage(url);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ImageProxy imageProxy = <span class="keyword">new</span> ImageProxy(highResolutionImage);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        imageProxy.showImage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><ul>
<li>java.lang.reflect.Proxy</li>
<li>RMI</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者</title>
    <url>/2019/11/04/md/develop/base/pattern/observer/</url>
    <content><![CDATA[<h2 id="7-观察者（Observer）"><a href="#7-观察者（Observer）" class="headerlink" title="7. 观察者（Observer）"></a>7. 观察者（Observer）</h2><h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<p><img src="https://www.mqiy.xyz/image/pattern/201911042144.jpg" alt="7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg"></p>
<h3 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<p><img src="https://www.mqiy.xyz/image/pattern/201911042145.png" alt="a8c8f894-a712-447c-9906-5caef6a016e3.png"></p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p>
<p><img src="https://www.mqiy.xyz/image/pattern/201911042145.jpg" alt="b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        notifyObserver();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        observers.add(o);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            observers.remove(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            o.update(temperature, humidity, pressure);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        weatherData.reisterObserver(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"StatisticsDisplay.update: "</span> + temp + <span class="string">" "</span> + humidity + <span class="string">" "</span> + pressure);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"CurrentConditionsDisplay.update: "</span> + temp + <span class="string">" "</span> + humidity + <span class="string">" "</span> + pressure);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        weatherData.setMeasurements(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        weatherData.setMeasurements(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">CurrentConditionsDisplay.update: 0.0 0.0 0.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">StatisticsDisplay.update: 0.0 0.0 0.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">CurrentConditionsDisplay.update: 1.0 1.0 1.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">StatisticsDisplay.update: 1.0 1.0 1.0</span></pre></td></tr></table></figure>

<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener">java.util.Observer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener">java.util.EventListener</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener">javax.servlet.http.HttpSessionBindingListener</a></li>
<li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2019/11/01/md/part/web/js/vue/</url>
    <content><![CDATA[<h3 id="运行vue项目"><a href="#运行vue项目" class="headerlink" title="运行vue项目"></a>运行vue项目</h3><p>打开cmd 进入项目的路径<br>进入项目之后安装依赖</p>
<p>npm install<br>你的项目下会生成名字叫：node_modules 的文件</p>
<p>然后执行以下语句，就会自动打开浏览器了</p>
<p>npm run dev</p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>idea</title>
    <url>/2019/11/01/md/tool/idea/</url>
    <content><![CDATA[<h4 id="Method-is-never-used"><a href="#Method-is-never-used" class="headerlink" title="Method is never used"></a>Method is never used</h4><p><img src="https://www.mqiy.xyz/image/tool/MethodIsNeverUsed.png" alt="Method is never used"></p>
<h4 id="create-serialVersionUID"><a href="#create-serialVersionUID" class="headerlink" title="create serialVersionUID"></a>create serialVersionUID</h4><p><img src="https://www.mqiy.xyz/image/tool/serialVersionUID.png" alt="serialVersionUID"></p>
<h4 id="多行左移快捷键"><a href="#多行左移快捷键" class="headerlink" title="多行左移快捷键"></a>多行左移快捷键</h4><p><code>shift+tab</code> </p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul>
<li>grep-console  </li>
</ul>
<h4 id="找不到符号"><a href="#找不到符号" class="headerlink" title="找不到符号"></a>找不到符号</h4><p>rebuild module</p>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>ctrl + alt +B  查找接口实现类的快捷键   ctal+alt 点击方法<br>ctrl+alt+方向键 快速返回上次查看代码的位置</p>
<p>Alt+F7  查询类，方法，使用的地方</p>
<p>定位</p>
<p>ctrl+B  选中方法时跳到调用的地方，选中类，跳到类实现</p>
<p>Alt+Up/Down，在方法间快速移动定位</p>
<p>Alt+insert  重写方法</p>
<p>Ctrl+X  删除当前行</p>
<p>Ctrl+F12 打开类方法属性概要视图</p>
<p>Ctrl+G  定位行</p>
<p>shift F6  批量重命名对象</p>
<p>Ctrl + shift + K 推到远程仓库</p>
<p>Ctrl+ Q 显示文档注释</p>
<p>查找接口的实现类：</p>
<p>IDEA 风格 ctrl + alt +B</p>
<p>查看类或接口的继承关系：<br>ctrl + h</p>
<p>ctrl+shift+U  转大小写</p>
<p>Shift+Click，可以关闭文件<br>Ctrl+Shift+E，最近更改的文件</p>
<p>ctrl+shif+x  全屏</p>
<p>ctrl+alt+z git恢复<br>ctrl+sift+` 切换分支</p>
<p>三、列操作<br>1.ctrl+shift+alt+j    列操作（多行逻辑操作、批量操作）</p>
<p>2.Ctrl+←(→)    移动到一个词的开始(结尾)</p>
<p>3.Ctrl+Shift+←(→)    从后到前（从前到后）选中一个词</p>
<p>4.Ctrl+Home    第一行代码</p>
<p>5.Ctrl+End    最后一行代码</p>
<p>6.ctrl+alt+l    代码格式化</p>
<p>alt+insert  生成getter and setter</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2019/11/01/md/tool/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 增加readme.txt文件到暂存区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git add readme.txt  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">git status</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 丢弃工作区的修改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git checkout -- file  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">git checkout branchName</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">git pull</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">git merge branchName</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 就是查看远程的所有分支列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git branch -a</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 撤销本地提交，回复到这个版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git reset 1bb6c7b4d53764f2e46672148902008eef883d89  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复到最后一次提交的改动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git checkout .</span></pre></td></tr></table></figure>

<h3 id="git最佳实践"><a href="#git最佳实践" class="headerlink" title="git最佳实践"></a>git最佳实践</h3><h4 id="解决git-pull-和-git-push-每次都需要输入密码的问题"><a href="#解决git-pull-和-git-push-每次都需要输入密码的问题" class="headerlink" title="解决git pull 和 git push 每次都需要输入密码的问题"></a>解决git pull 和 git push 每次都需要输入密码的问题</h4><blockquote>
<p><code>git config --global credential.helper store</code><br>之后再次执行git push 或者git pull这时候还需要输入用户名和密码,下次就不需要了</p>
</blockquote>
<hr>
<h4 id="回滚远程提交"><a href="#回滚远程提交" class="headerlink" title="回滚远程提交"></a>回滚远程提交</h4><p>git reset –hard HEAD^<br>git push –force</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2019/10/31/md/jdk/mulThread/ThreadLocal/</url>
    <content><![CDATA[<h3 id="3-1-ThreadLocal简介"><a href="#3-1-ThreadLocal简介" class="headerlink" title="3.1. ThreadLocal简介"></a>3.1. ThreadLocal简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p>再举个简单的例子： </p>
<p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。</p>
<h3 id="3-2-ThreadLocal示例"><a href="#3-2-ThreadLocal示例" class="headerlink" title="3.2. ThreadLocal示例"></a>3.2. ThreadLocal示例</h3><p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">""</span>+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            t.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" default Formatter = "</span>+formatter.get().toPattern());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" formatter = "</span>+formatter.get().toPattern());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 0 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 0 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 1 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 2 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 1 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 3 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 2 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 4 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 3 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 4 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 5 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 5 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 6 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 6 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 7 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 7 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 8 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 9 default Formatter &#x3D; yyyyMMdd HHmm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 8 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread Name&#x3D; 9 formatter &#x3D; yy-M-d ah:mm</span></pre></td></tr></table></figure>

<p>从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。</p>
<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法<code>withInitial()</code>，将Supplier功能接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">       </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;;</span></pre></td></tr></table></figure>

<h3 id="3-3-ThreadLocal原理"><a href="#3-3-ThreadLocal原理" class="headerlink" title="3.3. ThreadLocal原理"></a>3.3. ThreadLocal原理</h3><p>从 <code>Thread</code>类源代码入手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ......</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ......</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个  <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code>  类型的变量,我们可以把 <code>ThreadLocalMap</code>  理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Thread t = Thread.currentThread();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ThreadLocalMap map = getMap(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        map.set(<span class="keyword">this</span>, value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        createMap(t, value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> t.threadLocals;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key的键值对。</strong> 比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。<code>ThreadLocal</code> 是 map结构是为了让每个线程可以关联多个 <code>ThreadLocal</code>变量。这也就解释了 ThreadLocal 声明的变量为什么在每一个线程都有自己的专属本地变量。</p>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadLocal%E5%86%85%E9%83%A8%E7%B1%BB.png" alt="ThreadLocal内部类"></p>
<h3 id="3-4-ThreadLocal-内存泄露问题"><a href="#3-4-ThreadLocal-内存泄露问题" class="headerlink" title="3.4. ThreadLocal 内存泄露问题"></a>3.4. ThreadLocal 内存泄露问题</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">/** The value associated with this ThreadLocal. */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Object value;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">super</span>(k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value = v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试导图</title>
    <url>/2019/10/30/md/interview/java_interview/</url>
    <content><![CDATA[<p><img src="https://www.mqiy.xyz/image/develop/java_interview.png" alt="java_interview.png"></p>
]]></content>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>后端技术</title>
    <url>/2019/10/30/md/develop/backend-skill/</url>
    <content><![CDATA[<p><img src="https://www.mqiy.xyz/image/develop/backend-skill.svg" alt="jv.png"></p>
]]></content>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>五笔口诀</title>
    <url>/2019/10/30/md/other/input/wubi-tip/</url>
    <content><![CDATA[<h3 id="横区"><a href="#横区" class="headerlink" title="横区"></a>横区</h3><ul>
<li>11G 王旁青头五夫一，</li>
<li>12F 土干十寸未甘雨，</li>
<li>13D 大犬戊其古石厂，</li>
<li>14S 木丁西甫一四里，</li>
<li>15A 工戈草头右框七。  </li>
</ul>
<h3 id="竖区"><a href="#竖区" class="headerlink" title="竖区"></a>竖区</h3><ul>
<li>21H 目上卜止虎头具，</li>
<li>22J 日早两竖与虫依，</li>
<li>23K 口中两川三个竖，</li>
<li>24L 田甲方框四车里，  </li>
<li>25M 山由贝骨下框集。 </li>
</ul>
<h3 id="撇区"><a href="#撇区" class="headerlink" title="撇区"></a>撇区</h3><ul>
<li>31T 禾竹反文双人立，</li>
<li>32R 白斤气丘叉手提，</li>
<li>33E 月用力豸毛衣臼，</li>
<li>34W 人八登头单人几，</li>
<li>35Q 金夕鸟儿犭边鱼。</li>
</ul>
<h3 id="捺区"><a href="#捺区" class="headerlink" title="捺区"></a>捺区</h3><ul>
<li>41Y 言文方点谁人去，</li>
<li>42U 立辛六羊病门里，</li>
<li>43I 水族三点鳖头小，</li>
<li>44O 火业广鹿四点米，</li>
<li>45P 之字宝盖补礻衤。  </li>
</ul>
<h3 id="折区"><a href="#折区" class="headerlink" title="折区"></a>折区</h3><ul>
<li>51N 已类左框心尸羽，</li>
<li>52B 子耳了也乃框皮，</li>
<li>53V 女刀九艮山西倒，</li>
<li>54C 又巴牛厶马失蹄，</li>
<li>55X 幺母贯头弓和匕。</li>
</ul>
]]></content>
      <tags>
        <tag>五笔</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题目</title>
    <url>/2019/10/30/md/interview/friend-interview/</url>
    <content><![CDATA[<h3 id="one"><a href="#one" class="headerlink" title="one"></a>one</h3><ul>
<li>说说ThreadLocal如何保证线程安全</li>
<li>ZAB 与 PAXOS</li>
</ul>
<h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>####</p>
<p>wyn</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存问题</title>
    <url>/2019/10/30/md/part/redis/cache-problem/</url>
    <content><![CDATA[<h3 id="大量缓存同一时间失效会引起缓存的雪崩"><a href="#大量缓存同一时间失效会引起缓存的雪崩" class="headerlink" title="大量缓存同一时间失效会引起缓存的雪崩"></a>大量缓存同一时间失效会引起缓存的雪崩</h3><p>Redis<code>高可用</code>（High Availability）两种实现方式</p>
<ul>
<li>主从复制数据。</li>
<li>哨兵模式</li>
</ul>
<blockquote>
<p>网上给Redis加锁的机制都是利用Redis的setnx自身的方法去加锁,且防止死锁</p>
</blockquote>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis模型模式</title>
    <url>/2019/10/30/md/part/redis/redis-build-model/</url>
    <content><![CDATA[<p>####　sentinel模式</p>
<h4 id="cluster模式"><a href="#cluster模式" class="headerlink" title="cluster模式"></a>cluster模式</h4><p>cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，<br>这种模式适合<code>数据量巨大</code>的缓存要求</p>
<p>不足：</p>
<ul>
<li>一般涉及多个key的操作会不支持，取两个set的并集，且两个set在不同的Redis实例上面（当然也是能实现的，只是Redis不会直接支持这么做）。</li>
<li>涉及多个key的事务将不能使用</li>
<li>使用分区时,数据处理更加复杂,例如你必须处理多个RDB / AOF文件,你需要备份你的数据并聚合多个实例和主机的持久性文件。</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis持久化</title>
    <url>/2019/10/30/md/part/redis/redis-backup/</url>
    <content><![CDATA[<p>RDB：　 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化</p>
<p>优点：<br>    数据快照，适合做冷备<br>    对性能影响小<br>    回复快<br>缺点：<br>    丢失少量数据<br>    数据量过大，影响服务提供</p>
<p>AOF：　AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。<br>优点：<br>    数据不丢失（1s fsync）<br>    可读方式记录，适合恢复<br>缺点：<br>    文件大<br>    QPS相对低<br>    发年bug,数据未恢复一致</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis热key</title>
    <url>/2019/10/30/md/part/redis/redis-keyhot/</url>
    <content><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>怎么发现热key<br>方法一:凭借业务经验，进行预估哪些是热key</p>
<p>其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。</p>
<p>方法二:在客户端进行收集</p>
<p>这个方式就是在操作redis之前，加入一行代码进行数据统计。</p>
<p>方法三:在Proxy层做收集 </p>
<p>方法四:用redis自带命令</p>
<p>(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</p>
<p>(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</p>
<p>####解决方法：</p>
<ul>
<li>利用二级缓存</li>
<li>备份热key</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis哨兵</title>
    <url>/2019/10/30/md/part/redis/redis-sential/</url>
    <content><![CDATA[<h3 id="安装-redis"><a href="#安装-redis" class="headerlink" title="安装 redis"></a>安装 redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载,编译</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.7.tar.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line">tar xzf redis-5.0.7.tar.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line">cd redis-5.0.7</span></pre></td></tr><tr><td class="code"><pre><span class="line">make</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cp src/redis-server /usr/bin/</span></pre></td></tr><tr><td class="code"><pre><span class="line">cp src/redis-cli /usr/bin/</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启服务器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">src/redis-server</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启客户端</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">src/redis-cli</span></pre></td></tr></table></figure>


<h3 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h3><h4 id="cc-command-not-found"><a href="#cc-command-not-found" class="headerlink" title="cc: command not found"></a>cc: command not found</h4><p>安装<code>gcc</code></p>
<p>yum install -y gcc</p>
<h4 id="jemalloc-jemalloc-h-No-such-file-or-directory"><a href="#jemalloc-jemalloc-h-No-such-file-or-directory" class="headerlink" title="jemalloc/jemalloc.h: No such file or directory"></a>jemalloc/jemalloc.h: No such file or directory</h4><p>原因是jemalloc重载了Linux下的ANSI C的malloc和free函数。解决办法：make时添加参数。</p>
<blockquote>
<p>make MALLOC=libc</p>
</blockquote>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis篇特点</title>
    <url>/2019/10/30/md/part/redis/subject-redis/</url>
    <content><![CDATA[<h2 id="redis篇"><a href="#redis篇" class="headerlink" title="redis篇"></a>redis篇</h2><ul>
<li>第一章节 redis介绍</li>
<li>第二章节 redis集群策略</li>
<li>第三章节 redis高级特性</li>
</ul>
<h2 id="第一章节"><a href="#第一章节" class="headerlink" title="第一章节"></a>第一章节</h2><ul>
<li>redis介绍<ul>
<li>1.1 redis 特性</li>
<li>1.2 redis 数据类型</li>
<li>1.3 redis 应用场景</li>
<li>1.4 redis Java客户端</li>
</ul>
</li>
</ul>
<h3 id="1-1-redis特性"><a href="#1-1-redis特性" class="headerlink" title="1.1 redis特性"></a>1.1 redis特性</h3><ul>
<li>单核单线程 没有线程安全问题</li>
<li>性能高 IO多路复用 内存操作</li>
<li>支持多种持久化方案</li>
<li>支持弱事务 不支持Rollback</li>
<li>支持排序 分页 模糊搜索功能</li>
<li>支持队列订阅发布</li>
</ul>
<h3 id="1-2-redis-数据类型"><a href="#1-2-redis-数据类型" class="headerlink" title="1.2 redis 数据类型"></a>1.2 redis 数据类型</h3><ul>
<li>String类型 字符串类型 4.0版本后增加json的schema</li>
<li>hash类型 即可支持kkv模型</li>
<li>List类型 支持排序 支持队列命令 可用于简单的消息队列</li>
<li>Set类型 数据唯一类型 类似list</li>
<li>Sorted set类型 类似set/list 可通过score参数来自动排序</li>
</ul>
<h3 id="1-3-redis-应用场景"><a href="#1-3-redis-应用场景" class="headerlink" title="1.3 redis 应用场景"></a>1.3 redis 应用场景</h3><ul>
<li>各类别缓存方案 页面 业务 数据 </li>
<li>实时计数器 统计仪表 排行榜</li>
<li>分布式锁 开关</li>
<li>消息队列 发布/订阅</li>
<li>session存储</li>
<li>支持分页 模糊查询</li>
<li>搜索倒排的缓存</li>
</ul>
<h2 id="1-4-redis-Java客户端"><a href="#1-4-redis-Java客户端" class="headerlink" title="1.4 redis Java客户端"></a>1.4 redis Java客户端</h2><ul>
<li>Redisson 提供分布式相关操作服务 支持延迟队列</li>
<li>Jedis 多线程下 有线程安全问题 提供了基础操作</li>
<li>lettuce 高级Redis客户端 线程安全 springboot2.0集成支持</li>
</ul>
<h2 id="第二章节"><a href="#第二章节" class="headerlink" title="第二章节"></a>第二章节</h2><ul>
<li>redis集群策略<ul>
<li>2.1 redis 主从复制</li>
<li>2.2 redis 哨兵模式</li>
<li>2.2 redis 自带的集群模式</li>
</ul>
</li>
</ul>
<h3 id="2-1-redis-主从复制"><a href="#2-1-redis-主从复制" class="headerlink" title="2.1 redis 主从复制"></a>2.1 redis 主从复制</h3><ul>
<li>主数据库(master) 从数据库(slave) master可以进行读写操作 当读写操作导致数据变化时会自动将数据同步salve</li>
<li>机制初始化 slave发送SYNC命令 master接收到SYNC 将保存的快照文件(rdb)和缓存的命令发送给slave</li>
<li>复制初始化后 master每次接收到的写命令都会同步发送给slave 保证主从数据一致性</li>
<li>此方法不可保证高可用 或需要手动或程序来做主从切换等 但可以做到读写分离</li>
</ul>
<h3 id="2-2-redis-哨兵模式"><a href="#2-2-redis-哨兵模式" class="headerlink" title="2.2 redis 哨兵模式"></a>2.2 redis 哨兵模式</h3><ul>
<li>基于主从模式下的监控模式 </li>
<li>哨兵通过发送命令来监控master/slave是否正常运行</li>
<li>master出现故障时 开启选举自动将slave转化为master</li>
<li>多哨兵配置的时候 哨兵之间也会自动监控</li>
<li>多个哨兵可以监控同一个redis</li>
<li>基于异步复制 脑裂切换有数据丢失情况</li>
</ul>
<h3 id="2-3-redis-自带集群模式"><a href="#2-3-redis-自带集群模式" class="headerlink" title="2.3 redis 自带集群模式"></a>2.3 redis 自带集群模式</h3><ul>
<li>多master节点 通过hash算法落点到具体的slot master节点上</li>
<li>此集群模式 一般用于三主三从架构</li>
<li>slave节点用于备份master节点数据 </li>
<li>当master节点发生故障时 自动切换到slave节点</li>
<li>基于异步复制 主从切换有数据丢失情况</li>
</ul>
<h2 id="第三章节"><a href="#第三章节" class="headerlink" title="第三章节"></a>第三章节</h2><ul>
<li>redis高级特性<ul>
<li>3.1 redis 持久化</li>
<li>3.2 redis 淘汰机制</li>
<li>3.3 redis 穿透雪崩场景</li>
</ul>
</li>
</ul>
<h3 id="3-1-redis-持久化"><a href="#3-1-redis-持久化" class="headerlink" title="3.1 redis 持久化"></a>3.1 redis 持久化</h3><ul>
<li>redis 支持两种持久化方式 rdb aof</li>
<li>rdb 存储简单 便于备份 启动效率高 性能高 fork子进程来同步</li>
<li>rdb 同步由于由子进程来同步 无法做到实时同步</li>
<li>aof 存储为日志操作形式记录 数据安全性高 有同步策略 更高数据完整性跟一致性</li>
<li>aof 由于同步策略(每秒同步 每修改同步 不同步) aof在运行效率上往往会慢于rdb 且文件大于rdb</li>
<li>aof文件会越来越大 数据恢复也会越来越慢 所以rdb在恢复数据时的速度比aof要快</li>
</ul>
<h3 id="3-2-1-redis-淘汰机制"><a href="#3-2-1-redis-淘汰机制" class="headerlink" title="3.2.1 redis 淘汰机制"></a>3.2.1 redis 淘汰机制</h3><ul>
<li>内存的淘汰机制的初衷是为了更好地使用内存 用一定的缓存miss来换取内存的使用效率</li>
<li>在key无限增加的情况下 已无法达到过期失效 超过增加的极端情况</li>
<li>redis自带对key的几种淘汰机制 当然也可以自己通过程序或lua编写淘汰机制</li>
<li>设置参数 maxmemory <byte> maxmemory-policy 策略 即可使用淘汰机制</li>
</ul>
<h3 id="3-2-2-redis-淘汰机制"><a href="#3-2-2-redis-淘汰机制" class="headerlink" title="3.2.2 redis 淘汰机制"></a>3.2.2 redis 淘汰机制</h3><ul>
<li>noeviction 当内存使用达到阈值的时候 所有引起申请内存的命令会报错</li>
<li>allkeys-lru 在主键空间中 优先移除最近未使用的key</li>
<li>volatile-lru 在设置了过期时间的键空间中 优先移除最近未使用的key</li>
<li>allkeys-random 在主键空间中 随机移除某个key</li>
<li>volatile-random 在设置了过期时间的键空间中 随机移除某个key</li>
<li>volatile-ttl 在设置了过期时间的键空间中 具有更早过期时间的key优先移除</li>
</ul>
<h3 id="3-3-redis-穿透雪崩场景"><a href="#3-3-redis-穿透雪崩场景" class="headerlink" title="3.3 redis 穿透雪崩场景"></a>3.3 redis 穿透雪崩场景</h3><ul>
<li>有超时缓存 可采用双重加锁方式 让一个请求执行数据库操作并加入缓存 后续请求获得缓存 </li>
<li>尽可能使用无超时缓存 使用redis 自带的淘汰机制</li>
<li>无超时缓存 使用定时任务 刷新移除缓存</li>
<li>利用各类缓存 如页面 数据库缓存 二级缓存</li>
<li>在redis前加进程缓存 消减redis使用率 通过redis watch机制保证缓存一致性</li>
<li>布隆过滤器 或自定义过滤器 如bitmap hash值占位</li>
<li>空key情况(避免全局扫) 设置默认值或上级缓存或使用过滤器</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo个人博客搭建</title>
    <url>/2019/10/30/md/tool/hexo-next/</url>
    <content><![CDATA[<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="开启本地搜索"><a href="#开启本地搜索" class="headerlink" title="开启本地搜索"></a>开启本地搜索</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span></pre></td></tr></table></figure>
<hr>
<h4 id="添加点击爱心效果"><a href="#添加点击爱心效果" class="headerlink" title="添加点击爱心效果"></a>添加点击爱心效果</h4><p>1、创建js文件<br>在<code>/themes/next/source/js/src</code>下新建文件 clicklove.js ，接着把该链接下的代码拷贝粘贴到 clicklove.js 文件中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span></pre></td></tr></table></figure>


<p>2、修改_layout.swig<br>在<code>\themes\next\layout\_layout.swig</code>文件末尾添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clicklove.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span></pre></td></tr></table></figure>
<hr>
<h4 id="优化文章内链接文本样式"><a href="#优化文章内链接文本样式" class="headerlink" title="优化文章内链接文本样式"></a>优化文章内链接文本样式</h4><p>在<code>next\source\css\_common\components\post\post.styl</code>在末尾添加如下css样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 文章内链接文本样式</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">border-bottom</span>: none;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &amp;:hover &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<hr>
<h4 id="显示文章的字数与阅读时长"><a href="#显示文章的字数与阅读时长" class="headerlink" title="显示文章的字数与阅读时长"></a>显示文章的字数与阅读时长</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span></pre></td></tr></table></figure>

<hr>
<h4 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:zwcy/blog.git</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span></pre></td></tr></table></figure>


<hr>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>java-code-tip</p>
<h4 id="hexo-d后-ERROR-Deployer-not-found-git"><a href="#hexo-d后-ERROR-Deployer-not-found-git" class="headerlink" title="hexo d后 ERROR Deployer not found: git"></a>hexo d后 ERROR Deployer not found: git</h4><p>安装<code>hexo-deployer-git</code>插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span></pre></td></tr></table></figure>

<h4 id="背景动画Canvas-nest-true设置无效的解决方案"><a href="#背景动画Canvas-nest-true设置无效的解决方案" class="headerlink" title="背景动画Canvas_nest: true设置无效的解决方案"></a>背景动画Canvas_nest: true设置无效的解决方案</h4><p>下载<code>canvas-nest</code>插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入next主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd themes/next</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> canvas-nest</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 thems/next/_config.yml文件下修改 canvas_nest: <span class="literal">true</span></span></span></pre></td></tr></table></figure>

<h4 id="git-push-github失败，提示：SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443"><a href="#git-push-github失败，提示：SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443" class="headerlink" title="git push github失败，提示：SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443"></a>git push github失败，提示：SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</h4><blockquote>
<p>登录一下github网页版</p>
</blockquote>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo问题</title>
    <url>/2019/10/30/md/part/distributed/dubbo-problem/</url>
    <content><![CDATA[<h3 id="Dubbo注册中心挂掉之后，是否还可以继续通信？"><a href="#Dubbo注册中心挂掉之后，是否还可以继续通信？" class="headerlink" title="Dubbo注册中心挂掉之后，是否还可以继续通信？"></a>Dubbo注册中心挂掉之后，是否还可以继续通信？</h3><p>  可以的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用</p>
<ul>
<li>注册中心对等集群，任意一台宕掉后，会自动切换到另一台</li>
<li>注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯</li>
<li>服务提供者无状态，任一台 宕机后，不影响使用</li>
<li>服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复</li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>内存屏障</title>
    <url>/2019/10/28/md/jdk/jvm/memoryBarrier/</url>
    <content><![CDATA[<p><strong>内存屏障（Memory barrier）</strong></p>
<h4 id="为什么会有内存屏障"><a href="#为什么会有内存屏障" class="headerlink" title="为什么会有内存屏障"></a>为什么会有内存屏障</h4><ul>
<li>每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。</li>
<li>用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。 </li>
</ul>
<h4 id="内存屏障是什么"><a href="#内存屏障是什么" class="headerlink" title="内存屏障是什么"></a>内存屏障是什么</h4><p>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code>即读屏障和写屏障。<br>内存屏障有两个作用：  </p>
<blockquote>
<p>阻止屏障两侧的指令重排序；  </p>
</blockquote>
<blockquote>
<p>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。  </p>
</blockquote>
<ul>
<li>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</li>
<li>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。  </li>
</ul>
<h4 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h4><p>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p>
<ul>
<li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能  </li>
</ul>
<h4 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h4><p>volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：<br>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p>
<blockquote>
<p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。 </p>
</blockquote>
<h4 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h4><p>对于final域，编译器和CPU会遵循两个排序规则：</p>
<blockquote>
<p> 新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）  </p>
</blockquote>
<blockquote>
<p>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值） </p>
</blockquote>
<p>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</p>
<ul>
<li>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。</li>
<li>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。<br>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。  </li>
</ul>
<blockquote>
<p>volatile和final都使用了内存屏障，只不过volatile有两个保障点，可见性和有序性，可见性是通过缓存锁以及缓存一致性协议控制，有序性是内存屏障来保证。</p>
</blockquote>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>AtomicInteger线程安全</title>
    <url>/2019/10/28/md/jdk/mulThread/AtomicInteger%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>最近面试被问到一个问题，AtomicInteger如何保证线程安全？我查阅了资料 发现还可以引申到 乐观锁/悲观锁的概念，觉得值得一记。</p>
<p>众所周知，JDK提供了AtomicInteger保证对数字的操作是线程安全的，线程安全我首先想到了synchronized和Lock,但是这种方式又有一个名字，叫做互斥锁，一次只能有一个持有锁的线程进入，再加上还有不同线程争夺锁这个机制，效率比较低，所以又称“悲观锁”。</p>
<p>但是相应的有了乐观锁的概念，他的思路就是，它不加锁去完成某项操作，如果因为冲突失败就重试，直到成功为止。这种说的比较抽象，我们直接拿AtomicInteger源码举例，因为AtomicInteger保证线程安全就是因为使用了乐观锁。</p>
<p>Unsafe 是做一些Java语言不允许但是又十分有用的事情，具体的实现都是native方法，AtomicInteger里调用的 Unsafe 方法 基于的是CPU 的 CAS指令来实现的。所以基于 CAS 的操作可认为是无阻塞的，一个线程的失败或挂起不会引起其它线程也失败或挂起。并且由于 CAS 操作是 CPU 原语，所以性能比较好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>CAS就是Compare and Swap的意思，比较并操作。很多的cpu直接支持CAS指令。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 从代码上我们可以看到do while语句，从而证实当更新出现冲突时，即失败时，它还会尝试更新。符合乐观锁的思想。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> var5;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> var5;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>五笔输入常用500字</title>
    <url>/2019/10/25/md/other/input/commonWord/</url>
    <content><![CDATA[<p>的一是了不在有个人这上中大为来我到出要以时和地们得可下对生也子就过能他会多发说而于自之用年行家方后作成开面事好小心前所道法如进着同经分定都然与本还其当起动已两点从问里主实天高去现长此三将无国全文理明日些看只公等十意正外想间把情者没重相那向知因样学应又手但信关使种见力名二处门并口么先位头回话很再由身入内第平被给次别几月真立新通少机打水果最部何安接报声才体今合性西你放表目加常做己老四件解路更走比总金管光工结提任东原便美及教难世至气神山数利书代直色场变记张必受交非服化求风度太万各算边王什快许连五活思该步海指物则女或完马强言条特命感清带认保望转传儿制干计民白住字它义车像反象题却流且即深近形取往系量论告息让决未花收满每华业南觉电空眼听远师元请容她军士百办语期北林识半夫客战院城候单音台死视领失司亲始极双令改功程爱德复切随李员离轻观青足落叫根怎持精送众影八首包准兴红达早尽故房引火站似找备调断设格消拉照布友整术石展紧据终周式举飞片虽易运笑云建谈界务写钱商乐推注越千微若约英集示呢待坐议乎留称品志黑存六造低江念产刻节尔吃势依图共曾响底装具喜严九况跟罗须显热病证刚治绝群市阳确究久除闻答段官政类黄武七支费父统</p>
]]></content>
      <tags>
        <tag>五笔</tag>
      </tags>
  </entry>
  <entry>
    <title>面试又载在jvm上了</title>
    <url>/2019/10/24/md/jdk/jvm/%E9%9D%A2%E8%AF%95%E5%8F%88%E8%BD%BD%E5%9C%A8jvm%E4%B8%8A%E4%BA%86/</url>
    <content><![CDATA[<p>无论什么级别的Java从业者，JVM都是进阶时必须迈过的坎。不管是工作还是面试中，JVM都是必考题。如果不懂JVM的话，薪酬会非常吃亏（近70%的面试者挂在JVM上了）。</p>
<p>掌握了JVM机制，就等于学会了深层次解决问题的方法。对于Java开发者而言，只有熟悉底层虚拟机的运行机制，才能通过JVM日志深入到字节码的层次去分析排查问题，发现隐性的系统缺陷，进而提升系统性能。</p>
<p>一些技术人员开发工具用得很熟练，触及JVM问题时却是模棱两可，甚至连内存模型和内存区域，HotSpot和JVM规范，都混淆不清。工作很长时间，在生产时还在用缺省参数来直接启动，以致系统运行时出现性能、稳定性等问题时束手无措，不知该如何追踪排查。久而久之，这对自己的职业成长是极为不利的。</p>
<p>掌握JVM，是深入Java技术栈的必经之路。</p>
<p><img src="https://www.mqiy.xyz/image/jvm/jvm_outline.png" alt="jv.png"></p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper环境搭建</title>
    <url>/2019/10/22/md/part/mid/zookeeper/zk-run/</url>
    <content><![CDATA[<h2 id="Standalone"><a href="#Standalone" class="headerlink" title="Standalone"></a>Standalone</h2><h3 id="create-it-in-conf-zoo-cfg"><a href="#create-it-in-conf-zoo-cfg" class="headerlink" title="create it in conf/zoo.cfg:"></a>create it in conf/zoo.cfg:</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">dataDir</span>=<span class="string">/var/lib/zookeeper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span></pre></td></tr></table></figure>



<h3 id="start-ZooKeeper"><a href="#start-ZooKeeper" class="headerlink" title="start ZooKeeper"></a>start ZooKeeper</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkServer.sh start</span></pre></td></tr></table></figure>

<h3 id="Connecting-to-ZooKeeper"><a href="#Connecting-to-ZooKeeper" class="headerlink" title="Connecting to ZooKeeper"></a>Connecting to ZooKeeper</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkCli.sh -server 127.0.0.1:2181</span></pre></td></tr></table></figure>


<h2 id="Running-Replicated-ZooKeeper"><a href="#Running-Replicated-ZooKeeper" class="headerlink" title="Running Replicated ZooKeeper"></a>Running Replicated ZooKeeper</h2><p>For replicated mode, a minimum of three servers are required, and it is strongly recommended that you have an odd number of servers</p>
<h3 id="create-it-in-conf-zoo-cfg-1"><a href="#create-it-in-conf-zoo-cfg-1" class="headerlink" title="create it in conf/zoo.cfg"></a>create it in conf/zoo.cfg</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">结点1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">dataDir</span>=<span class="string">/var/lib/zookeeper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">initLimit</span>=<span class="string">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">syncLimit</span>=<span class="string">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.1</span>=<span class="string">192.168.85.134:2888:3888</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.2</span>=<span class="string">192.168.85.135:2888:3888</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.3</span>=<span class="string">0.0.0.0:2888:3888</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">echo</span> <span class="string">1 &gt; /var/lib/zookeeper/myid</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">结点2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">tickTime</span>=<span class="string">200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">dataDir</span>=<span class="string">/var/lib/zookeeper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">initLimit</span>=<span class="string">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">syncLimit</span>=<span class="string">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.1</span>=<span class="string">192.168.85.134:2888:3888</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.2</span>=<span class="string">0.0.0.0:2888:3888</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.3</span>=<span class="string">192.168.85.136:2888:3888</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">echo</span> <span class="string">2 &gt; /var/lib/zookeeper/myid</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">结点3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">dataDir</span>=<span class="string">/var/lib/zookeeper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">initLimit</span>=<span class="string">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">syncLimit</span>=<span class="string">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.1</span>=<span class="string">192.168.85.134:2888:3888</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.2</span>=<span class="string">192.168.85.135:2888:3888</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.3</span>=<span class="string">0.0.0.0:2888:3888</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">echo</span> <span class="string">3 &gt; /var/lib/zookeeper/myid</span></span></pre></td></tr></table></figure>

<blockquote>
<p>注意服务器防火墙是否开启</p>
</blockquote>
<h4 id="Cannot-open-channel-to-2-at-election-address-192-168-85-135-3888"><a href="#Cannot-open-channel-to-2-at-election-address-192-168-85-135-3888" class="headerlink" title="Cannot open channel to 2 at election address /192.168.85.135:3888"></a>Cannot open channel to 2 at election address /192.168.85.135:3888</h4><p>initLimit=5<br>syncLimit=2<br>server.1=192.168.85.144:2888:3888<br>server.2=192.168.85.145:2888:3888<br>server.3=192.168.85.146:2888:3888</p>
<p><code>解决</code>：   must specify 0.0.0.0 for the current node </p>
<h4 id="修改占用8080端口"><a href="#修改占用8080端口" class="headerlink" title="修改占用8080端口"></a>修改占用8080端口</h4><p>zookeeper最近的版本中有个内嵌的管理控制台是通过jetty启动，也会占用8080 端口。<br>通过查看zookeeper的官方文档，发现有3种解决途径：</p>
<ul>
<li>删除jetty。</li>
<li>修改端口。<blockquote>
<p>修改方法的方法有两种，一种是在启动脚本中增加 -Dzookeeper.admin.serverPort=你的端口号.<br>一种是在zoo.cfg中增加admin.serverPort=没有被占用的端口号</p>
</blockquote>
</li>
<li>停用这个服务，在启动脚本中增加”-Dzookeeper.admin.enableServer=false”</li>
</ul>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>蚂蚁、头条、拼多多的面试总结</title>
    <url>/2019/10/21/md/interview/2019alipay-pinduoduo-toutiao/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#写在2019年后的蚂蚁头条拼多多的面试总结">写在2019年后的蚂蚁、头条、拼多多的面试总结</a><ul>
<li><a href="#准备过程">准备过程</a></li>
<li><a href="#蚂蚁金服">蚂蚁金服</a><ul>
<li><a href="#一面">一面</a></li>
<li><a href="#二面">二面</a></li>
<li><a href="#三面">三面</a></li>
<li><a href="#四面">四面</a></li>
<li><a href="#五面">五面</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#拼多多">拼多多</a><ul>
<li><a href="#面试前">面试前</a></li>
<li><a href="#一面-1">一面</a></li>
<li><a href="#二面-1">二面</a></li>
<li><a href="#三面-1">三面</a></li>
<li><a href="#小结-1">小结</a></li>
</ul>
</li>
<li><a href="#字节跳动">字节跳动</a><ul>
<li><a href="#面试前-1">面试前</a></li>
<li><a href="#一面-2">一面</a></li>
<li><a href="#二面-2">二面</a></li>
<li><a href="#小结-2">小结</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="2019年蚂蚁金服、头条、拼多多的面试总结"><a href="#2019年蚂蚁金服、头条、拼多多的面试总结" class="headerlink" title="2019年蚂蚁金服、头条、拼多多的面试总结"></a>2019年蚂蚁金服、头条、拼多多的面试总结</h1><p>文章有点长，请耐心看完，绝对有收获！不想听我BB直接进入面试分享：</p>
<ul>
<li>准备过程</li>
<li>蚂蚁金服面试分享</li>
<li>拼多多面试分享</li>
<li>字节跳动面试分享</li>
<li>总结</li>
</ul>
<p>说起来开始进行面试是年前倒数第二周，上午9点，我还在去公司的公交上，突然收到蚂蚁的面试电话，其实算不上真正的面试。面试官只是和我聊了下他们在做的事情（主要是做双十一这里大促的稳定性保障，偏中间件吧），说的很详细，然后和我沟通了下是否有兴趣，我表示有兴趣，后面就收到正式面试的通知，最后没选择去蚂蚁表示抱歉。</p>
<p>当时我自己也准备出去看看机会，顺便看看自己的实力。当时我其实挺纠结的，一方面现在部门也正需要我，还是可以有一番作为的，另一方面觉得近一年来进步缓慢，没有以前飞速进步的成就感了，而且业务和技术偏于稳定，加上自己也属于那种比较懒散的人，骨子里还是希望能够突破现状，持续在技术上有所精进。</p>
<p>在开始正式的总结之前，还是希望各位同仁能否听我继续发泄一会，抱拳！</p>
<p>我翻开自己2018年初立的flag，觉得甚是惭愧。其中就有一条是保持一周写一篇博客，奈何中间因为各种原因没能坚持下去。细细想来，主要是自己没能真正静下来心认真投入到技术的研究和学习，那么为什么会这样？说白了还是因为没有确定目标或者目标不明确，没有目标或者目标不明确都可能导致行动的失败。</p>
<p>那么问题来了，目标是啥？就我而言，短期目标是深入研究某一项技术，比如最近在研究mysql，那么深入研究一定要动手实践并且有所产出，这就够了么？还需要我们能够举一反三，结合实际开发场景想一想日常开发要注意什么，这中间有没有什么坑？可以看出，要进步真的不是一件简单的事，这种反人类的行为需要我们克服自我的弱点，逐渐形成习惯。真正牛逼的人，从不觉得认真学习是一件多么难的事，因为这已经形成了他的习惯，就喝早上起床刷牙洗脸那么自然简单。</p>
<p>扯了那么多，开始进入正题，先后进行了蚂蚁、拼多多和字节跳动的面试。</p>
<h2 id="准备过程"><a href="#准备过程" class="headerlink" title="准备过程"></a>准备过程</h2><p>先说说我自己的情况，我2016先在蚂蚁实习了将近三个月，然后去了我现在的老东家，2.5年工作经验，可以说毕业后就一直老老实实在老东家打怪升级，虽说有蚂蚁的实习经历，但是因为时间太短，还是有点虚的。所以面试官看到我简历第一个问题绝对是这样的。</p>
<p>“哇，你在蚂蚁待过，不错啊”，面试官笑嘻嘻地问到。“是的，还好”，我说。“为啥才三个月？”，面试官脸色一沉问到。“哗啦啦解释一通。。。”，我解释道。“哦，原来如此，那我们开始面试吧”，面试官一本正经说到。</p>
<p>尼玛，早知道不写蚂蚁的实习经历了，后面仔细一想，当初写上蚂蚁不就给简历加点料嘛。</p>
<p>言归正传，准备过程其实很早开始了（当然这不是说我工作时老想着跳槽，因为我明白现在的老东家并不是终点，我还需要不断提升），具体可追溯到从蚂蚁离职的时候，当时出来也面了很多公司，没啥大公司，面了大概5家公司，都拿到offer了。</p>
<p>工作之余常常会去额外研究自己感兴趣的技术以及工作用到的技术，力求把原理搞明白，并且会自己实践一把。此外，买了N多书，基本有时间就会去看，补补基础，什么操作系统、数据结构与算法、MySQL、JDK之类的源码，基本都好好温习了（文末会列一下自己看过的书和一些好的资料）。<strong>我深知基础就像“木桶效应”的短板，决定了能装多少水。</strong></p>
<p>此外，在正式决定看机会之前，我给自己列了一个提纲，主要包括Java要掌握的核心要点，有不懂的就查资料搞懂。我给自己定位还是Java工程师，所以Java体系是一定要做到心中有数的，很多东西没有常年的积累面试的时候很容易露馅，学习要对得起自己，不要骗人。</p>
<p>剩下的就是找平台和内推了，除了蚂蚁，头条和拼多多都是找人内推的，感谢蚂蚁面试官对我的欣赏，以后说不定会去蚂蚁咯😄。</p>
<p>平台：脉脉、GitHub、v2</p>
<h2 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/zsXjkGNcic53JMPc0FUw1lBXl5iaibrEXvt9qal7lJSgfGJ8mq00yE1J4UQ9H1oo9t6RAL4T3whhx17TYlj1mjlXA/?wx_fmt=jpeg" alt="img"></p>
<ul>
<li>一面</li>
<li>二面</li>
<li>三面</li>
<li>四面</li>
<li>五面</li>
<li>小结</li>
</ul>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面就做了一道算法题，要求两小时内完成，给了长度为N的有重复元素的数组，要求输出第10大的数。典型的TopK问题，快排算法搞定。</p>
<p>算法题要注意的是合法性校验、边界条件以及异常的处理。另外，如果要写测试用例，一定要保证测试覆盖场景尽可能全。加上平时刷刷算法题，这种考核应该没问题的。</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul>
<li>自我介绍下呗</li>
<li>开源项目贡献过代码么？（Dubbo提过一个打印accesslog的bug算么）</li>
<li>目前在部门做什么，业务简单介绍下，内部有哪些系统，作用和交互过程说下</li>
<li>Dubbo踩过哪些坑，分别是怎么解决的？（说了异常处理时业务异常捕获的问题，自定义了一个异常拦截器）</li>
<li>开始进入正题，说下你对线程安全的理解（多线程访问同一个对象，如果不需要考虑额外的同步，调用对象的行为就可以获得正确的结果就是线程安全）</li>
<li>事务有哪些特性？（ACID）</li>
<li>怎么理解原子性？（同一个事务下，多个操作要么成功要么失败，不存在部分成功或者部分失败的情况）</li>
<li>乐观锁和悲观锁的区别？（悲观锁假定会发生冲突，访问的时候都要先获得锁，保证同一个时刻只有线程获得锁，读读也会阻塞；乐观锁假设不会发生冲突，只有在提交操作的时候检查是否有冲突）这两种锁在Java和MySQL分别是怎么实现的？（Java乐观锁通过CAS实现，悲观锁通过synchronize实现。mysql乐观锁通过MVCC，也就是版本实现，悲观锁可以通过select… for update加上排它锁） </li>
<li>HashMap为什么不是线程安全的？（多线程操作无并发控制，顺便说了在扩容的时候多线程访问时会造成死锁，会形成一个环，不过扩容时多线程操作形成环的问题再JDK1.8已经解决，但多线程下使用HashMap还会有一些其他问题比如数据丢失，所以多线程下不应该使用HashMap，而应该使用ConcurrentHashMap）怎么让HashMap变得线程安全？(Collections的synchronize方法包装一个线程安全的Map，或者直接用ConcurrentHashMap)两者的区别是什么？（前者直接在put和get方法加了synchronize同步，后者采用了分段锁以及CAS支持更高的并发）</li>
<li>jdk1.8对ConcurrentHashMap做了哪些优化？（插入的时候如果数组元素使用了红黑树，取消了分段锁设计，synchronize替代了Lock锁）为什么这样优化？（避免冲突严重时链表多长，提高查询效率，时间复杂度从O(N)提高到O(logN)）</li>
<li>redis主从机制了解么？怎么实现的？</li>
<li>有过GC调优的经历么？（有点虚，答得不是很好）</li>
<li>有什么想问的么？</li>
</ul>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ul>
<li>简单自我介绍下</li>
<li>监控系统怎么做的，分为哪些模块，模块之间怎么交互的？用的什么数据库？（MySQL）使用什么存储引擎，为什么使用InnnoDB？(支持事务、聚簇索引、MVCC)</li>
<li>订单表有做拆分么，怎么拆的？(垂直拆分和水平拆分)</li>
<li>水平拆分后查询过程描述下</li>
<li>如果落到某个分片的数据很大怎么办？(按照某种规则，比如哈希取模、range，将单张表拆分为多张表)</li>
<li>哈希取模会有什么问题么？(有的，数据分布不均，扩容缩容相对复杂 )</li>
<li>分库分表后怎么解决读写压力？(一主多从、多主多从)</li>
<li>拆分后主键怎么保证惟一？(UUID、Snowflake算法)</li>
<li>Snowflake生成的ID是全局递增唯一么？(不是，只是全局唯一，单机递增)</li>
<li>怎么实现全局递增的唯一ID？(讲了TDDL的一次取一批ID，然后再本地慢慢分配的做法)</li>
<li>Mysql的索引结构说下(说了B+树，B+树可以对叶子结点顺序查找，因为叶子结点存放了数据结点且有序)</li>
<li>主键索引和普通索引的区别(主键索引的叶子结点存放了整行记录，普通索引的叶子结点存放了主键ID，查询的时候需要做一次回表查询)一定要回表查询么？(不一定，当查询的字段刚好是索引的字段或者索引的一部分，就可以不用回表，这也是索引覆盖的原理)</li>
<li>你们系统目前的瓶颈在哪里？</li>
<li>你打算怎么优化？简要说下你的优化思路</li>
<li>有什么想问我么？</li>
</ul>
<h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><ul>
<li>介绍下自己</li>
<li>为什么要做逆向？</li>
<li>怎么理解微服务？</li>
<li>服务治理怎么实现的？(说了限流、压测、监控等模块的实现)</li>
<li>这个不是中间件做的事么，为什么你们部门做？(当时没有单独的中间件团队，微服务刚搞不久，需要进行监控和性能优化)</li>
<li>说说Spring的生命周期吧</li>
<li>说说GC的过程(说了young gc和full gc的触发条件和回收过程以及对象创建的过程)</li>
<li>CMS GC有什么问题？(并发清除算法，浮动垃圾，短暂停顿)</li>
<li>怎么避免产生浮动垃圾？(记得有个VM参数设置可以让扫描新生代之前进行一次young gc，但是因为gc是虚拟机自动调度的，所以不保证一定执行。但是还有参数可以让虚拟机强制执行一次young gc)</li>
<li>强制young gc会有什么问题？(STW停顿时间变长)</li>
<li>知道G1么？(了解一点 )</li>
<li>回收过程是怎么样的？(young gc、并发阶段、混合阶段、full gc，说了Remember Set)</li>
<li>你提到的Remember Set底层是怎么实现的？</li>
<li>有什么想问的么？</li>
</ul>
<h3 id="五面"><a href="#五面" class="headerlink" title="五面"></a>五面</h3><p>五面是HRBP面的，和我提前预约了时间，主要聊了之前在蚂蚁的实习经历、部门在做的事情、职业发展、福利待遇等。阿里面试官确实是具有一票否决权的，很看重你的价值观是否match，一般都比较喜欢皮实的候选人。HR面一定要诚实，不要说谎，只要你说谎HR都会去证实，直接cut了。</p>
<ul>
<li>之前蚂蚁实习三个月怎么不留下来？</li>
<li>实习的时候主管是谁？</li>
<li>实习做了哪些事情？（尼玛这种也问？）</li>
<li>你对技术怎么看？平时使用什么技术栈？（阿里HR真的是既当爹又当妈，😂）</li>
<li>最近有在研究什么东西么</li>
<li>你对SRE怎么看</li>
<li>对待遇有什么预期么</li>
</ul>
<p>最后HR还对我说目前稳定性保障部挺缺人的，希望我尽快回复。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>蚂蚁面试比较重视基础，所以Java那些基本功一定要扎实。蚂蚁的工作环境还是挺赞的，因为我面的是稳定性保障部门，还有许多单独的小组，什么三年1班，很有青春的感觉。面试官基本水平都比较高，基本都P7以上，除了基础还问了不少架构设计方面的问题，收获还是挺大的。</p>
<h2 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/zsXjkGNcic53JMPc0FUw1lBXl5iaibrEXvtsmoh9TdJcV0hwnrjtbWPdOacyj2uYe2qaI5jvlGIQHwYtknwnGTibbQ/?wx_fmt=jpeg" alt="img"></p>
<ul>
<li>面试前</li>
<li>一面</li>
<li>二面</li>
<li>三面</li>
<li>小结</li>
</ul>
<h3 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h3><p>面完蚂蚁后，早就听闻拼多多这个独角兽，决定也去面一把。首先我在脉脉找了一个拼多多的HR，加了微信聊了下，发了简历便开始我的拼多多面试之旅。这里要非常感谢拼多多HR小姐姐，从面试内推到offer确认一直都在帮我，人真的很nice。</p>
<h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ul>
<li>为啥蚂蚁只待了三个月？没转正？(转正了，解释了一通。。。)</li>
<li>Java中的HashMap、TreeMap解释下？(TreeMap红黑树，有序，HashMap无序，数组+链表)</li>
<li>TreeMap查询写入的时间复杂度多少？(O(logN))</li>
<li>HashMap多线程有什么问题？(线程安全，死锁)怎么解决？( jdk1.8用了synchronize + CAS，扩容的时候通过CAS检查是否有修改，是则重试)重试会有什么问题么？(CAS（Compare And Swap）是比较和交换，不会导致线程阻塞，但是因为重试是通过自旋实现的，所以仍然会占用CPU时间，还有ABA的问题)怎么解决？(超时，限定自旋的次数，ABA可以通过原理变量AtomicStampedReference解决，原理利用版本号进行比较)超过重试次数如果仍然失败怎么办？(synchronize互斥锁)</li>
<li>CAS和synchronize有什么区别？都用synchronize不行么？(CAS是乐观锁，不需要阻塞，硬件级别实现的原子性；synchronize会阻塞，JVM级别实现的原子性。使用场景不同，线程冲突严重时CAS会造成CPU压力过大，导致吞吐量下降，synchronize的原理是先自旋然后阻塞，线程冲突严重仍然有较高的吞吐量，因为线程都被阻塞了，不会占用CPU<br>)</li>
<li>如果要保证线程安全怎么办？(ConcurrentHashMap)</li>
<li>ConcurrentHashMap怎么实现线程安全的？(分段锁)</li>
<li>get需要加锁么，为什么？(不用，volatile关键字)</li>
<li>volatile的作用是什么？(保证内存可见性)</li>
<li>底层怎么实现的？(说了主内存和工作内存，读写内存屏障，happen-before，并在纸上画了线程交互图)</li>
<li>在多核CPU下，可见性怎么保证？(思考了一会，总线嗅探技术)</li>
<li>聊项目，系统之间是怎么交互的？</li>
<li>系统并发多少，怎么优化？</li>
<li>给我一张纸，画了一个九方格，都填了数字，给一个M<em>N矩阵，从1开始逆时针打印这M</em>N个数，要求时间复杂度尽可能低（内心OS：之前貌似碰到过这题，最优解是怎么实现来着）思考中。。。</li>
<li>可以先说下你的思路(想起来了，说了什么时候要变换方向的条件，向右、向下、向左、向上，依此循环)</li>
<li>有什么想问我的？</li>
</ul>
<h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ul>
<li>自我介绍下</li>
<li>手上还有其他offer么？(拿了蚂蚁的offer)</li>
<li>部门组织结构是怎样的？(这轮不是技术面么，不过还是老老实实说了)</li>
<li>系统有哪些模块，每个模块用了哪些技术，数据怎么流转的？（面试官有点秃顶，一看级别就很高）给了我一张纸，我在上面简单画了下系统之间的流转情况</li>
<li>链路追踪的信息是怎么传递的？(RpcContext的attachment，说了Span的结构:parentSpanId + curSpanId)</li>
<li>SpanId怎么保证唯一性？(UUID，说了下内部的定制改动)</li>
<li>RpcContext是在什么维度传递的？(线程)</li>
<li>Dubbo的远程调用怎么实现的？(讲了读取配置、拼装url、创建Invoker、服务导出、服务注册以及消费者通过动态代理、filter、获取Invoker列表、负载均衡等过程（哗啦啦讲了10多分钟），我可以喝口水么)</li>
<li>Spring的单例是怎么实现的？(单例注册表)</li>
<li>为什么要单独实现一个服务治理框架？(说了下内部刚搞微服务不久，主要对服务进行一些监控和性能优化)</li>
<li>谁主导的？内部还在使用么？ </li>
<li>逆向有想过怎么做成通用么？</li>
<li>有什么想问的么？</li>
</ul>
<h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><p>二面老大面完后就直接HR面了，主要问了些职业发展、是否有其他offer、以及入职意向等问题，顺便说了下公司的福利待遇等，都比较常规啦。不过要说的是手上有其他offer或者大厂经历会有一定加分。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>拼多多的面试流程就简单许多，毕竟是一个成立三年多的公司。面试难度中规中矩，只要基础扎实应该不是问题。但不得不说工作强度很大，开始面试前HR就提前和我确认能否接受这样强度的工作，想来的老铁还是要做好准备</p>
<h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/zsXjkGNcic53JMPc0FUw1lBXl5iaibrEXvtRoTSCMeUWramk7M4CekxE9ssH5DFGBxmDcw0x9hjzmbIGHVWenDK8w/?wx_fmt=jpeg" alt="img"></p>
<ul>
<li>面试前</li>
<li>一面</li>
<li>二面</li>
<li>小结</li>
</ul>
<h3 id="面试前-1"><a href="#面试前-1" class="headerlink" title="面试前"></a>面试前</h3><p>头条的面试是三家里最专业的，每次面试前有专门的HR和你约时间，确定OK后再进行面试。每次都是通过视频面试，因为都是之前都是电话面或现场面，所以视频面试还是有点不自然。也有人觉得视频面试体验很赞，当然萝卜青菜各有所爱。最坑的二面的时候对方面试官的网络老是掉线，最后很冤枉的挂了（当然有一些点答得不好也是原因之一）。所以还是有点遗憾的。</p>
<h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><ul>
<li>先自我介绍下</li>
<li>聊项目，逆向系统是什么意思</li>
<li>聊项目，逆向系统用了哪些技术</li>
<li>线程池的线程数怎么确定？</li>
<li>如果是IO操作为主怎么确定？</li>
<li>如果计算型操作又怎么确定？</li>
<li>Redis熟悉么，了解哪些数据结构?(说了zset) zset底层怎么实现的?(跳表)</li>
<li>跳表的查询过程是怎么样的，查询和插入的时间复杂度?(说了先从第一层查找，不满足就下沉到第二层找，因为每一层都是有序的，写入和插入的时间复杂度都是O(logN))</li>
<li>红黑树了解么，时间复杂度?(说了是N叉平衡树，O(logN))</li>
<li>既然两个数据结构时间复杂度都是O(logN)，zset为什么不用红黑树(跳表实现简单，踩坑成本低，红黑树每次插入都要通过旋转以维持平衡，实现复杂)</li>
<li>点了点头，说下Dubbo的原理?(说了服务注册与发布以及消费者调用的过程)踩过什么坑没有？（说了dubbo异常处理的和打印accesslog的问题）</li>
<li>CAS了解么？（说了CAS的实现）还了解其他同步机制么？（说了synchronize以及两者的区别，一个乐观锁，一个悲观锁）</li>
<li>那我们做一道题吧，数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数</li>
<li>先说下你的思路（从0下标开始遍历，如果是奇数下标判断该元素是否奇数，是则跳过，否则从该位置寻找下一个奇数）</li>
<li>下一个奇数？怎么找？（有点懵逼，思考中。。）</li>
<li>有思路么？（仍然是先遍历一次数组，并对下标进行判断，如果下标属性和该位置元素不匹配从当前下标的下一个遍历数组元素，然后替换）</li>
<li>你这样时间复杂度有点高，如果要求O(N)要怎么做（思考一会，答道“定义两个指针，分别从下标0和1开始遍历，遇见奇数位是是偶数和偶数位是奇数就停下，交换内容”）</li>
<li>时间差不多了，先到这吧。你有什么想问我的？</li>
</ul>
<h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><ul>
<li>面试官和蔼很多，你先介绍下自己吧</li>
<li>你对服务治理怎么理解的？</li>
<li>项目中的限流怎么实现的？（Guava ratelimiter，令牌桶算法）</li>
<li>具体怎么实现的？（要点是固定速率且令牌数有限）</li>
<li>如果突然很多线程同时请求令牌，有什么问题？（导致很多请求积压，线程阻塞）</li>
<li>怎么解决呢？（可以把积压的请求放到消息队列，然后异步处理）</li>
<li>如果不用消息队列怎么解决？（说了RateLimiter预消费的策略）</li>
<li>分布式追踪的上下文是怎么存储和传递的？（ThreadLocal + spanId，当前节点的spanId作为下个节点的父spanId）</li>
<li>Dubbo的RpcContext是怎么传递的？（ThreadLocal）主线程的ThreadLocal怎么传递到线程池？（说了先在主线程通过ThreadLocal的get方法拿到上下文信息，在线程池创建新的ThreadLocal并把之前获取的上下文信息设置到ThreadLocal中。这里要注意的线程池创建的ThreadLocal要在finally中手动remove，不然会有内存泄漏的问题）</li>
<li>你说的内存泄漏具体是怎么产生的？（说了ThreadLocal的结构，主要分两种场景：主线程仍然对ThreadLocal有引用和主线程不存在对ThreadLocal的引用。第一种场景因为主线程仍然在运行，所以还是有对ThreadLocal的引用，那么ThreadLocal变量的引用和value是不会被回收的。第二种场景虽然主线程不存在对ThreadLocal的引用，且该引用是弱引用，所以会在gc的时候被回收，但是对用的value不是弱引用，不会被内存回收，仍然会造成内存泄漏）</li>
<li>线程池的线程是不是必须手动remove才可以回收value？（是的，因为线程池的核心线程是一直存在的，如果不清理，那么核心线程的threadLocals变量会一直持有ThreadLocal变量）</li>
<li>那你说的内存泄漏是指主线程还是线程池？（主线程 ）</li>
<li>可是主线程不是都退出了，引用的对象不应该会主动回收么？（面试官和内存泄漏杠上了），沉默了一会。。。</li>
<li>那你说下SpringMVC不同用户登录的信息怎么保证线程安全的？（刚才解释的有点懵逼，一下没反应过来，居然回答成锁了。大脑有点晕了，此时已经一个小时过去了，感觉情况不妙。。。）</li>
<li>这个直接用ThreadLocal不就可以么，你见过SpringMVC有锁实现的代码么？（有点晕菜。。。）</li>
<li>我们聊聊mysql吧，说下索引结构（说了B+树）</li>
<li>为什么使用B+树？（ 说了查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据）</li>
<li>什么是索引覆盖？（忘记了。。。 ）</li>
<li>Java为什么要设计双亲委派模型？</li>
<li>什么时候需要自定义类加载器？</li>
<li>我们做一道题吧，手写一个对象池</li>
<li>有什么想问我的么？（感觉我很多点都没答好，是不是挂了（结果真的是） ）</li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>头条的面试确实很专业，每次面试官会提前给你发一个视频链接，然后准点开始面试，而且考察的点都比较全。</p>
<p>面试官都有一个特点，会抓住一个值得深入的点或者你没说清楚的点深入下去直到你把这个点讲清楚，不然面试官会觉得你并没有真正理解。二面面试官给了我一点建议，研究技术的时候一定要去研究产生的背景，弄明白在什么场景解决什么特定的问题，其实很多技术内部都是相通的。很诚恳，还是很感谢这位面试官大大。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从年前开始面试到头条面完大概一个多月的时间，真的有点身心俱疲的感觉。最后拿到了拼多多、蚂蚁的offer，还是蛮幸运的。头条的面试对我帮助很大，再次感谢面试官对我的诚恳建议，以及拼多多的HR对我的啰嗦的问题详细解答。</p>
<p>这里要说的是面试前要做好两件事：简历和自我介绍，简历要好好回顾下自己做的一些项目，然后挑几个亮点项目。自我介绍基本每轮面试都有，所以最好提前自己练习下，想好要讲哪些东西，分别怎么讲。此外，简历提到的技术一定是自己深入研究过的，没有深入研究也最好找点资料预热下，不打无准备的仗。</p>
<p><strong>这些年看过的书</strong>：</p>
<p>《Effective Java》、《现代操作系统》、《TCP/IP详解：卷一》、《代码整洁之道》、《重构》、《Java程序性能优化》、《Spring实战》、《Zookeeper》、《高性能MySQL》、《亿级网站架构核心技术》、《可伸缩服务架构》、《Java编程思想》</p>
<p>说实话这些书很多只看了一部分，我通常会带着问题看书，不然看着看着就睡着了，简直是催眠良药😅。</p>
<p>最后，附一张自己面试前准备的脑图：</p>
<p>链接:<a href="https://pan.baidu.com/s/1o2l1tuRakBEP0InKEh4Hzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1o2l1tuRakBEP0InKEh4Hzw</a> 密码:300d</p>
<p>全文完。</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2019/10/21/md/part/distributed/distribute-lock/</url>
    <content><![CDATA[<p>三种实现：</p>
<ul>
<li>基于数据库实现分布式锁</li>
<li>基于缓存（redis，memcached，tair）实现分布式锁</li>
<li>基于Zookeeper实现分布式锁</li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>es介绍</title>
    <url>/2019/10/17/md/part/mid/es/es-outline/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>ElasticSearch 是一个<code>分布式</code>、<code>高扩展</code>、<code>高实时</code>的<code>搜索与数据分析引擎</code>。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用ElasticSearch的水平伸缩性，能使数据在生产环境变得更有价值。ElasticSearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到Elastic Search 数据库中，再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。<br>Elasticsearch是与名为Logstash的数据收集和日志解析引擎以及名为Kibana的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”（以前称为“ELK stack”）。<br>Elasticsearch可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。”Elasticsearch是分布式的，这意味着索引可以被分成分片，每个分片可以有0个或多个副本。每个节点托管一个或多个分片，并充当协调器将操作委托给正确的分片。再平衡和路由是自动完成的。“相关数据通常存储在同一个索引中，该索引由一个或多个主分片和零个或多个复制分片组成。一旦创建了索引，就不能更改主分片的数量。<br>Elasticsearch使用Lucene，并试图通过JSON和Java API提供其所有特性。它支持facetting和percolating，如果新文档与注册查询匹配，这对于通知非常有用。另一个特性称为“网关”，处理索引的长期持久性；例如，在服务器崩溃的情况下，可以从网关恢复索引。Elasticsearch支持<code>实时GET</code>请求，适合作为NoSQL数据存储，但<code>缺少分布式事务</code>。</p>
<p>Lucene[‘lusen]</p>
<h3 id="有关概念"><a href="#有关概念" class="headerlink" title="有关概念"></a>有关概念</h3><ul>
<li>cluster：代表一个<a href="https://baike.baidu.com/item/集群" target="_blank" rel="noopener">集群</a>，集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</li>
<li>shards：代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</li>
<li>replicas：代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的<a href="https://baike.baidu.com/item/容错性" target="_blank" rel="noopener">容错性</a>，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</li>
<li>recovery：代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</li>
<li>river：代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。</li>
<li>gateway：代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），<a href="https://baike.baidu.com/item/分布式文件系统" target="_blank" rel="noopener">分布式文件系统</a>，Hadoop的HDFS和amazon的s3<a href="https://baike.baidu.com/item/云存储" target="_blank" rel="noopener">云存储</a>服务。</li>
<li>discovery.zen：代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过<a href="https://baike.baidu.com/item/多播" target="_blank" rel="noopener">多播</a>协议来进行节点之间的通信，同时也支持<a href="https://baike.baidu.com/item/点对点" target="_blank" rel="noopener">点对点</a>的交互。</li>
<li>Transport：代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、<a href="https://baike.baidu.com/item/thrift" target="_blank" rel="noopener">thrift</a>、servlet、memcached、zeroMQ等的<a href="https://baike.baidu.com/item/传输协议" target="_blank" rel="noopener">传输协议</a>（通过<a href="https://baike.baidu.com/item/插件" target="_blank" rel="noopener">插件</a>方式集成）。</li>
</ul>
<p><code>主节点</code>负责创建索引、删除索引、分配分片、追踪集群中的节点状态等工作</p>
<p>Elasticsearch中的主节点的工作量相对较轻，用户的请求可以发往任何一个节点，由该节点负责分发和返回结果，而不需要经过主节点转发</p>
<p>如果单个node分配多个shard，就会引入另外一系列的性能问题，我们知道对于任意一次完整的搜索，ElasticSearch会分别对每个shard进行查询，最后进行汇总。当节点数和shard数是一对一的时候，所有的查询可以并行运行。但是，对于具有多个shard的节点，如果磁盘是15000RPM或SSD，可能会相对较快，但是这也会存在等待响应的问题，所以通常不推荐一个节点超过2个shard。</p>
<p>但是如果一个小集群，就10个以内的节点，那就所有节点都可以作为master eligible node以及data node即可，超过10个node的集群再单独拆分master和data node吧  </p>
<p>如果你的节点数量小于10个，小集群，那所有的node，就不要做额外的配置了，master eligible node，同时也是data node</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引源于实际应用中需要<code>根据属性的值来查找记录</code>。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由<code>属性值来确定记录的位置</code>，因而称为倒排索引(inverted index)。带有倒排索引的文件我们称为倒排索引文件，简称倒排文件(inverted file)。</p>
<p>倒排索引就是关键词到文档 ID 的映射</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>常用解惑</title>
    <url>/2019/10/09/md/jdk/other/</url>
    <content><![CDATA[<h3 id="for-和while-true-的区别"><a href="#for-和while-true-的区别" class="headerlink" title="for(;;)和while(true)的区别"></a>for(;;)和while(true)的区别</h3><p>总结 for(;;) 比 while(true) 好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 编译前              编译后 </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)         mov eax,<span class="number">1</span>  </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    test eax,eax </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    je foo+<span class="number">23</span>h</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    jmp foo+<span class="number">18</span>h</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//VS                 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">编译前              编译后 </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;)          jmp foo+<span class="number">23</span>h</span></pre></td></tr></table></figure>

<p>对比之下，for (；；)指令少，不占用<code>寄存器</code>，而且没有判断跳转，比while (1)好。</p>
<p>也就是说两者在在宏观上完全一样的逻辑，但是底层完全不一样，for相对于来说更加简洁明</p>
<hr>
]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2019/09/25/md/part/system/linux/linux-common-command/</url>
    <content><![CDATA[<h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><p>find / -name my.cnf </p>
<h4 id="修改文件归属用户与用户组"><a href="#修改文件归属用户与用户组" class="headerlink" title="修改文件归属用户与用户组"></a>修改文件归属用户与用户组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改文件归属用户  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">chown -R hdh elasticsearch-7.3.2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改文件归属用户组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">chgrp -R hdh elasticsearch-7.3.2</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2019/09/24/md/tool/maven/</url>
    <content><![CDATA[<h3 id="run命令"><a href="#run命令" class="headerlink" title="run命令"></a>run命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar -Dmaven.test.skip=true</span></pre></td></tr></table></figure>



<h3 id="maven阿里镜像"><a href="#maven阿里镜像" class="headerlink" title="maven阿里镜像"></a>maven阿里镜像</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span></pre></td></tr></table></figure>





<h3 id="Spring-Boot-全局排除-spring-boot-starter-logging-依赖"><a href="#Spring-Boot-全局排除-spring-boot-starter-logging-依赖" class="headerlink" title="Spring Boot 全局排除 spring-boot-starter-logging 依赖"></a>Spring Boot 全局排除 spring-boot-starter-logging 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局排除spring-boot-starter-logging内的所有依赖--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>



<h3 id="多模块maven"><a href="#多模块maven" class="headerlink" title="多模块maven"></a>多模块maven</h3><ul>
<li>创建项目类型为maven pom的主项目</li>
<li>然后分别创建子模块</li>
<li>最后在父pom.xml添加子模块，idea成功识别</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>spring-boot-admin-server<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>spring-boot-admin-client<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span></pre></td></tr></table></figure>


<h3 id="mvn-install-resource"><a href="#mvn-install-resource" class="headerlink" title="mvn install resource"></a>mvn install resource</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean source:jar install</span></pre></td></tr></table></figure>

<h3 id="mvn-tomcat7-run"><a href="#mvn-tomcat7-run" class="headerlink" title="mvn tomcat7:run"></a>mvn tomcat7:run</h3><p><strong>内存不足时设置参数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set MAVEN_OPTS=-Xms256m -Xms512m -XX:MaxNewSize=256m -XX:MaxPermSize=256m</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>工作建议</title>
    <url>/2019/09/18/md/life/work/</url>
    <content><![CDATA[<p>1、不要把同事当朋友，要当盟友。<br>2、不要和同事说过多自己的隐私。<br>3、公司组织的比赛一定要参加！一定要参加！一定要参加！<br>4、保持微笑，不要喜怒无常。<br>5、投资比工作重要，不学习理财投资不买房的若干年后都后悔了。<br>6、尽量别得罪人，三十年河东三十年河西<br>7、不要瞧不起你领导，他能是你的领导，一定有你能学习的地方。<br>8、你可以有理想，但是时刻记住你的理想跟别人没啥关系。<br>9、不要相信公司的奉献精神，他们不想要你的时候可快了。<br>10、保持运动，和你是不是忙没有关系。<br>11、偷奸耍滑可以耍了的一时，但是总要露馅。<br>12、什么30天教你做达人，一个月教你赚100万的攻略都是骗人的，厚积薄发才是真理。<br>13、学习是为你自己。人与人之间的差距是逐步拉开的。<br>14、大部分的工作只看结果，不看过程。很多事情努力了没做到和没做是一样的。<br>15、不要浪费时间在不值得浪费的人身上，自己的时间很宝贵。<br>16、学会站在老板或者公司的角度去思考问题。格局很重要。<br>17、在成人的社交礼仪里，没有爽快的答应就是拒绝。<br>18、抱怨只会显得一个人特别无能。<br>19、不要矫情，除非你是牛人，否则的话，永远提醒自己，人才市场有成千上万的人随时可以取代你顶替这个职位。<br>20、加班这种事情不可避免，忍不了就辞职，走不了就忍着！<br>21、无论多么信任的人，别过多袒露你的过去。为你自己好。<br>22、尽量不要向同事借钱，一般人家都会很反感，除非你们成为了真正的朋友。<br>23、不要为了工作牺牲身体和家庭。<br>24、闷不吭声地埋头苦干，并不一定能够给你带来想要的认可。要学会向领导、上司汇报工作进度。<br>25、低调做人，高调做事。<br>26、老板经营的是他的事业，你经营的是你的人生，所以混不得。<br>27、不要放弃每一个可以请教的机会，不论这个人你是否喜欢，职位是否比你高。<br>28、觉得是垃圾社交，不想参加就不要去，好好把握下班后自由的时间，别为了迎合别人浪费自己时间。<br>29、画饼的领导千千万，谁当领导不画饼？但画了饼连糖都不给吃的公司趁早走，不要回头。<br>30、不要夸夸而谈，这只会让人发现你的浅薄，对于不懂得事情，要懂得闭上嘴巴。<br>31、一定要去大城市，那里才有更多出路和机会。<br>32、我们年轻的时候是得吃苦，但是我们不随便吃苦。<br>33、不要太安逸，现在哪里还有什么稳定工作。<br>34、和公司谈钱时，少讲感情，尽量不讲，拿能力和业绩说话。<br>35、不管你这个工作做的有多差，都不要否定自己。你一定要相信，你还是很优秀。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>不做老好人，你的善良必须要有锋芒</title>
    <url>/2019/09/18/md/life/thinking/%E4%B8%8D%E5%81%9A%E8%80%81%E5%A5%BD%E4%BA%BA%EF%BC%8C%E4%BD%A0%E7%9A%84%E5%96%84%E8%89%AF%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E9%94%8B%E8%8A%92/</url>
    <content><![CDATA[<p>  有一些耋好人，为了周围人的喜欢和认可，不懂拒绝别人，却让自己活得很累，可是别人也不会真的感激你，你为别人付出的时候，别人却不会为你付出，在这样一种不对等的关系中，所以就会产生出让人失望的情绪。很多人不明白，为什么自己替别人做了很多，却得不到应有的回报和尊重呢？而且还会因为稍有一点不满意，别人还会记恨。其实，这其中主要的原因就是因为你太喜欢帮助别人了。</p>
<p>  老好人也称为“利他主义者。事实上，利他主义者是用自己的行为在对自己进行操纵——并没有人要求他们这么做！他们的过度付出是造成这种”做了好事却得不到尊重“的情形的元凶。  </p>
<p>  好人我们都喜欢，但一旦你被别人当成”老好人“，那么你的付出就只会给自己带来无尽的麻烦了。因为，老好人往往给人一种懦弱、没主见的印象。总是表现得很无私，面对别人的种种请求，不管能不能做到，都会硬着头皮允诺，甚至有时候会不惜牺牲自己的利益来帮助他人。</p>
<p>  总是毫无怨言地帮别人做事，时间一长，他们会认为你做这些事情是应该的。还有些人是欺软怕硬型的，你总是表现得很弱势，对方会以为你很好”欺负“，所以有什么事情都会想到让你来承担。你帮助他们做一次事情，他们便会让你做更多的事情，因为他们摸准了你不好意思拒绝的弱点。你要知道，只有”雪中送炭“式的帮助才会让人铭记一生，但是如果你随时都会帮助你身边的人做各种事情，那么你很可能会被别人当作傻瓜，或者廉价的劳动力。  </p>
<p>  老好人的处世原则是宁可自己受委屈也不拒绝别人，但是这样做，却不会被人真正铭记。作为老好人，之所以对他人的要求不愿意轻易拒绝，是担心因为拒绝而使对方难堪，无法保持友好关系。然而，一味地隐忍却不会让对方高看你，相反，还很有可能会越来越瞧不起你。<br>  我们之中大部分人都有欺软怕硬的本质。对于做惯了好人的你，可能要改变自己的秉性的确有些不容易，但是你如果不改变自己的”利他主义“，别人就可能毫无底线地侵犯你。  </p>
<p>  当然，对于他人的求助，我们不可能袖手旁观，那样的话，我们就太冷血了。但是帮助别人也要遵循一定的原则，要帮助真正有需要帮助和值得帮助的人。如果对方因为懒惰、虚荣、爱占小便宜等原因而让你代劳，那还是果断拒绝吧。此外，对于那些知恩不报，甚至”得了便宜还卖乖“的人，更要保持距离，因为他们是不值得你去付出自己的精力和时间的。  </p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>性格</tag>
      </tags>
  </entry>
  <entry>
    <title>老好人</title>
    <url>/2019/09/18/md/life/%E8%80%81%E5%A5%BD%E4%BA%BA/</url>
    <content><![CDATA[<p><code>老好人</code>指的是随和厚道，性格温柔，不愿得罪人，不会拒绝别人，缺乏原则性的人。然而现在社会中普遍反对老好人主义。</p>
<h3 id="心理提示"><a href="#心理提示" class="headerlink" title="心理提示"></a>心理提示</h3><p>一直以来，老好人都是以待人热情大方，不会拒绝别人而让你在交际中容易受到大家欢迎，特别是最初阶段。但是，人类都有欺软怕硬心理，在这种心理下，如果你总是习惯性地接受他人的任何请求，常常扮演着一种“老好人”的角色，让人在你身上得寸进尺，那渐渐地你自己也会身心疲惫，早晚有一天会出问题的。<br>能帮助别人固然很好，但如果总是如此，对方就会得寸进尺，认为你帮忙是理所当然的，感激之情也会淡薄。为了避免这种情况，最好灵活一些，可以偶尔故意拒绝对方的要求。<br>做人要有自己的尺度，你不是神，也不是大圣人，不可事事做“老好人”，总是对别人谦让，有求必应，这样会让人得寸进尺。<br>自古以来，什么人都有，恶人，人们恐惧他；善人，人们爱戴他；而那些老好人呢？生活中总是可以看到那些随和厚道的、从不得罪人、看起来似乎没有一点儿脾气儿的，人家什么忙都愿意帮的人。按理来说，这种人应该是最讨人喜欢的，若你遇见了自己不愿意去做的或者懒得去做的事，只要叫一句“某某某，帮我个忙好不好”，一个简单明了的“好”，你就可以潇洒解脱，去做自己喜欢的事情。这多亏了那个热心人啊，怎么着也得给他授予一枚好人勋章吧！可是调查却表明，正是这种不拒绝，也不反抗的人，在“世界上最讨厌的人”排名榜中名列前茅。哎呦，出了力还不得好，为什么会这样呢？</p>
<h4 id="【一、阿伦森效应】"><a href="#【一、阿伦森效应】" class="headerlink" title="【一、阿伦森效应】"></a>【一、阿伦森效应】</h4><p>这得归根于有名的阿伦森效应。所谓阿伦森效应，是指伴随奖励减少，态度也逐渐消极；伴随奖励增加，而态度逐渐积极的心理现象。曾经有人做过一个实验，将被试分4组对某一人给予不同的评价，借以观察某人对哪一组最具好感。第一组始终对之褒扬有加，第二组始终对之贬损否定，第三组先褒后贬，第四组先贬后褒，最后在实验对象对数十人进行后，发现大部分人对第四组最具好感，而对第三组最具反感。<br>阿伦森效应提醒人们，在日常工作与生活中，应该尽力避免由于自己的表现不当所造成的他人对自己印象不良方向的逆转。<br>老好人在人际交往中吃力不讨好便是这个缘故，当生活的风向改变，他也不得不开口说拒绝。而这唯有的一次拒绝，却比一个贬义词更像是一记巴掌，拍在对方的脸皮上。举例来说吧，有这么一个老好人，第一次，A找他帮忙，他没拒绝；第二次，A又寻求帮助，老好人又帮了他……之后，第三次，第四次，第五次，老好人都毫无意外的帮助A了。但在第无数次的帮忙后，老好人终于因为某些不得已的原因拒绝了A的请求，此时A被激起的愤怒感与失望感将胜于从前的种种，而老好人之前帮A做的所有事情，似乎都在他拒绝A的那一刻起，变得毫无意义。<br>经过无数次的帮助而建立起来的好感就因为仅有一次的拒绝就被破坏了，这究竟是谁的错？老好人想必也是捶胸顿足，有口难言。可能有人会说“这都是老好人的自作自受，谁让他一直都充当这个老“好人”呢”，但事情远远没有这么简单。</p>
<h4 id="【二、登门槛效应】"><a href="#【二、登门槛效应】" class="headerlink" title="【二、登门槛效应】"></a>【二、登门槛效应】</h4><p>很久以前就有人提出了“得寸进尺效应”，也叫做“登门槛效应”，这是指一个人如果接受了别人的一个小要求，那么别人在此基础上再提出一个更高点的要求，这个人也会倾向于接受。<br>上面所讲的A同志运用的就是得寸进尺效应，因为人的每个意志行动都有其行动的最初目标，在许多场合下，由于人的动机是复杂的，因此常常会面对不同的目标进行比较、衡量和选择，在相同情况下，那些简单易行的目标较容易让人接受并采取行动。另外，人们总愿意把自己调整成前后一贯、首尾一致的形象，即使别人的要求有些过分，但为了维护印象的一贯性，人们也会维持下去。老好人在一开始的时候帮助了A，为了他的美好形象，即使再不情愿，他也会始终的帮助A，所以才会有接踵而来的求助。</p>
<h4 id="【三、摆脱“老好人”的形象】"><a href="#【三、摆脱“老好人”的形象】" class="headerlink" title="【三、摆脱“老好人”的形象】"></a>【三、摆脱“老好人”的形象】</h4><p>如何摆脱“老好人”的形象？这个就需要改变你的行为模式。根据吸引力法则，他们会找你帮忙，是因为你是那个“愿意帮忙的人”。<br>当然，可能有些读者想问，朋友间，总会有不方便、需要帮忙的时候，难道说人家找你帮忙就必须一口拒绝，以免后患吗？我只能说，如果你这么做了，最后倒霉的还是你，你的人际关系和生活最后只会被你的这个“一口拒绝”弄的乱七八糟。对于别人的请求，需要选择性的帮忙，你要戴上辨别是非的眼镜去进行筛选。</p>
<h4 id="【四、选择性帮忙】"><a href="#【四、选择性帮忙】" class="headerlink" title="【四、选择性帮忙】"></a>【四、选择性帮忙】</h4><p>如果把你身边的人分成几个生活圈的话，你可以选择：</p>
<ol>
<li>亲密圈：很好很好的朋友，你和他之间已经不在乎钱的问题，甚至可以分享一切；</li>
<li>朋友圈：身边经常一起玩的，关系不错的，但比亲密圈少一分熟稔的人；</li>
<li>熟人圈：同事、同学，你对他的感觉一般，不热情，不冷淡的；</li>
<li>世界圈：陌生人（调查显示，一个人对陌生人比对认识的人愿意投入更多的信任）。</li>
</ol>
<p>对于你心目中的亲密圈内的人也不用我说，连钱你都愿意彼此分享了，为他付出，你也定是心甘情愿的；朋友圈里的人，他的人格、人品，他是一个怎样的人，你们经常混在一起，总是略有耳闻的。爱占小便宜的家伙你委婉拒绝他或许是更好的选择，你觉得他还不错的人帮个小忙也无妨。剩下的那些人，你应该切身思考下你的人生会和他有交集吗？你讨厌他什么？仔细衡量其中的利与弊便可瞬间得出结果。<br>生活是美好的，每个人都是善良的。赠人玫瑰，手留余香。帮助了别人，心里也会快乐。但每个人都是独立的个体，谁也没有义务去无条件地帮谁。与其做一个博爱的滥好人，不如去爱少数人，也为少数人所爱。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>性格</tag>
      </tags>
  </entry>
  <entry>
    <title>压力管理</title>
    <url>/2019/09/04/md/life/%E5%8E%8B%E5%8A%9B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>搞定<code>老婆</code>和<code>老板</code>  </p>
<p>情绪不好，<code>不要做重要的决定</code>和<code>接触重要的人</code></p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>BASE理论</title>
    <url>/2019/08/23/md/part/distributed/base/</url>
    <content><![CDATA[<h3 id="三个部分："><a href="#三个部分：" class="headerlink" title="三个部分："></a>三个部分：</h3><p>1、基本可用（Base Availability）。</p>
<p>基本可用就意味着可以容许系统有短暂的不可用状态，只要能快速恢复就可以。</p>
<p>2、软状态（Soft-state）。</p>
<p>软状态是跟持久状态相对的，也就意味着系统可以处于一种中间状态，既不是事务执行前的状态，也不是事务成功执行后的状态，这种状态会导致系统的不一致性，但是这种不一致性是短暂的，最终是要回归到一致性的。</p>
<p>3、最终一致性（Eventual Consistency）。</p>
<p>最终一致性跟强一致性相对，也就意味着系统只要能在可接受的时间范围内达到一致性即可。</p>
<p>BASE理论容许系统出现短暂性的问题的，无论是短暂的不可用还是短暂的不一致状态，只要能够在一定时间范围内最终达到可用或者一致状态即可。</p>
<h3 id="补偿机制"><a href="#补偿机制" class="headerlink" title="补偿机制"></a>补偿机制</h3><p>既然BASE理论容许系统处于短暂的不可用和不一致的状态，那么在设计的时候怎么去保证最终的可用和一致状态呢？这就需要引入补偿机制。<br>现在的系统往往都微服务化了，所以要完成某一个业务流程往往涉及到很多个服务，甚至涉及很多个外部的系统，外部系统的可用性不是我们能够保证的，我们在设计实现流程时能够做的就是当在调用某个三方系统失败时，后续的流程应该怎么去设计。这就需要工作流编排的能力。工作流的编排完全是基于业务的，需要根据业务的实际情况来进行流程的转换。<br>举个例子来说。如果去某个地方旅游，来回机票、酒店都定好了，但是旅游地的短途交通还没有预定成功，这也不会使得我们放弃这次旅游，因为旅游地的短途交通这个事情我们确认可以解决的。这个就说明当整个业务流程中的非关键操作失败后，业务流程可以正常执行。但是如果是回程机票没有定好，那我们可能就会试着再重试去预定，如果实在预定不到，那我们就会取消这次旅游，并且就会去启动取消去程的机票和预定的酒店。这个就说明当整个业务流程中的关键操作失败后，业务流程必须实行回滚操作。</p>
<p>补偿机制的设计有几个关键点需要考虑：</p>
<ul>
<li>1、要使得一个业务流程能够执行完成，必须得保证流程涉及的所有的服务都必须是幂等性的，并且在整个流程的执行过程中需要有重试机制。</li>
<li>2、整个补偿机制的工作流是状态驱动的，所以需要时刻关注业务流程执行过程中的状态，当某个状态出现时需要有效地驱动工作流引擎中的下一个动作，继续执行或者进行回滚或者补偿动作。</li>
<li>3、当业务流程执行失败后，需要启动补偿的流程，这个补偿流程不一定完成是业务流程的反向操作，可以根据实际的情况来制定补偿的操作，目标就是补偿流程的启动要么就是保证业务流程执行成功，要么就是保证回滚到业务流程执行前的状态。</li>
<li>4、有些业务补偿操作不一定需要即时执行，在保证关键的业务操作执行成功的情况下，对于一些非关键的业务操作，可以推迟或者降低优先级执行。</li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>cap</title>
    <url>/2019/08/23/md/part/distributed/cap/</url>
    <content><![CDATA[<h4 id="CAP设计原则"><a href="#CAP设计原则" class="headerlink" title="CAP设计原则"></a>CAP设计原则</h4><ul>
<li><p><code>一致性</code>（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p>
</li>
<li><p><code>可用性</code>（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</p>
</li>
<li><p><code>分区容忍性</code>（P）：就是当由于网络故障之时，导致集群里的机器不能保证其互相保持正常通信之时，每台机器所具备各自为战能力，保证服务能否正常使用</p>
</li>
</ul>
<p>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。</p>
<p>如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备</p>
<p>但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问</p>
<p>此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足。必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足。</p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>SRE</title>
    <url>/2019/08/22/md/develop/SRE/</url>
    <content><![CDATA[<p>SRE是指Site Reliability Engineer (网站可靠性工程师)。他是软件工程师和系统管理员的结合，一个SRE工程师基本上需要掌握很多<br>知识：<code>算法</code>，数据结构，<code>编程能力</code>，<code>网络编程</code>，<code>分布式系统</code>，<code>可扩展架构</code>，故障排除。</p>
<p>，DevOps 可能缺乏 SRE 在一些专业领域的技能： </p>
<ul>
<li><p>计算机体系结构能力；</p>
</li>
<li><p>高吞吐高并发优化能力；</p>
</li>
<li><p>可扩展系统设计能力；</p>
</li>
<li><p>复杂系统设计能力；</p>
</li>
<li><p>业务系统排查能力。 </p>
</li>
</ul>
<p>两者都需要软实力，但是 SRE 面临复杂度更高，挑战更大，要求也更高：</p>
<ul>
<li>分析问题、解决问题能力</li>
<li>战胜困难决心</li>
<li>面对挑战热情</li>
<li>自驱学习</li>
</ul>
]]></content>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>架构师职位相关(二)</title>
    <url>/2019/08/22/md/interview/sa-require-02/</url>
    <content><![CDATA[<h3 id="商汤科技招聘–术架构师-技术经理-35k-45k"><a href="#商汤科技招聘–术架构师-技术经理-35k-45k" class="headerlink" title="商汤科技招聘–术架构师/技术经理(35k-45k)"></a>商汤科技招聘–术架构师/技术经理(35k-45k)</h3><h5 id="岗位职责："><a href="#岗位职责：" class="headerlink" title="岗位职责："></a>岗位职责：</h5><ul>
<li>根据公司业务规划，开展城市视觉智慧赋能产品架构相关设计与研发工作；</li>
<li>参与构建高性能，高可用，可扩展的分布式人工智能平台产品；</li>
<li>负责产品架构设计，影响产品路线图，构建智慧城市及AI+行业领域具有竞争力的智能化产品；</li>
<li>支撑AI产品、项目交付团队，完成产品对行业用户的赋能；</li>
<li>负责大中型项目的系统架构和概要设计，参与核心模块的代码编写，保证架构的落地交付；</li>
<li>深刻理解需求，对项目中的总体设计、模块设计进行确定、审查和把关；</li>
<li>决定项目中的关键问题和技术难题，丰富技术库；</li>
<li>参与售前阶段的产品白皮书、设计方案书、投标书、测试报告、实施方案等设计文档、POC等</li>
</ul>
<h5 id="任职要求："><a href="#任职要求：" class="headerlink" title="任职要求："></a>任职要求：</h5><ul>
<li>8年以上java开发，5年以上架构设计经验，3年以上项目开发团队管理经验, 有SaaS或者PaaS架构设计以及相关JAVA开源技术方案者优先。有微服务架构、分布式架构、持续构建架构经验者优先。</li>
<li>有BPM, RuleEngine等的开发和架构设计经验者优先；有开放平台&amp;API设计经验。</li>
<li>精通Java编程，熟练使用Spring framework(Spring Boot\SpringMVC\Spring Cloud\Spring Data\Spring Batch等), Javascript, JQuery；</li>
<li>精通高并发下的架构设计和高负载Web应用的关键技术，如容灾备份、负载均衡、集群、横向及纵向扩展。以及主流开源Web框架、消息系统，缓存系统，关系数据库系统，Linux操作系统。</li>
<li>熟悉PostgreSQL/MySQL/MongoDB/Cassandra数据库的管理、配置、使用等。</li>
<li>熟悉Tomcat/JBoss的管理、配置、使用等。 </li>
<li>有elastic search/solr开发经验者优先。</li>
<li>有 Hadoop/HBase/Spark/Flink/Storm经验者优先</li>
<li>熟悉Docker与K8S者优先</li>
<li>工作积极努力，客观务实，具有良好的沟通、团队协作、工作计划和创新的能力。</li>
<li>软件工程，计算机科学，计算机工程，自动化，数学等相关专业本科及以上学历，技术优秀者学历可以放宽。</li>
</ul>
<hr>
<h3 id="平安健康保险–-0921GK-架构师-30k-50k"><a href="#平安健康保险–-0921GK-架构师-30k-50k" class="headerlink" title="平安健康保险– 0921GK-架构师(30k-50k)"></a>平安健康保险– 0921GK-架构师(30k-50k)</h3><h5 id="工作职责"><a href="#工作职责" class="headerlink" title="工作职责"></a>工作职责</h5><ul>
<li><p>负责核心系统架构改造，优化，设计方案,开源项目的二次开发，达到项目自定义需求，编写系统相关的技术接口和规范文档 </p>
</li>
<li><p>与运维合作，共同制定一些监控指标以及告警工具 </p>
</li>
<li><p>负责业务核心代码的开发指导，新技术的引进及培训，参与公司的系统规划、功能模块规划、切分系统功能模块 </p>
</li>
<li><p>负责理解和设计非功能性系统需求，包括软件的可维护性、性能、复用性、可靠性、有效性和可测试性等。 </p>
</li>
<li><p>组织协调技术研究和攻关工作，组织及带领公司内部员工研究与项目相关的新技术 </p>
</li>
</ul>
<h5 id="任职要求"><a href="#任职要求" class="headerlink" title="任职要求"></a>任职要求</h5><ul>
<li><p><code>35岁</code>以下计算机相关专业，本科及以上学历 </p>
</li>
<li><p>6年以上开发经验，4年以上平台架构设计经验，2年以上中大型系统设施实施经验 。至少研究过1个以上系统类开源产品的架构和源代码。 </p>
</li>
<li><p>领导过5人以上的技术研发团队，良好的架构设计和技术指导能力，精通JAVA及相关技术，深入了解java开发工具及主流开发框架，具有扎实的技术功底，熟悉主流技术架构 </p>
</li>
<li><p>精通Mysql/MongoDB数据库，熟悉Linux、REST架构、TCP/IP协议，精通面向对象的分析和设计技术，包括设计模式、UML建模等，有设计通用框架及模块的能力 </p>
</li>
<li><p>熟悉RPC，异步、多线程、分布式、缓存、负载均衡、消息队列等技术的设计和应用 </p>
</li>
<li><p>具有大型分布式系统的平台架构设计能力，有各协议层设计和实现经验者优先 </p>
</li>
<li><p>诚恳、踏实，对技术和工作充满热情，有强烈的责任心、主动性和团队合作精神</p>
</li>
</ul>
<h3 id="喜马拉雅–Java技术经理-架构师（26k-40k）"><a href="#喜马拉雅–Java技术经理-架构师（26k-40k）" class="headerlink" title="喜马拉雅–Java技术经理/架构师（26k-40k）"></a>喜马拉雅–Java技术经理/架构师（26k-40k）</h3><h5 id="岗位职责"><a href="#岗位职责" class="headerlink" title="岗位职责"></a>岗位职责</h5><ul>
<li><p>主导平台的后台架构设计与开发，搭建平台基础设施；</p>
</li>
<li><p>研究新的技术方案，调整服务端开发策略和技术架构，使之适应业务平台日益增长的需求。</p>
</li>
</ul>
<h5 id="任职要求-1"><a href="#任职要求-1" class="headerlink" title="任职要求"></a>任职要求</h5><ul>
<li><p>至少3年以上大规模分布式系统应用架构设计与研发经验，精通Java技术栈相关技术；</p>
</li>
<li><p>3年以上大型数据库如MySQL使用经验，具备分布式数据库如TDDL, TIDB等；</p>
</li>
<li><p>精通unix/linux操作系统；</p>
</li>
<li><p>精通分布式计算平台如storm， spark， flink等</p>
</li>
<li><p>精通缓存，如redis， pika， codis等；</p>
</li>
<li><p>精通分布式存储，如HDFS,Parquet,HBase；</p>
</li>
<li><p>有移动互联网架构如移动网关，应用性能管理，可视化埋点， ABTest，微服务化等经验者优先；</p>
</li>
<li><p>对开源技术有浓厚兴趣，有源代码阅读习惯；</p>
</li>
<li><p>具备良好的识别和设计通用框架及模块的能力。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>架构师职位相关(一)</title>
    <url>/2019/08/22/md/interview/sa-require-01/</url>
    <content><![CDATA[<h3 id="拼多多–稳定性架构师-SRE-30k-60k"><a href="#拼多多–稳定性架构师-SRE-30k-60k" class="headerlink" title="拼多多–稳定性架构师(SRE)(30k-60k )"></a>拼多多–稳定性架构师(SRE)(30k-60k )</h3><h5 id="职位描述："><a href="#职位描述：" class="headerlink" title="职位描述："></a>职位描述：</h5><p>作为基础平台团队的一员，在拼多多，你每天将：</p>
<p>在社交电商领域排名第一的新兴独角兽公司中切身感受公司和个人同时高速成长的感觉；</p>
<p>在充满创造力和活力的年轻团队中，技术驱动业务，改变互联网电商行业；</p>
<p>为十亿级用户的电商平台提供稳定性保障支撑，规划技术方向，优化基础架构，打造强一致高可用的技术架构；</p>
<h5 id="岗位职责："><a href="#岗位职责：" class="headerlink" title="岗位职责："></a>岗位职责：</h5><ul>
<li><p>对公司技术平台的稳定性负责，通过质量管理、过程管理、架构优化等手段不断提升系统稳定性；</p>
</li>
<li><p>建设全链路压测平台、容量评估和调度平台、稳定性模拟平台、可视化架构平台等来提升系统稳定性；</p>
</li>
<li><p>负责技术难点的攻坚，推动公司级的架构优化项目，指导并培训工程师，提升团队整体技术能力；</p>
</li>
<li><p>具有强烈的目标感、良好的服务意识和自我驱动力。</p>
</li>
</ul>
<h5 id="任职要求："><a href="#任职要求：" class="headerlink" title="任职要求："></a>任职要求：</h5><ul>
<li>计算机相关专业本科及以上学历；</li>
<li>开发功底扎实，熟悉Java/Golang/C/C++单种或多种开发语言，对高并发高可用系统有深刻理解和实践经验；</li>
<li>熟悉大型互联网平台的架构，熟悉微服务框架、分布式组件、常见的存储组件并有丰富实践经验；</li>
<li>有容量调度管理、稳定性压测、架构优化、活动保障、混沌工程实践者优先；</li>
</ul>
<hr>
<h3 id="万向区块链技术中心招聘-后端架构师-30k-45k"><a href="#万向区块链技术中心招聘-后端架构师-30k-45k" class="headerlink" title="万向区块链技术中心招聘 后端架构师 (30k-45k)"></a>万向区块链技术中心招聘 后端架构师 (30k-45k)</h3><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><ul>
<li><p>5年以上开发经验</p>
</li>
<li><p>本科以上学历，计算机/软件相关专业优先</p>
</li>
<li><p>具备团队技术领导经验</p>
</li>
</ul>
<h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><ul>
<li><p>工作积极主动、耐心细心，能承受一定的工作压力，有很好的学习能力及强烈的责任心和团队合作的精神</p>
</li>
<li><p>态度良好，不排斥提携后进者</p>
</li>
<li><p>编程方向：精通Java或等面向对象语言，理解AOP（面向切面编程）等设计</p>
</li>
<li><p>主流开发框架：精通Tomcat、Nigix等常用应用容器部署与优化；精通Spring系列框架，熟悉Hibernate、MyBatis等技术；精通主流关系型数据库、NoSQL数据库应用，熟悉分布式缓存、数据持久化技术</p>
</li>
<li><p>参与过大型系统设计及开发</p>
</li>
<li><p>精通主流设计模式、泛型、数据结构及主要排序算法</p>
</li>
<li><p>对技术系统具有热诚，领导并主动积极参与及主持技术项目</p>
</li>
</ul>
<h5 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h5><ul>
<li><p>承担领导交付的任务</p>
</li>
<li><p>负责带领工程小组针对需求进行设计及开发，并在技术上有所要求，推动技术演进</p>
</li>
<li><p>研究及追踪技术演进，并带领小组进行技术尝试</p>
</li>
<li><p>参与管理各项技术框架及设计，推进开发项目完成</p>
</li>
</ul>
<hr>
<h3 id="爱回收招聘-业务架构师-30k-50k"><a href="#爱回收招聘-业务架构师-30k-50k" class="headerlink" title="爱回收招聘 业务架构师(30k-50k)"></a>爱回收招聘 业务架构师(30k-50k)</h3><h5 id="岗位职责：-1"><a href="#岗位职责：-1" class="headerlink" title="岗位职责："></a>岗位职责：</h5><ul>
<li><p>负责明确服务边界，参与技术评审；</p>
</li>
<li><p>建立业务线内中台与前台系统的协同机制</p>
</li>
<li><p>抽象和沉淀业务中台，避免重复建设；</p>
</li>
<li><p>建立业务线技术团队和集团技术中台的协同机制。</p>
</li>
</ul>
<h5 id="任职要求：-1"><a href="#任职要求：-1" class="headerlink" title="任职要求："></a>任职要求：</h5><ul>
<li><p>5年以上服务端开发经验，丰富的微服务架构能力；</p>
</li>
<li><p>熟悉领域驱动设计等主流建模方法，具备优秀的业务建模能力；</p>
</li>
<li><p>精通电商/O2O某一领域，并成功完成平台化建设；</p>
</li>
<li><p>丰富的项目管理经验，具备跨部门协调沟通能力；</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷</title>
    <url>/2019/08/21/md/part/project/agile-project-manage/</url>
    <content><![CDATA[<p>敏捷项目管理的项目流程制度上的管理可以看作是对一套完善的项目管理流程制度的裁剪，只不过这个裁剪的尺度比较大，<br>从而也对敏捷项目团队成员的适应性，自主性提出了较高的要求。</p>
]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>es搭建</title>
    <url>/2019/08/21/md/part/mid/es/es-run/</url>
    <content><![CDATA[<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p> <a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/products/elasticsearch</a></p>
<p><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch</a></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>执行bin文件夹中的elasticsearch.bat ，查看  <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a></p>
<h4 id="安装ik中文分词器"><a href="#安装ik中文分词器" class="headerlink" title="安装ik中文分词器"></a>安装ik中文分词器</h4><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<ul>
<li>选择和已经下载的elasticsearch版本兼容的ik。</li>
<li>解压后复制elasticsearch/plugins/ik(ik文件夹新创建)目录下</li>
<li>重新运行elasticsearch.bat</li>
</ul>
<p><a href="https://blog.csdn.net/u010391342/article/details/82117389" target="_blank" rel="noopener">https://blog.csdn.net/u010391342/article/details/82117389</a></p>
<h3 id="集群elasticsearch-yml相关配置如下"><a href="#集群elasticsearch-yml相关配置如下" class="headerlink" title="集群elasticsearch.yml相关配置如下"></a>集群<code>elasticsearch.yml</code>相关配置如下</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">----------------------------------</span> <span class="string">Cluster</span> <span class="string">-----------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">mqiy-es</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.85</span><span class="number">.141</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.85.142",</span> <span class="string">"192.168.85.143"</span><span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["node-1",</span> <span class="string">"node-2"</span><span class="string">,"node-3"]</span></span></pre></td></tr></table></figure>

<h4 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h4><blockquote>
<p><a href="http://192.168.85.141:9200/_cat/health?v" target="_blank" rel="noopener">http://192.168.85.141:9200/_cat/health?v</a>      查看集群的健康状态<br><a href="http://192.168.85.141:9200/_cat/indices?v" target="_blank" rel="noopener">http://192.168.85.141:9200/_cat/indices?v</a>     查看集群的索引数<br><a href="http://192.168.85.141:9200/_cat/allocation?v" target="_blank" rel="noopener">http://192.168.85.141:9200/_cat/allocation?v</a>  查看集群所在磁盘的分配状况<br><a href="http://192.168.85.141:9200/_cat/nodes?v" target="_blank" rel="noopener">http://192.168.85.141:9200/_cat/nodes?v</a>       查看集群的节点<br><a href="http://192.168.85.141:9200/_cat" target="_blank" rel="noopener">http://192.168.85.141:9200/_cat</a>               查看集群信息目录(包含上面的)</p>
</blockquote>
<p>v 表示带title</p>
<h3 id="启动过程报错"><a href="#启动过程报错" class="headerlink" title="启动过程报错"></a>启动过程报错</h3><h4 id="max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144"><a href="#max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144" class="headerlink" title="max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]"></a>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</h4><p>添加配置 /etc/sysctl.conf (永久性修改)</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch config start</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">vm.max_map_count</span>=<span class="string">262144</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch config end</span></span></pre></td></tr></table></figure>

<blockquote>
<p>sysctl -p</p>
</blockquote>
<h4 id="max-file-descriptors-4096-for-elasticsearch-process-is-too-low-increase-to-at-least-65535"><a href="#max-file-descriptors-4096-for-elasticsearch-process-is-too-low-increase-to-at-least-65535" class="headerlink" title="max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]"></a>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]</h4><p>添加配置 /etc/security/limits.conf  (永久性修改)　</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch config start</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">*</span> <span class="string">soft nofile 65536</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">*</span> <span class="string">hard nofile 131072</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">*</span> <span class="string">soft nproc 2048</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">*</span> <span class="string">hard nproc 4096</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch config end</span></span></pre></td></tr></table></figure>
<blockquote>
<p>其中<code>*</code> 号不能省略，不需要重启</p>
</blockquote>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>旅游计划</title>
    <url>/2019/08/20/md/plan/%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>待玩的地方：  </p>
<table>
<thead>
<tr>
<th>城市</th>
<th>地点</th>
<th>进度</th>
</tr>
</thead>
<tbody><tr>
<td>苏州</td>
<td>钮家巷</td>
<td></td>
</tr>
<tr>
<td></td>
<td>旺山</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>减肥计划</title>
    <url>/2019/08/20/md/plan/%E5%87%8F%E8%82%A5%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>买个苹果本，为期二个月（2019-10-21)：要求 </p>
<ul>
<li>减肥到63KG</li>
<li>戒小说</li>
<li>戒HB</li>
<li>每周一本书</li>
</ul>
<p>跑步(20m)<br>深蹲(10m)<br>HITT全身(15M)<br>腹肌撕裂初(9m)</p>
<p>or<br>骑单车(30m)<br>HITT全身(15M)<br>HIIT核心燃烧(25m)<br>腹肌撕裂初(9m)</p>
]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>心有不平</title>
    <url>/2019/08/20/md/life/%E5%BF%83%E6%9C%89%E4%B8%8D%E5%B9%B3/</url>
    <content><![CDATA[<h3 id="2019-08-20"><a href="#2019-08-20" class="headerlink" title="2019-08-20"></a>2019-08-20</h3><p>物业打电话过来，收物业费，自己一顿说，周五过去，其实指的是周五去南京，而不是周五交物业费，瞎弄</p>
<h3 id="2019-08-06"><a href="#2019-08-06" class="headerlink" title="2019-08-06"></a>2019-08-06</h3><p>洗的衣服被人放在很脏的凳子上，默默地拿起回屋子了，忍气吞声，应该大声怼回去。</p>
<hr>
<h3 id="2019-07-22"><a href="#2019-07-22" class="headerlink" title="2019-07-22"></a>2019-07-22</h3><p>小舅来上海玩，晚上带他们吃饭，住酒店，他们说随便，不能当真，还是要认真准备一下。  </p>
<h3 id="2019-07-18"><a href="#2019-07-18" class="headerlink" title="2019-07-18"></a>2019-07-18</h3><p>公司部门组织活动，自己出一部分钱，关键是我已经参加过一次，现在我又报名了，傻屌  </p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>学习计划</title>
    <url>/2019/08/20/md/plan/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>集合</th>
<th>时间</th>
<th>完成情况</th>
</tr>
</thead>
<tbody><tr>
<td>集合</td>
<td>2W</td>
<td></td>
</tr>
<tr>
<td>JVM</td>
<td>2W</td>
<td></td>
</tr>
<tr>
<td>并发</td>
<td>4W</td>
<td></td>
</tr>
<tr>
<td>分布式</td>
<td>4W</td>
<td></td>
</tr>
<tr>
<td>缓存</td>
<td>2W</td>
<td></td>
</tr>
<tr>
<td>设计模式</td>
<td>2W</td>
<td></td>
</tr>
<tr>
<td>算法与数据结构</td>
<td>4W</td>
<td></td>
</tr>
<tr>
<td>微服务</td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>作息计划</title>
    <url>/2019/08/20/md/plan/%E4%BD%9C%E6%81%AF%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h4 id="作息时间"><a href="#作息时间" class="headerlink" title="作息时间"></a>作息时间</h4><ul>
<li>9：30准备睡觉</li>
<li>22:30~6:00 </li>
</ul>
<h5 id="晚睡的有两种人"><a href="#晚睡的有两种人" class="headerlink" title="晚睡的有两种人:"></a>晚睡的有两种人:</h5><ul>
<li>忙到不行，想要利用一天中最后一点时间；</li>
<li>无所事事，但是没有勇气闭上双眼来结束这失败的一天，总想多做点什么，以此来减轻心中的愧疚感。 </li>
</ul>
<hr>
<p>晚上下班回来不要求自己做什么，只是放松，上班已经很累了，再学习或者运动，想想都会有抵触心理</p>
<blockquote>
<p>每在电脑前工作20分钟，就看看6米外的物体大概20秒</p>
</blockquote>
<p>早睡让我学会了放下</p>
]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>运行docker web容器.</title>
    <url>/2019/08/20/md/part/docker/%E8%BF%90%E8%A1%8Cdocker%20web%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h4 id="运行一个web应用"><a href="#运行一个web应用" class="headerlink" title="运行一个web应用"></a>运行一个web应用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 载入镜像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker pull training/webapp  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d:让容器在后台运行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -P:将容器内部使用的网络端口映射到我们使用的主机上。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部运行的进程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker top wizardly_chandrasekhar</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker inspect wizardly_chandrasekhar </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启WEB应用容器，已经停止的容器，可以使用命令 docker start 来启动。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker start wizardly_chandrasekhar</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 正在运行的容器，我们可以使用 docker restart 命令来重启</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker restart  wizardly_chandrasekhar</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 移除WEB应用容器(删除容器时，容器必须是停止状态)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker rm wizardly_chandrasekhar</span></pre></td></tr></table></figure>

<blockquote>
<p>docker镜像的名字中不能包含大写字母,改成小写<br>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker redis 启动  --privileged=<span class="literal">true</span>加权限</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run --privileged=true   -p 6379:6379 -v /root/data:/data \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -d docker.io/redis:5.0.5 redis-server --appendonly yes</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接、查看容器,使用redis镜像执行redis-cli命令连接到刚启动的容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker exec -it 0bf909dfb2d2 redis-cli</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker nginx</title>
    <url>/2019/08/20/md/part/docker/docker%20nginx/</url>
    <content><![CDATA[<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --privileged=true  -d -p 8080:80 --name runoob-nginx-test-web \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -v ~/nginx/logs:/var/log/nginx nginx:1.15.12</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘</title>
    <url>/2019/08/09/md/plan/plan/</url>
    <content><![CDATA[<ul>
<li><p>英国剧作家萧伯纳曾说过：自我控制是最强者的本能。<br>有很多人会将这句话奉为人生励志金句：“体重都无法控制，还怎么控制人生！”<br>很多人做事就靠三分钟的热度吊着，三天打鱼，两天晒网，激情过后，留下的就是唯有迷茫。一个人要想取得成功，坚持是最基本的素养。</p>
</li>
<li><p>其实这里涉及到一个人自律的问题，体重和人生并没有实际的关联性，但必须肯定地是，一个能控制自己体重的人，确实是可怕又可敬的，他们身上都有着这样的特质。<br>如果你只有计划，只有目标是远远不够的，不行动那一切都是扯淡。我个人是比较讨厌和反感经常抱怨的人，抱怨不能改变什么，只会让你更加地消极。<br>可怜之人必有可恨之处，这句话用在一些整天喊着有才无门的人身上很适用。自己不去努力改变，别人能帮的了你一时，却不可能帮助你一辈子。<br>试着给自己制定一个计划，然后坚持去做一个月、两个月，到时候看看你能收获多少？</p>
</li>
<li><p>数据结构、网络、框架、数据库和分布式</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>spring cloud 相关问题</title>
    <url>/2019/07/23/md/problem/spring%20cloud/</url>
    <content><![CDATA[<p>使用新Greenwich.SR1部署 eureka server 时</p>
<h5 id="Caused-by-java-lang-ClassNotFoundException-com-sun-jersey-api-core-DefaultResourceConfig"><a href="#Caused-by-java-lang-ClassNotFoundException-com-sun-jersey-api-core-DefaultResourceConfig" class="headerlink" title="Caused by: java.lang.ClassNotFoundException: com.sun.jersey.api.core.DefaultResourceConfig"></a>Caused by: java.lang.ClassNotFoundException: com.sun.jersey.api.core.DefaultResourceConfig</h5><p>缺少jar</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-bundle<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>problem</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell redirect</title>
    <url>/2019/07/19/md/part/system/linux/shell-redirect/</url>
    <content><![CDATA[<p>Linux下使用shell命令时经常使用类似这样的Shell输出重定向:</p>
<p>1&gt;/dev/null 2&gt;&amp;1</p>
<p>在Shell命令的结尾，我们可以通过&gt;符号来重定向输出。</p>
<ol>
<li><p>标准输入stdin文件描述符为0，标准输出stdout文件描述符为1，标准错误stderr文件描述符为2</p>
</li>
<li><p>/dev/null 空设备文件，相当于垃圾桶</p>
</li>
<li><p>重定向符号：&gt;</p>
</li>
</ol>
<p>逐一解释上面的Shell重定向命令：</p>
<p>（1）  &gt;符号代表输出重定向</p>
<p>（2）  &gt;前面的数字:</p>
<p>0代表标准输入<br>1代表stdout标准输出，默认值为1，所以”1&gt;/dev/null”可以简写为”&gt;/dev/null”<br>2代表stderr标准错误输出</p>
<p>（3）2&gt;&amp;1代表把stderr标准错误输出 重定向 到stdout标准输出</p>
<p>所以，1&gt;/dev/null 2&gt;&amp;1的解释就是</p>
<p>将stdout标准输出重定向到空设备文件/dev/null ，同时将stderr标准错误输出的重定向跟stdout标准输出重定向一致，也输出到空设备文件/dev/null。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis相关问题</title>
    <url>/2019/07/11/md/problem/mybatis/</url>
    <content><![CDATA[<h3 id="mybatis报错-Specified-class-is-an-interface"><a href="#mybatis报错-Specified-class-is-an-interface" class="headerlink" title="mybatis报错 Specified class is an interface"></a>mybatis报错 Specified class is an interface</h3><h4 id="1-错误原因"><a href="#1-错误原因" class="headerlink" title="1.错误原因"></a>1.错误原因</h4><p>Caused by: org.springframework.beans.factory.BeanCreationException: </p>
<p>Error creating bean with name ‘admUserMapper’ defined in file<br>[E:\idea_soft\workspace\xxxx-mircoservices\i\classes\main\com\imassbank\admin\mapper\AdmUserMapper-\classes\main\com\admin\mapper\AdmUserMapper.class]:<br>Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: </p>
<p>Failed to instantiate [com.xxxxxx.mapper.AdmUserMapper]: Specified class is an interface</p>
<h4 id="2-原因以及解决方案"><a href="#2-原因以及解决方案" class="headerlink" title="2.原因以及解决方案"></a>2.原因以及解决方案</h4><p>1）原因: Mapper有重复的  例如  AdmUserMapper   在 a工程中有  但是 在b工程中  并且 叫相同的名字   导致  spring 在加载时 调用mapper解析器 导致出错</p>
<blockquote>
<p>Mapper报错的名称可能不对,如上文AdmUserMapper,可能其他Mapper重复导致</p>
</blockquote>
]]></content>
      <tags>
        <tag>problem</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot</title>
    <url>/2019/07/11/md/problem/spring-boot/</url>
    <content><![CDATA[<h3 id="Springboot-Filter中注入bean-无效为null"><a href="#Springboot-Filter中注入bean-无效为null" class="headerlink" title="Springboot Filter中注入bean 无效为null"></a>Springboot Filter中注入bean 无效为null</h3><p>问题原因：</p>
<p>Web应用的启动顺序是：Lisenter-&gt;Fliter-&gt;Servlet,  应用程序上下文， 初始化 Fliter的时候，还没有初始化Servlert，所有没有进入DispacterServlet的初始化，故在Fliter中使用注解注入bean为空；</p>
<p>解决办法：</p>
<p>添加初始化bean配置，手动创建对象new</p>
]]></content>
      <tags>
        <tag>problem</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>go优缺点</title>
    <url>/2019/07/10/md/langu/go/go/</url>
    <content><![CDATA[<p>使用 Go 语言的<code>缺点</code></p>
<ul>
<li>缺少框架</li>
<li>错误处理</li>
<li>软件包管理</li>
</ul>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>部署方式</title>
    <url>/2019/07/09/md/part/cicd/%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="金丝雀部署"><a href="#金丝雀部署" class="headerlink" title="金丝雀部署"></a>金丝雀部署</h3><p>先部署单台服务器，金丝雀测试（国内常称灰度测试）通过，则全部部署<br>简单的金丝雀测试一般通过手工测试验证，复杂的金丝雀测试需要比较完善的监控基础设施配合，通过监控指标反馈，观察金丝雀的健康状况，作为后续发布或回退的依据  </p>
<blockquote>
<p><code>优势</code> ： 用户体验影响小，体验较平滑  </p>
</blockquote>
<blockquote>
<p><code>不足</code>：发布自动化程度不够，发布期间可引发服务中断</p>
</blockquote>
]]></content>
      <tags>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>docker相关问题</title>
    <url>/2019/07/08/md/problem/docker/</url>
    <content><![CDATA[<h3 id="docker构建脚本报：-Syntax-error-end-of-file-unexpected-expecting-“then”"><a href="#docker构建脚本报：-Syntax-error-end-of-file-unexpected-expecting-“then”" class="headerlink" title="docker构建脚本报：  Syntax error : end of file unexpected (expecting “then”)"></a>docker构建脚本报：  Syntax error : end of file unexpected (expecting “then”)</h3><blockquote>
<p>用vim   操作 startup.sh  :set fileformat=unix修改ubuntu 和linux服务器、 dos等非图形界面冲突<br>:wq保存</p>
</blockquote>
]]></content>
      <tags>
        <tag>problem</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>vim使用</title>
    <url>/2019/07/08/md/tool/vim/</url>
    <content><![CDATA[<h3 id="vim中文乱码"><a href="#vim中文乱码" class="headerlink" title="vim中文乱码"></a>vim中文乱码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##配置文件，开头添加以下配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> termencoding=utf-8</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> encoding=utf-8</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查找SHELL的进程号并杀死</title>
    <url>/2019/06/21/md/part/system/linux/find%20progress%20kill/</url>
    <content><![CDATA[<h3 id="shell查找进程并杀死"><a href="#shell查找进程并杀死" class="headerlink" title="shell查找进程并杀死"></a>shell查找进程并杀死</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">tomcat_id=`ps -ef | grep tomcat | grep -v "grep" | awk '&#123;print $2&#125;'`</span></pre></td></tr><tr><td class="code"><pre><span class="line">echo $tomcat_id</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">for id in $tomcat_id</span></pre></td></tr><tr><td class="code"><pre><span class="line">do</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kill -9 $id  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    echo "killed $id"  </span></pre></td></tr><tr><td class="code"><pre><span class="line">done</span></pre></td></tr></table></figure>
<blockquote>
<p>注意：tomcat表示要查找的程序进程名，如：tomcat、8081端口、redis等等。</p>
</blockquote>
<h3 id="linux查找进程并杀死"><a href="#linux查找进程并杀死" class="headerlink" title="linux查找进程并杀死"></a>linux查找进程并杀死</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####查找tomcat进程</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ps -ef | grep tomcat | grep -v grep | awk '&#123;print $2&#125;'</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####查找tomcat进程并杀死</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ps -ef | grep tomcat | grep -v grep | awk '&#123;print $2&#125;' | xargs kill -9</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>情商50则</title>
    <url>/2019/06/21/md/life/%E6%83%85%E5%95%8650%E5%88%99/</url>
    <content><![CDATA[<p>1，话别说太满，人别熟太快。<br>3，不要把别人想得太坏，也不要把别人想得太好，都是凡人。<br>2，别人自嘲可以，但你千万别附和<br>4，可以嘲笑你的朋友，但不能嘲笑他喜欢的东西。  </p>
<h2 id="34，自嘲是最高境界，而不是嘲笑别人。"><a href="#34，自嘲是最高境界，而不是嘲笑别人。" class="headerlink" title="34，自嘲是最高境界，而不是嘲笑别人。  "></a>34，自嘲是最高境界，而不是嘲笑别人。  </h2><p>6，刚开始和对方不熟悉的时候，聊到晚上十点多对方发来消息就别回复了，第二天早晨再回复，这样又可以聊一天。<br>7，把“随便”改成“听你的”。<br>23，把“听明白了吗”换成“我说明白了吗”。<br>5，把每一句“我不会”都改成“我可以学”<br>把“谢谢”改成“谢谢你” 并微笑看着对方的眼睛    </p>
<hr>
<p>8，别人骂你你要听，别人夸你你别信。<br>9，请道歉而不是取笑别人开不起玩笑，你以为谁没有底线只不过还没到底而已。<br>10，聊天时别人发微笑，你不知道怎么回的话，就回，你笑得真好看。<br>11，能用表情包解决的就不要说脏话！<br>12，恰到好处的装逼，适可而止的套路。  </p>
<p>13，如果一个人不理你，有可能是对方的问题；如果大家都不理你，那你就要考虑自身问题了。 </p>
<hr>
<p>14，人前不应该说的话，背后也别说。<br>27，不要在公众场合揭别人的短处，让别人难堪。<br>35，请不要随意出卖一个朋友的隐私来取悦另一个不熟的朋友。<br>46，不要人后捅刀子嘴别贱。  </p>
<hr>
<p>15，在最愤怒时忍住最伤人对方的那句话。<br>17，不要把负能量带给身边的人。<br>18，不要吝啬你的赞美和表达爱意的语言。<br>40，越是亲近的人越要用心对待，一句随意的话会伤害她。<br>42，千万不要为了恋爱而淡了身边所有人。<br>21，真的不必把太多人请进生命里，太多热情总是不被珍惜。  </p>
<hr>
<p>16，如果没有十足的把握和必要，就不要轻易说假话。<br>19，女孩子永远抗拒不了陪她通宵聊天的人。<br>20，刻薄嘴欠和幽默是两回事；口无遮拦和坦率是两回事；没有教养和随性是两回事；轻重不分和耿直是两回事。  </p>
<hr>
<p>22，如果遇到了傻Ⅹ，不要与他争论，而且要同意他的一切观点，把他培养成大傻Ⅹ。<br>24，不能侮辱别人的idol，谨记！<br>47，践踏别人的梦想等同于谋杀。  </p>
<hr>
<p>25，在拒绝这件事上，越简单越好，明明是别人需求自己帮忙，解释半天变成自己亏欠了别人的感觉，帮得上，想帮就帮，帮不上，就拒绝。人际交往，简单明了有时最恰当，懂得拒绝，才可以洒脱不纠结。<br>33，学会拒绝，没人会感激你的善良，他们只会得寸进尺。  </p>
<hr>
<p>26，逢人只说三分话，未可全抛一片心。<br>29，看透不说透，还是好朋友。<br>39，最印象的一句话，“交友不必言尽，言尽则无友”  </p>
<hr>
<p>28，社交没那么容易，每个人都有他的手机。<br>30，当你往上爬的时候对别人好一点，因为你走下坡路的时候会遇到他们。</p>
<hr>
<p>31，颜值要高，脾气要好，原则要有。<br>36，有分寸的信任，有理由的怀疑。<br>37，把身材练好，把妆化好。<br>41，修得豆腐嘴，藏得刀子心。<br>43，清醒时做事，糊涂时读书，大怒时睡觉，独处时思考。  </p>
<hr>
<p>32，该叫阿姨的叫姐，该叫姐的叫美女该叫美女的叫妹子。<br>38，不会讲话时别瞎说沉默微笑更好。<br>44，永远不要听信别人口中的他。<br>45，女生之间的嫉妒心太可怕，不要公开说这个女生比那个好看。<br>48，常与同好争高下，不共傻瓜论短长。——出自《欢乐颂》  </p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>生活中有哪些残忍的真相</title>
    <url>/2019/06/21/md/life/%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%AE%8B%E5%BF%8D%E7%9A%84%E7%9C%9F%E7%9B%B8/</url>
    <content><![CDATA[<p>1、如果你八岁，十八岁，二十八岁都没有漂亮起来，那这辈子大概率就没法好看了（男生同理）</p>
<p>解：变有钱，变有内涵，变豁达，提升好看概率，实在不行，提升自己看得开的能力。</p>
<p>2、大部分人终其一生都不能拥有及格的原生家庭，及格的校园生活，及格的职场发展，以及及格的婚姻和后代</p>
<p>解：降低及格线，严以律己宽以待人，庸人不自扰。</p>
<p>3、迷茫是人生80%的状态，剩下的百分之二十，都是一些俗不可耐的目标，比如考大学，比如找工作，比如谈对象，比如买房买车生孩子，恰恰是这些俗不可耐的目标才能暂时将你从迷茫的状态里拯救出来。</p>
<p>解：做好当下一件事，接受迷茫的状态但不沉沦，或者试试把共产主义作为新的理想？</p>
<p>4、算计，衡量，比较，得失利弊分析将贯穿大部分人的一生，洒脱，率性而为是很多人向往的状态，却很难做到。</p>
<p>解：算计过程，衡量结果，但是不算计人心，不衡量感情。洒脱有时候真的意味着卸下很多责任，但凡人在世，岂能没有责任？</p>
<p>5、攒钱，省吃俭用其实才是大部分人的生存之道，不然你以为拼多多是怎么火起来的，我听过投资需谨慎，理财有风险的，可从没听说过攒钱有风险，储蓄需谨慎的。</p>
<p>解：没人知道十年后房价暴涨，与其遗憾，不如适当积蓄，给自己一个底气。</p>
<p>6、有时候感情双方都是彼此的Plan B，却还要在婚礼上宣誓此生唯一。</p>
<p>解：Plan B也是Plan，因为A计划失败，不得不启动B计划，还记得第一个发明可乐的人吗，他的A计划是止咳药来着，但是B计划更盈利不是吗？</p>
<p>7、孩子比较爱父母的时候一般是自己无助的时候，父母比较爱孩子的时候一般是自己比较得意的时候。所以事业生活不顺的家长大多会打骂孩子，而混的风生水起的孩子容易忽略父母。（是的，就是这么扎心，父母子女之间的爱也有爱得可以为对方死，非常爱，比较爱，一般爱，不爱，讨厌，恨，恨不得对方去死等不同等级）。</p>
<p>解：这是唯一一个无解的真相，只能参考第一题最后一句，提升自己看得开的能力。</p>
<p>8、养个不如意的孩子会严重影响夫妻感情，家庭关系，声称孩子是宝贝天使的父母，心里都在给自己孩子悄悄打分，这个分数一直能打到儿女退休那天，退休金高低也会成为最后一项得分。</p>
<p>解：养孩子之前，对自己进行充分评审和考核，确定孩子无论什么样，都不后悔做一遭父母，再带孩子来到这个世界上，如果只是把孩子当做自己人生的一个加分项，那说到底还是不配为人父母。</p>
<p>9、鄙视链真实存在于各行各业，各种阶层，而且处于鄙视链高层的人经常表态的一句话是：我并不觉得XXX的人会有这样的缺点，也不会看不起他们，只是阅历见识不同，三观不同，没法聊得来。潜台词就是：我鄙视你，我不要跟你玩！处于底层的人则经常说这样的话：他们不过是XXXX，其实不也是XXX，谁稀罕他们！潜台词就是：你们那边好像很好玩，为啥不喊我一起玩?！</p>
<p>解：努力成为鄙视链的上端，不然永远逃不脱鄙视链。</p>
<p>10、大多数人理智上知道嫉贤妒能是错误的，但感情上已经红了眼，会在各种打擦边球的地方做小动作，让如日中天的人稍微落下西山，然后还会自我安慰：这事情并不能怨我，我能做什么啊，根本不会影响到的。</p>
<p>解：得意时谨言慎行，失意时不落井下石，已经是很厉害的人了。</p>
<p>11、生活中也许会发生，但只要电视剧里作为主题来演的，那一定是小概率事件：比如穷人家女孩嫁给富二代；比如家徒四壁的穷孩子考上了清北；比如后爸后妈对孩子视如己出，辛苦养育，感人泪下；比如抱错孩子刚好其中一家是很有钱而由此引发的十八年后的二十集剧情；比如你爱的人刚好也爱你。。。。</p>
<p>因为不常发生，所以有演绎的价值，可惜蠢人总喜欢拿小概率事件当自家剧本，穷还不思进取，坐等孩子考清华，家庭矛盾都四分五裂了，还不快刀斩乱麻，就在那坐等突发事件发生，人设逆转然后阖家团圆（是的，点名批评最近热门剧“都挺好”的走向，这种剧情会麻痹多少病态的家庭，让他们误以为一切家庭乱象都会有这样的美好结尾）。</p>
<p>解：看清楚什么是小概率事件，才能在大多数不如意事情发生的时候泰然处之，而又能在小概率事情发生时珍惜美好的那一刻。</p>
<p>12、残忍的真相就是人人都知道真相，但还要合起来粉饰太平。</p>
<p>解：生活的本质是钟摆运动，两端是繁花似锦，中间是漫长的平平无奇，粉饰太平也许是在摆动至下一个美好节点期间能做的最大的努力。</p>
<p>罗曼罗兰那句耳熟能详的话作为结尾：There is only one heroism in the world: to see the world as it is and to love it.</p>
<p>我写的这个答案的确很扎心，但是这并不是本意，扎心只是一瞬的感触，剩下的时间里依然过好每一天，才是大部分人的选择，我想看过我答案的人，并不会因为这些答案扎心就放弃继续生活了吧。</p>
<p>我写的解其实也都是大多数人知道的道理，只是知道和做到，不是一回事，像我自己，扎心的真相都是我亲身经历，但是我也在努力践行我自己的英雄主义，与大家共勉。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>这就是人生</title>
    <url>/2019/06/21/md/life/thinking/%E8%BF%99%E5%B0%B1%E6%98%AF%E4%BA%BA%E7%94%9F/</url>
    <content><![CDATA[<p>孤独是人生的常态，一定要拥有真正喜欢的兴趣爱好，这样才能支持你渡过无数个漫漫长夜和无数个孤独的时候，读书则是成本最低的兴趣爱好。很多人看起来什么都感兴趣，啥都能参与一定点但都不深入，这种人是最孤独的，因为他根本不知道自己想要什么，喜欢什么。</p>
<p>绝大部分焦虑不过是脑子勤奋（想的太多）和身体懒惰之间的矛盾，自视甚高是人之常情，但一般要等到人到中年才能明白。20岁：我一定行——40岁：我本可以——60岁：我真的不行哎，是大部分人的人生轨迹。</p>
<p>一个人行不行可能早就注定了，比如家庭，比如言行举止，比如不经意间的流露……比如知乎的提问，大部分人都不懂得先问是不是再问为什么，大部分人都来懒的出奇，对自己不负责任，问的很随便，不说任何前提，不说任何自己情况，比如太多人问什么专业好、XX专业有没有前景、550分能读什么学校……只有这几个字，惜墨如金守口如瓶的，这些人将来基本上都会庸庸碌碌一辈子。因为思考意识具有决定性作用，跟年龄关系不大，如果你跟顶级中学的高中生聊过天 ，会发现她们比很多大学生有思想有见识，问问题的时候会把个人和家庭情况、问题背景、愿景交待的很清楚。</p>
<p>对于大部分人来说，体制内尤其是公务员是最好是工作，因为大部分人到了中年才会明白自己不过是庸人，是站在路边给别人喝彩，坐在台下给别人鼓掌的人，年轻时所谓的理想情怀豪言壮语只是对自己不了解，或者人云亦云。</p>
<p>大部分人一辈子也不会遇到轰轰烈烈荡气回肠的爱情，不过的找一个能接受的，不喜欢也不讨厌，甚至不那么讨厌的人将就着，婚姻，不过是人生的例行公事。</p>
<p>大部分失败的婚姻不是败给大是大非，而是日常再小不过的琐事，零刀子割肉没感觉，时间长了才会发现情感已经跌破发行价了。跟门当户对、经济条件、颜值相比，一个有趣的人开朗的人善良的人积极阳光的人，重要的多。大多数的婚姻失败不是大是大非的原则性问题，而是无数细枝末节的煎熬和落差，天长日久的日常摩擦，好的性格和心态，可以避免和减少大多数以上不快。</p>
<p>婚姻的真谛不只是爱，更多是忍受，求同存异，利弊权衡。</p>
<p>绝大多数人找的媳妇儿都不如大学里的恋人，能在大学找个媳妇儿就尽量，毕业后你会发现你根本找不到这么好的了，甚至可以让你越来越绝望。不被父母祝福的婚姻大概率是不会幸福的，尤其是远嫁、两人落差太大，都是一种孤军深入式的冒险。</p>
<p>没有遭遇大的意外，比如战争、大的天灾、绝症、残疾，有一份能养家糊口的工作就是一种幸福甚至幸运，当然你不会觉察到，直到失去。大部分人一辈子也没有一个真正的爱好，没有被谁真爱过，真爱过谁，没有痛痛快快哭过笑过，都是复制黏贴型人生。</p>
<p>绝大多数人都有阴暗面，即便一辈子不为人所知。人性是最不靠谱的东西，法律和契约最实实在在的。</p>
<p>大多数人一辈子也没有真正的朋友，所谓的朋友不过是同学、同事、同行、熟人甚至亲戚邻居身份的外延，别看平时亲密热烈，你好我好，一遇到事情，朋友二字就褪色了。朋友也不是人生的标配，友情也不是一成不变的，因为每个人都是在变化之中，当再次见面时，大家说着言不由衷的话，去没有什么交集时，就让这份友情活在对往事的回忆中去吧。</p>
<p>除了父母，真的很少有人想你好，大部分人盼你倒大霉。</p>
<p>大部分人都会受父母的影响，这种影响是骨子里的，越想摆脱越摆脱不了，会草蛇灰线伏延几十年，尤其是人到中年，有一天会突然发现自己变成了讨厌的模样，被父母附体。</p>
<p>大部分人，一辈子和文艺也没有交集，看电影看个热闹，听音乐听个响，看书图个刺激，虽然朋友圈都是纳兰容若、尼采。文艺青年大都会在潦倒、衰败、激愤、穷酸中渡过一生。</p>
<p>出轨、堕落是一种戒不了毒，不要指望用感动、谅解、宽恕去改变，当然也有回头是岸立地成佛的，但概率低到你不敢冒险。</p>
<p>知乎大部分故事都是假的，教人月入XX年入XX大都是收智商税的，推荐的东西大部分用处不大，思维、决策、分析等高赞文章大都是自问自答，也是心理学管理学书社会学籍上都有的，基本上属于收藏不看系列。</p>
<p>残忍归残忍，可日子也得过不是，罗曼罗兰那句话不是都会背了嘛。其实也谈不上残忍，这就是真实的人生，只不过大部分人把生活想的太美好而已。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos配置的加载规则详解</title>
    <url>/2019/06/21/md/part/microServices/Nacos%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><ul>
<li>Data ID中的<code>alibaba-nacos-config-client</code>：对应客户端的配置<code>spring.cloud.nacos.config.prefix</code>，默认值为<code>${spring.application.name}</code>，即：服务名</li>
<li>Data ID中的<code>properties</code>：对应客户端的配置<code>spring.cloud.nacos.config.file-extension</code>，默认值为<code>properties</code></li>
<li>Group的值<code>DEFAULT_GROUP</code>：对应客户端的配置<code>spring.cloud.nacos.config.group</code>，默认值为<code>DEFAULT_GROUP</code></li>
</ul>
<p>在采用默认值的应用要加载的配置规则就是：<code>Data ID=${spring.application.name}.properties</code>，<code>Group=DEFAULT_GROUP</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">application:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">name:</span> <span class="string">alibaba-nacos-discovery-client</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment"># server discovery</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">cloud:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">nacos:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">discovery:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>linux压缩与解压</title>
    <url>/2019/06/21/md/part/system/linux/linux-tar/</url>
    <content><![CDATA[<h4 id="unzip解压"><a href="#unzip解压" class="headerlink" title="unzip解压"></a>unzip解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压window中压缩的文件，不会文件名包含中文乱码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">unzip -O CP936 xxx.zip</span></pre></td></tr></table></figure>

<h4 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h4><p>-c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p>
<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p>
<p>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出</p>
<p>下面的参数-f是必须的</p>
<p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<h4 id="tar-示例"><a href="#tar-示例" class="headerlink" title="tar 示例"></a>tar 示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#### 压缩</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg      // 将目录里所有jpg文件打包成tar.jpg</span></pre></td></tr><tr><td class="code"><pre><span class="line">tar –czf jpg.tar.gz *.jpg   // 将目录里所有jpg文件打包成jpg.tar后，生成gzip压缩过的包，命名为jpg.tar.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line">tar –cjf jpg.tar.bz2 *.jpg  // 将目录里所有jpg文件打包成jpg.tar后，生成bzip2压缩过的包，命名为jpg.tar.bz2</span></pre></td></tr><tr><td class="code"><pre><span class="line">tar –cZf jpg.tar.Z *.jpg    // 将目录里所有jpg文件打包成jpg.tar后，生成umcompress压缩过的包，命名为jpg.tar.Z</span></pre></td></tr><tr><td class="code"><pre><span class="line">rar a jpg.rar *.jpg         // rar格式的压缩，需要先下载rar for Linux</span></pre></td></tr><tr><td class="code"><pre><span class="line">zip -r  jpg.zip  *.jpg      // zip格式的压缩  -r 递归压缩</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###  解压</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tar –xvf file.tar           //解压 tar包</span></pre></td></tr><tr><td class="code"><pre><span class="line">tar -xzvf file.tar.gz       //解压tar.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line">tar -xjvf file.tar.bz2      //解压 tar.bz2</span></pre></td></tr><tr><td class="code"><pre><span class="line">tar –xZvf file.tar.Z -C /opt/dev      //解压tar.Z</span></pre></td></tr><tr><td class="code"><pre><span class="line">unrar e file.rar            //解压rar</span></pre></td></tr><tr><td class="code"><pre><span class="line">unzip file.zip -d /opt/dev             //解压zip</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>uml</title>
    <url>/2019/06/21/md/tool/uml/</url>
    <content><![CDATA[<h3 id="口决"><a href="#口决" class="headerlink" title="口决"></a>口决</h3><ul>
<li>虚箭实现实泛化</li>
<li>虚线依赖实关联</li>
<li>空菱聚合实组合</li>
</ul>
<h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><p>用一条带空心箭头的直接表示，通常在程序里面泛化表现为继承于非抽象类。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>用一条带实心箭头的虚线表示。通常程序里面实现关系表现为继承抽象类,或接口。</p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>用一条带空心菱形箭头的直线表示。与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。</p>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>用一条带实心菱形箭头直线表示，如果整体不存在了，部分也不复存在</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>用一套带箭头的虚线表示，描述一个对象在运行期间会用到另一个对象的关系。通常在程序里面通过构造函数、形参等体现。</p>
<h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>用一条直线表示，当然如果需要标明方向可以添加箭头，通常不会随着状态的变化而变化。通常在程序里面以类变量的方式表现。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>spring cloud gateway 入门</title>
    <url>/2019/06/21/md/part/microServices/spring%20cloud/spring%20cloud%20gateway%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 集成eureka --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--&lt;dependency&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    &lt;/dependency&gt;--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure>
<p>spring-cloud-gateway有两种配置方式，一种是在application.yml中配置，一种是使用@Bean对象注入。（注意：二者选其一）</p>
<h4 id="application-yml方式"><a href="#application-yml方式" class="headerlink" title="application.yml方式"></a>application.yml方式</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">cloud:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">gateway:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">routes:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">WEB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">uri:</span> <span class="string">http://127.0.0.1:8661</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">predicates:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="string">Path=/web/&#123;segment&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">filters:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="string">SetPath=/&#123;segment&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span></pre></td></tr></table></figure>

<h4 id="Bean对象注入配置方式"><a href="#Bean对象注入配置方式" class="headerlink" title="@Bean对象注入配置方式"></a>@Bean对象注入配置方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">routeLocator</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> builder.routes()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .route(<span class="string">"WEB"</span>, r -&gt; r.path(<span class="string">"/web/&#123;segment&#125;"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    .filters(f -&gt; f.setPath(<span class="string">"/&#123;segment&#125;"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    .uri(<span class="string">"http://127.0.0.1:8661"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .build();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>简要说明：</p>
<ul>
<li>id：路由的id，参数配置不要重复，如不配置，gateway会使用生成一个uuid代替。</li>
<li>uri：路由的目标地址。注意：uri地址后面不要加 “ / “</li>
<li>Path：配置路由的路径。比如：/web/{segment}则表示当访问<a href="http://127.0.0.1:8562/web/**时候路由的指定的uri上面" target="_blank" rel="noopener">http://127.0.0.1:8562/web/**时候路由的指定的uri上面</a></li>
<li>SetPath：在发起请求时，在路由请求路径后面加上web/后面的内容。如果不配置，将无法路由地址后缀/web/index，只能路由/web</li>
<li>StripPrefix 去掉转发根据路径web</li>
</ul>
]]></content>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务健康检查</title>
    <url>/2019/06/21/md/part/microServices/spring%20cloud/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启健康检查（需要spring-boot-starter-actuator依赖）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">eureka.client.healthcheck.enabled</span>=<span class="string">true</span></span></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#应用信息 /actuator/info</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">app:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">name:</span> <span class="string">@project.name@</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">description:</span> <span class="string">@project.description@</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">version:</span> <span class="string">@project.version@</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">encoding:</span> <span class="string">@project.build.sourceEncoding@</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">java:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">version:</span> <span class="string">@java.version@</span></span></pre></td></tr></table></figure>




<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>洁面-洗面奶</title>
    <url>/2019/06/21/md/life/%E7%94%B7%E5%A3%AB%E6%8A%A4%E8%82%A4/</url>
    <content><![CDATA[<p><strong>洁面-洗面奶</strong></p>
<p><strong>水温：一定选择和皮肤温度相近的水温</strong>，不要觉得夏天太热就用凉水，冬天太冷就用较烫的水，这都会刺激到皮肤；<strong>最后可以用稍凉一些的水收尾，达到收缩毛孔的效果。</strong></p>
<p><strong>手法：</strong>在脸上转圈打炮泡，注意T区等容易出油的部位可以多照顾一些，没什么好说的。</p>
<p><strong>时间：不低于30秒，不超过三分钟；</strong>不要觉得洗的时间越长越好。</p>
<p><strong>注意</strong>：洗完及时擦干脸上的水分，刚洗完脸，毛孔张开状态下，水分蒸发更容易带走皮肤的水分。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>事务的四种隔离级别</title>
    <url>/2019/06/21/md/part/db/trac-isolate/</url>
    <content><![CDATA[<h3 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h3><table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Read committed</td>
<td>√</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>√</td>
<td>√</td>
<td>X</td>
</tr>
<tr>
<td>Serializable</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>ISOLATION_READ_UNCOMMITTED</strong>：读未提交，这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。</p>
<pre><code>这种隔离级别会产生脏读，不可重复读和幻像读。、</code></pre></li>
<li><p><strong>ISOLATION_READ_COMMITTED</strong>：读已提交，保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</p>
</li>
<li><p><strong>ISOLATION_REPEATABLE_READ</strong>：可重复读，这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</p>
<pre><code>它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</code></pre></li>
<li><p><strong>ISOLATION_SERIALIZABLE</strong>：串行化，这是花费最高代价但是最可靠的事务隔离级别。事务被处理为<strong>顺序执行</strong>。</p>
<pre><code>除了防止脏读，不可重复读外，还避免了幻像读。 </code></pre></li>
</ol>
]]></content>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>问题日志</title>
    <url>/2019/06/20/md/problem/web/</url>
    <content><![CDATA[<h3 id="Invalid-character-found-in-method-name-HTTP-method-names-must-be-tokens-the-HTTP-protoco"><a href="#Invalid-character-found-in-method-name-HTTP-method-names-must-be-tokens-the-HTTP-protoco" class="headerlink" title="Invalid character found in method name. HTTP method names must be tokens|the HTTP protoco"></a>Invalid character found in method name. HTTP method names must be tokens|the HTTP protoco</h3><p><code>因为请求协议不对，需要统一成https或http请求</code></p>
<hr>
]]></content>
      <tags>
        <tag>problem</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>docker设计</title>
    <url>/2019/06/20/md/part/docker/docker-nexus/</url>
    <content><![CDATA[<p>docker run -tid -p 8081:8081 –name nexus  –restart=always  –privileged=true   -e NEXUS_CONTEXT=nexus -v /usr/local/nexus3/nexus-data:/nexus-data  docker.io/sonatype/nexus3 </p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker设计</title>
    <url>/2019/06/20/md/part/docker/docker%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h5 id="Docker通过引人分层文件系统构建和高效的镜像机制，降低了迁移难度"><a href="#Docker通过引人分层文件系统构建和高效的镜像机制，降低了迁移难度" class="headerlink" title="Docker通过引人分层文件系统构建和高效的镜像机制，降低了迁移难度"></a>Docker通过引人分层文件系统构建和高效的镜像机制，降低了迁移难度</h5>]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>dist文件使用</title>
    <url>/2019/06/19/md/part/web/js/dist%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="生成dist目录"><a href="#生成dist目录" class="headerlink" title="生成dist目录"></a>生成dist目录</h3><p>npm run build</p>
<h3 id="安装express-generator生成器"><a href="#安装express-generator生成器" class="headerlink" title="安装express-generator生成器"></a>安装express-generator生成器</h3><p>执行  $ npm install express-generator -g  进行安装  </p>
<h3 id="创建一个express项目"><a href="#创建一个express项目" class="headerlink" title="创建一个express项目"></a>创建一个express项目</h3><p>执行  $ express expressDemo （expressDemo是项目名）  </p>
<h3 id="进入expressDemo目录，安装项目依赖"><a href="#进入expressDemo目录，安装项目依赖" class="headerlink" title="进入expressDemo目录，安装项目依赖"></a>进入expressDemo目录，安装项目依赖</h3><p>npm install               </p>
<h3 id="把dist目录下的所有文件复制到express项目的public文件夹下"><a href="#把dist目录下的所有文件复制到express项目的public文件夹下" class="headerlink" title="把dist目录下的所有文件复制到express项目的public文件夹下"></a>把dist目录下的所有文件复制到express项目的public文件夹下</h3><p>然后运行 $ npm start 启动expressDemo<br>打开浏览器，输入 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>, 就可以看到效果了</p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>go介绍</title>
    <url>/2019/06/19/md/langu/go/go%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><strong>Go</strong>（又称<strong>Golang</strong>）是Google开发的一种<code>静态强类型</code>、<code>编译型</code>、<code>并发型</code>，并具有<code>垃圾回收</code>功能的编程语言。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行模型是以东尼·霍尔的<code>通信顺序进程</code>（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo，但它也具有Pi运算的特征，比如通道传输。在1.8版本中开放<code>插件</code>（Plugin）的支持，这意味着现在能从Go中<code>动态加载部分函数</code>。</p>
<p>Go内嵌了<code>关联数组</code>（也称为哈希表（Hashes）或字典（Dictionaries）），就像字符串类型一样</p>
<h3 id="撰写风格"><a href="#撰写风格" class="headerlink" title="撰写风格"></a>撰写风格</h3><p>在Go中有几项规定，而且这些是强制的，当不匹配以下规定时编译将会产生错误。</p>
<ul>
<li>每行程序结束后不需要撰写分号（;）。</li>
<li>大括号（{）不能够换行放置。</li>
<li>if判断式和for循环不需要以小括号包覆起来。</li>
</ul>
<blockquote>
<p>Go亦有内置gofmt工具，能够自动整理代码多余的空白、变量名称对齐、并将对齐空格转换成Tab</p>
</blockquote>
<h4 id="指针示例"><a href="#指针示例" class="headerlink" title="指针示例"></a>指针示例</h4><p>指针变量 <code>*</code> 和地址值 <code>&amp;</code> 的区别：指针变量保存的是一个地址值，会分配独立的内存来存储一个整型数字。当变量前面有 <code>*</code> 标识时，才等同于 <code>&amp;</code> 的用法，否则会直接输出一个整型数字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> ptr *<span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   ptr = &amp;a</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">println</span>(<span class="string">"a的值为"</span>, a);    <span class="comment">// 4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">println</span>(<span class="string">"*ptr为"</span>, *ptr);  <span class="comment">// 4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">println</span>(<span class="string">"ptr为"</span>, ptr);    <span class="comment">// 0xx000xx</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2019/06/18/md/tool/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>列表嵌套只需在子列表中的选项添加四个空格即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - 第一项嵌套的第一个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - 第一项嵌套的第二个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. 第二项：</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - 第二项嵌套的第一个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - 第二项嵌套的第一个元素</span></pre></td></tr></table></figure>

<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>一行字后面添加<code>两个空格</code>才换行</p>
<h4 id="添加链接"><a href="#添加链接" class="headerlink" title="添加链接"></a>添加链接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[链接文字](链接网址 &quot;标题&quot;)</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>支付流程</title>
    <url>/2019/06/18/md/busin/pay-flow/</url>
    <content><![CDATA[<ol>
<li>获取支付交易流水号</li>
<li>生成签名，拼成交易链接</li>
<li>支付成功，同步异步返回结果，异步每隔一段时间发送</li>
<li>修改完给支付宝返回success</li>
</ol>
]]></content>
      <tags>
        <tag>业务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2019/06/18/md/part/distributed/distribute-trac/</url>
    <content><![CDATA[<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ol>
<li>主流的关系型数据库产品都是实现了XA接口，事务管理器和资源管理器之间使用XA协议，JTA(Java Transaction API)。</li>
<li><code>TCC</code>   try  comfirm   cancel 。</li>
<li><code>本地消息表</code><br>采用定时轮询扫描的方式，去检查消息表的数据。</li>
<li><code>消息队列</code><br>采用时效性高的MQ，由对方订阅消息并监听，有消息时自动触发事件。</li>
<li><code>mq事务消息</code><br>RocketMQ<br>第一阶段发送Prepared消息时，会拿到消息的地址，<br>第二阶段执行本地事物，<br>第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。<br>如果确认消息发送失败了，RocketMQ会定期扫描消息集群中的事物消息，<br>这时候发现了Prepared消息，它会向消息发送者确认，<br>Bob的钱到底是减了还是没减呢，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。<br>这样就保证了消息发送与本地事务同时成功或同时失败。</li>
<li><code>补偿机制</code><br>只有当我们回调页面中输出了success字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。<br>否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。</li>
</ol>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>面试知识点确认</title>
    <url>/2019/06/18/md/interview/intervice-know-confirm/</url>
    <content><![CDATA[<p>socket多线程                     ok<br>netty底层nio，aio                ok<br>高并发                           ok<br>heh                       ok<br>事务控制多库多表操作             ok<br>spring cloud<br>soa                              ignore<br>jvm调优                          ok<br>类加载机制                       ok<br>gc机制                           ok<br>支付流程和注意点<br>spring的加载机制                 ok<br>tomcat加载机制                   ignore<br>做过的项目                       important</p>
<p>线程调度；多线程相关：多线程并发用到那哪些？线程数据共享；synchronize 用法，原理 ？死锁的原因，现场写了一下；（重点）</p>
<p>首先要了解高并发的的瓶颈在哪里？</p>
<p>1、可能是服务器网络带宽不够<br>增加网络带宽，添加CDN</p>
<p>2.可能web线程连接数不够<br>负载均衡，前置代理服务器Nginx，静态资源分离到另外一个服务器</p>
<p>3.可能数据库连接查询上不去。<br>优化数据库查询语句，explain之后，找出耗时多的点，添加索引。<br>数据库查询优化，读写分离，分表等等</p>
<p>4.使用缓存，比较固定长时间少更新的solr，短期的也可以用redis，memcache</p>
<p>最后复制一些在高并发下面需要常常需要处理的内容:</p>
<p>统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。</p>
<p>能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。</p>
<p>解决以上问题后，使用服务器集群来解决单台的瓶颈问题。</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>拦截器与Filter的区别</title>
    <url>/2019/06/18/md/other/Filter%E4%B8%8EHandle/</url>
    <content><![CDATA[<h3 id="拦截器与Filter的区别"><a href="#拦截器与Filter的区别" class="headerlink" title="拦截器与Filter的区别"></a>拦截器与Filter的区别</h3><ul>
<li><p>相似之处：都是AOP编程思想的体现，都能实现权限检查与日志记录等</p>
</li>
<li><p>不同之处：</p>
</li>
</ul>
<ol>
<li><p>使用范围不同</p>
<p>​    Filter是Servlet规范规定的，只能用于Web程序中</p>
<p>​    拦截器既可用于Web程序，与可用于Application,Swing程序中</p>
</li>
<li><p>规范不同</p>
<p>​    Filter是在Servlet规范定义的，是Servlet容器支持的.</p>
<p>​    而拦截器是在Spring容器内，是Spring框架支持的</p>
</li>
<li><p>使用资源不同</p>
<p>​    拦截器是Spring的一个组件，可以使用spring相关服务，如对象，事务，数据源</p>
<p>​    而Filter不能</p>
</li>
<li><p>深度不同<br>​    Filter在Servlet前后启作用，拦截器则可以在方法前后，异常抛出前后</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm内存加载和gc</title>
    <url>/2019/06/18/md/jdk/jvm/jvm-and-gc/</url>
    <content><![CDATA[<p>jvm比较重要的内存区域<br><code>方法区</code>：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。<br><code>常量池</code>：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。<br><code>堆区</code>：用于存放类的对象实例。<br><code>栈区</code>：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。<br>除了以上四个内存区域之外，jvm中的运行时内存区域还包括<code>本地方法栈</code>和<code>程序计数器</code></p>
<p>1）堆</p>
<p>所有通过new创建的对象的内存都在堆中分配，堆的大小可以通过-Xmx和-Xms来控制。<br>堆被划分为<code>新生代</code>和<code>旧生代</code>，新生代又被进一步划分为<code>Eden</code>和<code>Survivor</code>区，最后Survivor由From Space和To Space组成</p>
<p><code>新生代</code>。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，<br>新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例</p>
<p><code>旧生代</code>。在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p><code>持久代</code>。已经取消，JDK8 HotSpot JVM现在使用了本地内存来存储类元数据，被称为Metaspace。</p>
<p>2）栈<br>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。</p>
<p>3）本地方法栈<br>用于支持native方法的执行，存储了每个native方法调用的状态</p>
<p>4）方法区<br>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。</p>
<h3 id="基本回收算法"><a href="#基本回收算法" class="headerlink" title="基本回收算法"></a>基本回收算法</h3><h4 id="1-复制（Copying）"><a href="#1-复制（Copying）" class="headerlink" title="1. 复制（Copying）"></a>1. 复制（Copying）</h4><p>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。 </p>
<h4 id="2-标记-清除（Mark-Sweep）"><a href="#2-标记-清除（Mark-Sweep）" class="headerlink" title="2. 标记-清除（Mark-Sweep）"></a>2. 标记-清除（Mark-Sweep）</h4><p>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。 </p>
<h4 id="3-标记-整理（Mark-Compact）"><a href="#3-标记-整理（Mark-Compact）" class="headerlink" title="3. 标记-整理（Mark-Compact）"></a>3. 标记-整理（Mark-Compact）</h4><p>此算法结合了 “标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。 </p>
<h4 id="4-分代（Generational-Collecting）"><a href="#4-分代（Generational-Collecting）" class="headerlink" title="4. 分代（Generational Collecting）"></a>4. 分代（Generational Collecting）</h4><p>垃圾收集器<br>串行GC（Serial GC）、并行回收GC（Parallel Scavenge）和并发回收GC（ParNew）</p>
<p>GC有两种类型：<code>Scavenge GC</code>和<code>Full GC</code>。<br>JVM分别对新生代和旧生代采用不同的垃圾回收机制</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm编译类加载和执行</title>
    <url>/2019/06/18/md/jdk/jvm/jvm%E7%BC%96%E8%AF%91%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>JVM是Java Virtual Machine（Java虚拟机），Java虚拟机是实现跨平台这一特点的关键。</p>
<p>Java代码编译和执行的整个过程包含了以下三个重要的机制：</p>
<ol>
<li><code>Java源码编译机制</code></li>
<li><code>类加载机制</code></li>
<li><code>类执行机制</code></li>
</ol>
<h4 id="Java源码编译机制："><a href="#Java源码编译机制：" class="headerlink" title="Java源码编译机制："></a>Java源码编译机制：</h4><ol>
<li>分析和输入到符号表</li>
<li>注解处理</li>
<li>语义分析和生成class文件</li>
</ol>
<p>class文件包括结构信息。包括class文件格式版本号及各部分的数量与大小的信息元数据。对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池<br>方法信息。对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</p>
<hr>
<h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><p>JVM的类加载是通过ClassLoader及其子类来完成的<br>1.Bootstrap ClassLoader<br>负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class<br>2.Extension ClassLoader<br>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包<br>3.App ClassLoader<br>负责记载classpath中指定的jar包及目录中class<br>4.Custom ClassLoader<br>属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</p>
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
<h4 id="类执行机制"><a href="#类执行机制" class="headerlink" title="类执行机制"></a>类执行机制</h4><p>JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果</p>
<p>类加载生命周期<br><code>加载</code>、<code>连接</code>、<code>初始化</code>、<code>使用</code>、<code>卸载</code><br>hotspot虚拟机是当真正用到一个类的时候才对它进行加载。</p>
<h5 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h5><p> 找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象</p>
<ol>
<li>通过一个类的全限定名（包名与类名）来获取定义此类的二进制字节流（Class文件）。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><ul>
<li>验证：验证被加载后的类是否有正确的结构，类数据是否会符合虚拟机的要求，确保不会危害虚拟机安全。</li>
<li>准备：为类的静态变量（static filed）在方法区分配内存，并赋默认初值（0值或null值）。静态常量（static final filed）会在准备阶段赋程序设定的初值，如static final int a = 666;  静态常量a就会在准备阶段被直接赋值为666，对于静态变量，这个操作是在初始化阶段进行的。</li>
<li>解析：将类的二进制数据中的符号引用换为直接引用。在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。</li>
</ul>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化阶段才真正执行Java代码。<br>类的初始化的主要工作是为静态变量赋程序设定的初值。<br>没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。</p>
<hr>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><h5 id="执行过程简介"><a href="#执行过程简介" class="headerlink" title="执行过程简介"></a>执行过程简介</h5><p>当编译和连接一个C++程序时，所获得的可执行二进制文件只能在指定的硬件平台和操作系统上运行，因为这个二进制文件包含了对目标处理器的机器语言。而Java编译器把Java源文件的指令翻译成字节码，这种字节码就是Java虚拟机的“机器语言”。<br>与普通程序不同的是，Java程序（class文件）并不是本地的可执行程序。当运行Java程序时，首先运行JVM（Java虚拟机），然后再把Java class加载到JVM里头运行，负责加载Java class的这部分就叫做Class Loader。</p>
<h5 id="JVM中的ClassLoader"><a href="#JVM中的ClassLoader" class="headerlink" title="JVM中的ClassLoader"></a>JVM中的ClassLoader</h5><p>JVM本身包含了一个ClassLoader称为<code>BootstrapClassLoader</code>，和JVM一样，BootstrapClassLoader是用本地代码实现的，它负责加载核心JavaClass（即所有java.<em>开头的类）。另外JVM还会提供两个ClassLoader，它们都是用Java语言编写的，由BootstrapClassLoader加载；其中<code>ExtensionClassLoader</code>负责加载扩展的Javaclass（例如所有javax.</em>开头的类和存放在JRE的ext目录下的类）<code>ApplicationClassLoader</code>负责加载应用程序自身的类。<br>当运行一个程序的时候，JVM启动，运行bootstrapclassloader，该ClassLoader加载java核心API（ExtClassLoader和AppClassLoader也在此时被加载），然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class，这就是一个程序最基本的加载流程。</p>
<h5 id="执行ClassLoader例子"><a href="#执行ClassLoader例子" class="headerlink" title="执行ClassLoader例子"></a>执行ClassLoader例子</h5><p>什么时候JVM会使用ClassLoader加载一个类呢？当你使用java去执行一个类，JVM使用ApplicationClassLoader加载这个类；然后如果类A引用了类B，不管是直接引用还是用Class.forName()引用，JVM就会找到加载类A的ClassLoader，并用这个ClassLoader来加载类B。JVM按照运行时的有效执行语句，来决定是否需要装载新类，从而装载尽可能少的类，这一点和编译类是不相同的。</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程概要</title>
    <url>/2019/06/18/md/jdk/mulThread/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>多线程只有一个目的：更好的利用cpu的资源</p>
<ul>
<li><p>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</p>
</li>
<li><p>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。</p>
</li>
<li><p>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。</p>
</li>
<li><p>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如简单加入@synchronized关键字。</p>
</li>
</ul>
<p><strong>阻塞(Blocked)</strong>：</p>
<ol>
<li>调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</li>
<li>调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）</li>
<li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li>
</ol>
<p>Thread类中的yield方法可以让一个running状态的线程转入runnable。</p>
<ul>
<li>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会，可能无效，又选择了让步的线程。</li>
<li>join()在一个线程中调用other.join(),将等待other执行完后才继续本线程。</li>
<li>interrupted方法其本质只是设置该线程的中断标志，真正实现线程的中断原理是：开发人员根据中断标志的具体值，来决定如何退出线程。</li>
<li>stop方法会中断一个正在运行的线程</li>
</ul>
<p>synchronized, wait, notify 是任何对象都具有的同步工具<br>monitor 在synchronized 范围内，监视器发挥作用<br>wait/notify必须存在于synchronized块，这三个关键字针对的是同一个监视器，意味着wait之后，其他线程可以进入同步块执行。</p>
<p><code>volatile 多线程的内存模型</code>：<br>main memory（主存）、working memory（线程栈）<br>在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。</p>
<h3 id="多线程包-java-util-concurrent"><a href="#多线程包-java-util-concurrent" class="headerlink" title="多线程包:java.util.concurrent"></a>多线程包:java.util.concurrent</h3><p><code>ThreadLocal类</code>，每个使用该变量的线程提供独立的变量副本，常用于用户登录控制，如记录session信息<br>每个Thread都持有一个TreadLocalMap类型的变量</p>
<p><code>原子类</code>（AtomicInteger、AtomicBoolean……）等同于synchronized，AtomicInteger.compareAndSet(int expect,int update)可实现乐观锁   </p>
<h4 id="Lock类"><a href="#Lock类" class="headerlink" title="Lock类"></a>Lock类</h4><p>ReentrantLock<br>ReentrantReadWriteLock.ReadLock<br>ReentrantReadWriteLock.WriteLock<br>lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本<br>r.lock()或r.lockInterruptibly()<br>r.unlock()<br>ReentrantReadWriteLock，写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码</p>
<h4 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h4><p>BlockingQueue 这个queue是单向队列，特别适用于先进先出策略的一些应用场景，BlockingQueue在队列的基础上添加了多线程协作的功能，提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器<br>常见的阻塞队列有：<br><code>ArrayListBlockingQueue</code><br><code>LinkedListBlockingQueue</code><br><code>DelayQueue</code><br><code>SynchronousQueue</code><br><code>ConcurrentHashMap</code>  </p>
<p>高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap</p>
<p><strong>HashMap</strong><br>put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象<br>put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象<br>HashMap是在bucket中储存键对象和值对象</p>
<h4 id="线程池管理类ThreadPoolExecutor"><a href="#线程池管理类ThreadPoolExecutor" class="headerlink" title="线程池管理类ThreadPoolExecutor"></a>线程池管理类ThreadPoolExecutor</h4><p>corePoolSize:池内线程初始值与最小值，就算是空闲状态，也会保持该数量线程。<br>maximumPoolSize:线程最大值，线程的增长始终不会超过该值。<br>keepAliveTime：当池内线程数高于corePoolSize时，经过多少时间多余的空闲线程才会被回收。回收前处于wait状态<br>unit：时间单位，可以使用TimeUnit的实例，如TimeUnit.MILLISECONDS。<br>workQueue:待入任务（Runnable）的等待场所，该参数主要影响调度策略，如公平与否，是否产生饿(starving)  。<br>threadFactory:线程工厂类，有默认实现，如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。   </p>
<p>有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。</p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Sidecar模式：下一代微服务架构的关键</title>
    <url>/2019/06/18/md/part/microServices/Sidecar/</url>
    <content><![CDATA[<h1 id="Sidecar模式：下一代微服务架构的关键"><a href="#Sidecar模式：下一代微服务架构的关键" class="headerlink" title="Sidecar模式：下一代微服务架构的关键"></a>Sidecar模式：下一代微服务架构的关键</h1><h2 id="什么是Sidecar模式？"><a href="#什么是Sidecar模式？" class="headerlink" title="什么是Sidecar模式？"></a>什么是Sidecar模式？</h2><p>Sidecar模式是一种将应用功能从应用本身剥离出来作为单独进程的方式。该模式允许我们向应用无侵入添加多种功能，避免了为满足第三方组件需求而向应用添加额外的配置代码。</p>
<p>就像边车加装在摩托车上一样，在软件架构中，sidecar附加到主应用，或者叫父应用上，以扩展/增强功能特性，同时Sidecar与主应用是松耦合的。</p>
<p>举个例子，假设现在有6个相互通信的微服务，每个微服务都需要具有可观察性、监控、日志记录、配置、断路器等功能，而所有这些功能都是在微服务中使用一些第三方库实现的。</p>
<p>这样一组服务的实际情况可能会非常复杂，增加了应用的整体复杂性，尤其是当每个微服务用不同的语言编写、使用不同的基于.net、Java、Python等语言的第三方库</p>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务优缺点</title>
    <url>/2019/06/18/md/part/microServices/feture/</url>
    <content><![CDATA[<p>微服务有如下<br>####优点</p>
<ul>
<li>微服务是松藕合的，无论是在开发阶段或部署阶段都是独立的。</li>
<li>能够快速响应, 局部修改容易, 一个服务出现问题不会影响整个应用。</li>
<li>易于和第三方应用系统集成, 支持使用不同的语言开发, 允许你利用融合最新技术。</li>
<li>每个微服务都很小，足够内聚，足够小，代码容易理解。团队能够更关注自己的工作成果, 聚焦指定的业务功能或业务需求。</li>
<li>开发简单、开发效率提高，一个服务可能就是专一的只干一件事, 能够被小团队单独开发，这个小团队可以是 2 到 5 人的开发人员组成。<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3>微服务架构带来过多的运维操作, 可能需要团队具备一定的 DevOps 技巧.<br>分布式系统可能复杂难以管理。因为分布部署跟踪问题难。当服务数量增加，管理复杂性增加。</li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix Turbine</title>
    <url>/2019/06/18/md/part/microServices/spring%20cloud/Hystrix%20Turbine/</url>
    <content><![CDATA[<h3 id="Hystrix-Turbine简介"><a href="#Hystrix-Turbine简介" class="headerlink" title="Hystrix Turbine简介"></a>Hystrix Turbine简介</h3><p>看单个的Hystrix Dashboard的数据并没有什么多大的价值，要想看这个系统的Hystrix Dashboard数据就需要用到Hystrix Turbine。Hystrix Turbine将每个服务Hystrix Dashboard数据进行了整合。Hystrix Turbine的使用非常简单，只需要引入相应的依赖和加上注解和配置就可以了。</p>
<h3 id="引入相应的依赖"><a href="#引入相应的依赖" class="headerlink" title="引入相应的依赖"></a>引入相应的依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure>

<hr>
<p>在其入口类ServiceTurbineApplication加上注解@EnableTurbine，开启turbine，@EnableTurbine注解包含了@EnableDiscoveryClient注解，即开启了注册服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTurbine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTurbineApplication</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ServiceTurbineApplication<span class="class">.<span class="keyword">class</span>).<span class="title">web</span>(<span class="title">true</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<hr>
<p>配置文件application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">application.name:</span> <span class="string">service-turbine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">port:</span> <span class="number">8769</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">security.basic.enabled:</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">aggregator:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">clusterConfig:</span> <span class="string">default</span>   <span class="comment"># 指定聚合哪些集群，多个使用","分割，默认为default。可使用http://.../turbine.stream?cluster=&#123;clusterConfig之一&#125;访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">appConfig:</span> <span class="string">service-hi,service-lucy</span>  <span class="comment">### 配置Eureka中的serviceId列表，表明监控哪些服务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">clusterNameExpression:</span> <span class="string">new</span> <span class="string">String("default")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment"># 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment"># 2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment"># 3. 当clusterNameExpression: metadata['cluster']时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">client:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">serviceUrl:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span></pre></td></tr></table></figure>



<p>输入监控流<a href="http://localhost:8769/turbine.stream" target="_blank" rel="noopener">http://localhost:8769/turbine.stream</a></p>
]]></content>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>db</title>
    <url>/2019/06/18/md/part/db/db/</url>
    <content><![CDATA[<h3 id="为什么数据库可以没有外键？"><a href="#为什么数据库可以没有外键？" class="headerlink" title="为什么数据库可以没有外键？"></a>为什么数据库可以没有外键？</h3><ul>
<li>性能，影响插入、更新和删除操作的性能。数据库需要检查它是否违反数据完整性</li>
<li>传统数据，许多数据库在设计时需要存储来自旧数据库和遗留数据，这些数据可能对数据质量和完整性没有那么严格</li>
<li>全表重新加载</li>
</ul>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p>
<p>【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，<br>保证被关联的字段需要有索引。</p>
<p>【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)就是 SQL92 定义的<br>标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<p>使用 IS NULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。</p>
<p>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p>
<p>MySQL的基本存储结构是页(记录都存在页里边)：<br>各页：双向链表<br>页内数据：单向链表</p>
<p><img src="https://www.mqiy.xyz/image/db/mysql-lock.png" alt="mysql-lock.png"></p>
]]></content>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>mariadb</title>
    <url>/2019/06/18/md/part/db/maria/</url>
    <content><![CDATA[<h3 id="maven-配置"><a href="#maven-配置" class="headerlink" title="maven 配置"></a>maven 配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mariadb.jdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mariadb-java-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="jdbc设置"><a href="#jdbc设置" class="headerlink" title="jdbc设置"></a>jdbc设置</h3><table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>driver-class-name</td>
<td>org.mariadb.jdbc.Driver</td>
</tr>
<tr>
<td>url</td>
<td>jdbc:mariadb://localhost:3306/test</td>
</tr>
</tbody></table>
<hr>
<h3 id="Linux下MySQL表名不区分大小写的设置方法"><a href="#Linux下MySQL表名不区分大小写的设置方法" class="headerlink" title="Linux下MySQL表名不区分大小写的设置方法"></a>Linux下MySQL表名不区分大小写的设置方法</h3><ol>
<li>用root登录，打开并修改 /etc/my.cnf；在[mysqld]节点下，加入一行： lower_case_table_names=1。</li>
<li>重启mysql服务</li>
</ol>
<p>[^]: lower_case_table_names=1 参数缺省地在 Windows 中这个选项为 1 ，在 Unix 中为 0</p>
]]></content>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL explanin命令</title>
    <url>/2019/06/18/md/part/db/mysql-tool/</url>
    <content><![CDATA[<p>sql  explanin命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 备份数据库 mayday</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mysqldump -uroot -pAdmin123# mayday  &gt; bk.sql</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>linux安装mariadb</title>
    <url>/2019/06/18/md/part/system/linux/linux-install-mariadb/</url>
    <content><![CDATA[<h3 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h3><p>安装命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install mariadb mariadb-server</span></pre></td></tr></table></figure>

<p>安装完成MariaDB，首先启动MariaDB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start mariadb</span></pre></td></tr></table></figure>

<p>设置开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable mariadb</span></pre></td></tr></table></figure>

<p>接下来进行MariaDB的相关简单配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span></pre></td></tr></table></figure>



<p>初始化MariaDB完成，接下来测试登录</p>
<p>mysql -uroot -ppassword</p>
<h3 id="配置MariaDB的字符集"><a href="#配置MariaDB的字符集" class="headerlink" title="配置MariaDB的字符集"></a>配置MariaDB的字符集</h3><p>文件/etc/my.cnf</p>
<p>在[mysqld]标签下添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">init_connect</span>=<span class="string">'SET collation_connection = utf8mb4_unicode_ci'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">init_connect</span>=<span class="string">'SET NAMES utf8mb4'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">character_set_server</span>=<span class="string">utf8mb4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">collation-server</span>=<span class="string">utf8mb4_unicode_ci</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">init_connect</span>=<span class="string">'SET NAMES utf8mb4'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">skip-character-set-client-handshake</span>=<span class="string">true</span></span></pre></td></tr></table></figure>

<hr>
<p>文件/etc/my.cnf.d/client.cnf</p>
<p>在[client]中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">default-character-set</span>=<span class="string">utf8mb4</span></span></pre></td></tr></table></figure>
<hr>
<p>文件/etc/my.cnf.d/mysql-clients.cnf</p>
<p>在[mysql]中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">default-character-set</span>=<span class="string">utf8mb4</span></span></pre></td></tr></table></figure>



<p> 全部配置完成，重启mariadb</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mariadb</span></pre></td></tr></table></figure>

<p>之后进入MariaDB查看字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show variables like "%character%";show variables like "%collation%";</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">| Variable_name | Value |</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">| character_set_client | utf8 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| character_set_connection | utf8 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| character_set_database | latin1 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| character_set_filesystem | binary |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| character_set_results | utf8 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| character_set_server | latin1 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| character_set_system | utf8 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| character_sets_dir | /usr/share/mysql/charsets/ |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">----------------------+-------------------+</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">| Variable_name | <span class="keyword">Value</span> |</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">----------------------+-------------------+</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">| collation_connection | utf8_general_ci |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| collation_database | latin1_swedish_ci |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| collation_server | latin1_swedish_ci |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">----------------------+-------------------+</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span></pre></td></tr></table></figure>



<h4 id="修改DB的默认编码："><a href="#修改DB的默认编码：" class="headerlink" title="修改DB的默认编码："></a>修改DB的默认编码：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> XX_db <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>db</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>need attention</title>
    <url>/2019/06/18/md/other/need%20attention/</url>
    <content><![CDATA[<h4 id="定义接口不规范"><a href="#定义接口不规范" class="headerlink" title="定义接口不规范"></a>定义接口不规范</h4><ul>
<li>hagendaza项目，定义一个HdOrderManager接口，没有继承基类<code>BaseManager</code>，无法实现<code>读写分离</code></li>
</ul>
]]></content>
      <tags>
        <tag>problem</tag>
      </tags>
  </entry>
  <entry>
    <title>MapStruct</title>
    <url>/2019/06/18/md/tool/MapStruct/</url>
    <content><![CDATA[<h3 id="MapStruct-一个-Java-实体映射工具"><a href="#MapStruct-一个-Java-实体映射工具" class="headerlink" title="MapStruct 一个 Java 实体映射工具"></a>MapStruct 一个 Java 实体映射工具</h3><p>一个成熟的工程中，尤其是现在的分布式系统中，应用与应用之间，还有单独的应用细分模块之后，DO 一般不会让外部依赖，对象与对象之间的互相转换，就需要有一个专门用来解决转换问题的工具</p>
<h3 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mapstruct.version</span>&gt;</span>1.2.0.Final<span class="tag">&lt;/<span class="name">mapstruct.version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PesonMapper</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> PersonModel <span class="title">mapEighteen</span><span class="params">( Person entity)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  <span class="keyword">if</span> (entity.getName.equals(<span class="number">18</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		   <span class="keyword">return</span> map(entity);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Mapping</span>(target = <span class="string">"personName"</span>, source = <span class="string">"name"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Mapping</span>(target = <span class="string">"hand"</span>,  ignore = <span class="keyword">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PersonModel <span class="title">map</span><span class="params">( Person entity)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">protected</span> <span class="keyword">abstract</span>  List&lt;PersonModel &gt; map(List&lt; Person&gt; entity);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云oss缩略图</title>
    <url>/2019/06/18/md/tool/oss/</url>
    <content><![CDATA[<h4 id="OSS是使用通过URL尾部的参数指定图片的缩放大小"><a href="#OSS是使用通过URL尾部的参数指定图片的缩放大小" class="headerlink" title="OSS是使用通过URL尾部的参数指定图片的缩放大小"></a>OSS是使用通过URL尾部的参数指定图片的缩放大小</h4><p>图片路径后面拼接如下路径：<br>?x-oss-process=image/[处理类型],x_100,y_50[宽高等参数]</p>
<p>?x-oss-process=image/resize,m_fill,h_高度,w_宽度,limit_0</p>
<p>示例：</p>
<p>原图：<br><a href="http://qunxianghui-upload.oss-cn-hangzhou.aliyuncs.com/upload/image/20180829/84cb48ea3923c827481787b8877f9260.jpeg" target="_blank" rel="noopener">http://qunxianghui-upload.oss-cn-hangzhou.aliyuncs.com/upload/image/20180829/84cb48ea3923c827481787b8877f9260.jpeg</a></p>
<p>缩略图：（注意：复制下面链接到浏览器中访问，直接点击可能后面参数带不过去）<br><a href="http://qunxianghui-upload.oss-cn-hangzhou.aliyuncs.com/upload/image/20180829/84cb48ea3923c827481787b8877f9260.jpeg?x-oss-process=image/resize,m_fill,h_100,w_200" target="_blank" rel="noopener">http://qunxianghui-upload.oss-cn-hangzhou.aliyuncs.com/upload/image/20180829/84cb48ea3923c827481787b8877f9260.jpeg?x-oss-process=image/resize,m_fill,h_100,w_200</a></p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>spring事务</title>
    <url>/2019/06/18/md/part/spring/spring-trac/</url>
    <content><![CDATA[<h3 id="Spring声明式事务七种传播行为"><a href="#Spring声明式事务七种传播行为" class="headerlink" title="Spring声明式事务七种传播行为"></a>Spring声明式事务七种传播行为</h3><ul>
<li>REQUIRES_NEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。  </li>
<li>NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对<code>DataSourceTransactionManager</code>事务管理器起效。</li>
<li>REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。<strong>这是spring默认的传播行为</strong>。</li>
<li>MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出异常。</li>
<li>SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。</li>
<li>NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。</li>
<li>NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。</li>
</ul>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2019/06/18/md/part/spring/spring/</url>
    <content><![CDATA[<h1 id="Bean注解修饰带参数方法时，参数取值"><a href="#Bean注解修饰带参数方法时，参数取值" class="headerlink" title="@Bean注解修饰带参数方法时，参数取值"></a>@Bean注解修饰带参数方法时，参数取值</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> RabbitAdmin <span class="title">rabbitAdmin</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		System.out.println(String.format(<span class="string">"-----------getRabbitAdmin:%s"</span>, connectionFactory.hashCode()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RabbitAdmin(connectionFactory);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如上，有参数connectFactory，若spring容器中只有一个ConnectionFactory 类型的bean，则不论参数取名为何都是按类型取bean ConnectionFactory 为参数，若有多个则参数取名必须为多个bean中的一个，否则报错。</p>
<p>spring：容器<br>核心：依赖注入和控制反转<br>Spring有两个核心接口：BeanFactory和ApplicationContext<br>bean之间不用new object，解耦。由spring容易管理。在需要时，注入<br>@autowire @component @controller @service等注解，通过scan标签扫描。<br>管理bean和bean，模块和模块之间的关系。</p>
<h3 id="bean生成"><a href="#bean生成" class="headerlink" title="bean生成"></a>bean生成</h3><p>xml配置文件bean -&gt; BeanDefinition对象-&gt;保存在beanFactory的ConcurrentHashMap(通过BeanDefinitionRegistry)</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>eureka</title>
    <url>/2019/06/18/md/part/microServices/eureka/eureka/</url>
    <content><![CDATA[<p>Eureka Server采用的是Peer to Peer对等通信。这是一种去中心化的架构，无master/slave区分，每一个Peer都是对等的。<br>在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。</p>
<p>Eureka注册中心的作用很大的程度是作用于<code>服务发现</code>和<code>服务心跳</code>，在多个注册中心的时候,依赖于zuul的负载均衡,保证异常的服务停止,正常的服务加载,保证服务的稳定性。</p>
<p>Eureka能够通过心跳检查、客户端缓存等机制，确保了系统的高可用性。</p>
<p>默认配置，Eureka Server在90s没有得到客户端的心跳，则注销该实例，同时Eureka 有自我保护机制（防止本身不可用，而干掉可用服务），通过在Eureka Server配置参数，<br>可启动保护机制它的工作原理是：当Eureka Server节点在短时间内丢失过多的客户端时（可能发送了网络故障），那么这个节点将进入自我保护模式，<br>不再注销任何微服务，当网络故障回复后，该节点会自动退出自我保护模式。</p>
<p>Eureka VS Zookeeper</p>
<p>在CAP理论中说道，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡</p>
<p>此Zookeeper保证的是CP, 而Eureka则是AP<br>zookeeper：当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的</p>
<h4 id="EMERGENCY-EUREKA-MAY-BE-INCORRECTLY-CLAIMING-INSTANCES-ARE-UP-WHEN-THEY’RE-NOT-RENEWALS-ARE-LESSER-THAN-THRESHOLD-AND-HENCE-THE-INSTANCES-ARE-NOT-BEING-EXPIRED-JUST-TO-BE-SAFE"><a href="#EMERGENCY-EUREKA-MAY-BE-INCORRECTLY-CLAIMING-INSTANCES-ARE-UP-WHEN-THEY’RE-NOT-RENEWALS-ARE-LESSER-THAN-THRESHOLD-AND-HENCE-THE-INSTANCES-ARE-NOT-BEING-EXPIRED-JUST-TO-BE-SAFE" class="headerlink" title="EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE."></a>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一般出现此模式时，服务返回错误。即如果真实的服务已经Down掉，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 但在注册中心界面服务却一直存在，且显示为UP状态，关掉自我保护模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">eureka.server.enable-self-preservation</span> = <span class="string">false</span></span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>spring cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>spring cloud各组件介绍</title>
    <url>/2019/06/18/md/part/microServices/spring%20cloud/spring%20Cloud%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="主要组成如下："><a href="#主要组成如下：" class="headerlink" title="主要组成如下："></a>主要组成如下：</h3><p>　　服务发现——Netflix Eureka                      服务调用——Netflix Feign<br>　　熔断器——Netflix Hystrix                          服务网关——Netflix Zuul<br>　　分布式配置——Spring Cloud Config         消息总线 —— Spring Cloud Bus</p>
<h3 id="服务发现组件：eureka"><a href="#服务发现组件：eureka" class="headerlink" title="服务发现组件：eureka"></a>服务发现组件：eureka</h3><p>eureka client注册到eureka服务端上，不管服务提供者还是服务消费者都要注册。<br>eureka服务端和客户端有心跳机制，默认30秒。90秒没有收到，就会剔除掉这个客户端。<br>服务消费者客户端上有服务注册表缓存，eureka服务端down之后，也能找到服务提供者。</p>
<hr>
<h3 id="客户端负载均衡组件：ribbon"><a href="#客户端负载均衡组件：ribbon" class="headerlink" title="客户端负载均衡组件：ribbon"></a>客户端负载均衡组件：ribbon</h3><p>三种方式：<code>轮循</code>，<code>随机</code>，<code>根据响应时间加权</code><br>默认策略是<code>轮循</code>。<br>可以自定义<br>eureka包含有ribbon的jar包</p>
<hr>
<h3 id="feign：命名式的http-client"><a href="#feign：命名式的http-client" class="headerlink" title="feign：命名式的http client"></a>feign：命名式的http client</h3><p>整合了ribbon和eureka    支持springMVC的注解<br>包含feign encoder ，feign decoder，feign contract</p>
<hr>
<h3 id="hystrix：断路器和超时机制的组件"><a href="#hystrix：断路器和超时机制的组件" class="headerlink" title="hystrix：断路器和超时机制的组件"></a>hystrix：断路器和超时机制的组件</h3><p>没有保护应用会导致雪崩效应<br>超时机制<br>断路器模式：依赖的服务有大量超时，不去请求，快速失败<br>断路器状态：关闭，打开，断开<br>打开，直接返回状态不可用<br>半开，尝试请求，成功率达标，断路器关闭，反之打开<br>关闭，正常请求</p>
<p>1.监控，总共请求多少次，有多少失败，失败率达到标准，断路器打开<br>2.断路器状态<br>3.半开时，分流<br>4.自我修复，断路器状态切换</p>
<p>当对特定服务呼叫，hystrix默认5秒钟失败20次，打开断路器<br>回退机制，fallback，可以由开发人员提供<br>health indicator健康指标<br>hystrix.stream 监控</p>
<p>turbine 监控整个集群</p>
<hr>
<p>zuul 实现比较好的api gateway<br>反向代理所有注册在eureka上的服务</p>
<p>Sidecar 支持使用其他语言的微服务</p>
<hr>
<h3 id="spring-cloud-config统一管理微服务配置的组件"><a href="#spring-cloud-config统一管理微服务配置的组件" class="headerlink" title="spring cloud config统一管理微服务配置的组件"></a>spring cloud config统一管理微服务配置的组件</h3><p>集中管理<br>动态调整<br>不同环境不同配置<br>自动刷新<br>config server<br>连上GIT </p>
<p>config client<br>获取git上的配置</p>
<hr>
<p>spring cloud bus<br>基于mq<br>trace追踪</p>
]]></content>
      <tags>
        <tag>spring cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>endPoint</title>
    <url>/2019/06/18/md/part/spring/springboot/endPoint/</url>
    <content><![CDATA[<h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p>SpringBoot的Endpoint主要是用来监控应用服务的运行状况，并集成在Mvc中提供查看接口</p>
<hr>
<h3 id="内置Endpoint"><a href="#内置Endpoint" class="headerlink" title="内置Endpoint"></a>内置Endpoint</h3><ul>
<li>HealthEndpoint 监控dist和db的状态</li>
<li>MetricsEndpoint 监控内存与gc的状况</li>
</ul>
]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot 运行方式</title>
    <url>/2019/06/18/md/part/spring/springboot/spring-boot-test/</url>
    <content><![CDATA[<h4 id="springboot-运行"><a href="#springboot-运行" class="headerlink" title="springboot 运行"></a>springboot 运行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> jar方式运行   -D 参数必须在jar前面指定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">java -jar -Dserver.port=8081 spring-boot-test-service-0.0.1-SNAPSHOT.jar</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> spring-boot plugin 运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mvn spring-boot:run -Dspring-boot.run.arguments='--spring.profiles.active=pro'</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mvn spring-boot:run -Dspring-boot.run.profiles=pro</span></pre></td></tr></table></figure>

<h4 id="springboot中的配置文件server-context-path不起作用"><a href="#springboot中的配置文件server-context-path不起作用" class="headerlink" title="springboot中的配置文件server.context-path不起作用"></a>springboot中的配置文件server.context-path不起作用</h4><p>因为spring boot版本问题导致的！！现在用的比较新的版本在2.0以上！以前是1.0-2.0之间的.server.context-path=/XXXXX</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/XXXXX  # 2.0以上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">server.context-path</span>=<span class="string">/XXXXX          #  2.0以下</span></span></pre></td></tr></table></figure>
<hr>
<h4 id="springboot无法完成变量从pom到-properties文件自动替换的问题"><a href="#springboot无法完成变量从pom到-properties文件自动替换的问题" class="headerlink" title="springboot无法完成变量从pom到.properties文件自动替换的问题"></a>springboot无法完成变量从pom到.properties文件自动替换的问题</h4><p>我在maven的pom文件中进行了多环境变量配置，引用了maven-resources-plugin，在application.properties文件中通过以下配置指定不同环境下的配置文件，</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span> = <span class="string">$&#123;profiles.active&#125;</span></span></pre></td></tr></table></figure>

<p>但是${profiles.active}无法从pom文件中获取变量值替换</p>
<blockquote>
<p>由于<code>${}</code>方式会被maven处理。如果你pom继承了<code>spring-boot-starter-parent</code>，Spring<br>Boot已经将maven-resources-plugins默认的<code>${}</code>方式改为了<code>@@</code>方式，如<code>@name@</code></p>
</blockquote>
<p>spring:<br>  profiles:<br>    active: @spring.profile.active@</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;spring.profile.active&gt;sit&lt;&#x2F;spring.profile.active&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;properties&gt;</span></pre></td></tr></table></figure>


<p>如果还想继续使用${}占位符方式，只需要在pom文件中加上下面配置即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">useDefaultDelimiters</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useDefaultDelimiters</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># #tag.tagid，不能使用 #&#123;tag.tagid&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = ARTICLES_CACHE_NAME, key = <span class="string">"'findArtileByTag'+#tag.tagId+#page+#limit+#status"</span>)</span></pre></td></tr></table></figure>

<p>较新版的Spring Boot取消了@<code>SpringApplicationConfiguration</code>这个注解，用<code>@SpringBootTest</code>就可以了</p>
<h4 id="spring-boot全局排除jar"><a href="#spring-boot全局排除jar" class="headerlink" title="spring-boot全局排除jar"></a>spring-boot全局排除jar</h4><p>项目里使用了log4j2做日志处理，要排除掉Spring Boot 很多jar里边默认依赖的日志包spring-boot-starter-logging。一个一个写依赖排除也可以，<br>但是太繁琐了，经过尝试，只让它依赖个<code>spring-boot-starter-logging</code>的空壳，里边的东西全部排除掉即可。使用下边的方式就可以达到想要的效果。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局排除spring-boot-starter-logging内的所有依赖--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>eq</title>
    <url>/2019/06/18/md/life/eq/</url>
    <content><![CDATA[<ul>
<li>感知他人情绪的能力。</li>
<li>控制自己情绪的能力。</li>
<li>目标和行为的高度统一</li>
</ul>
<p>感受到对方的表情变化，并及时调整自己的说话思维方式，这才是正确的反馈</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>缩写</title>
    <url>/2019/06/18/md/other/%E7%BC%A9%E5%86%99/</url>
    <content><![CDATA[<h1 id="UAT-SIT-QAS-DEV-PET"><a href="#UAT-SIT-QAS-DEV-PET" class="headerlink" title="UAT SIT QAS DEV PET"></a>UAT SIT QAS DEV PET</h1><ul>
<li><code>SIT</code>: System Integrate Test的缩写，即系统整合测试 </li>
<li><code>QAS</code>: Quality Assurance system　质量保证 </li>
<li><code>DEV</code>: Development 开发 </li>
<li><code>PET</code>: Performance Evaluation Test　性能测试</li>
</ul>
<p><strong>QPS</strong>：<code>Queries Per Second</code>意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。<br><strong>TPS</strong>：是<code>TransactionsPerSecond</code>的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>适应社会而磨平棱角吗</title>
    <url>/2019/06/18/md/life/thinking/%E9%80%82%E5%BA%94%E7%A4%BE%E4%BC%9A%E8%80%8C%E7%A3%A8%E5%B9%B3%E6%A3%B1%E8%A7%92%E5%90%97/</url>
    <content><![CDATA[<h4 id="如果成长就是向世界妥协，你愿意为了适应社会而磨平棱角吗？"><a href="#如果成长就是向世界妥协，你愿意为了适应社会而磨平棱角吗？" class="headerlink" title="如果成长就是向世界妥协，你愿意为了适应社会而磨平棱角吗？"></a>如果成长就是向世界妥协，你愿意为了适应社会而磨平棱角吗？</h4><p>我也曾经以为我在妥协，后来发现我只是自说自话地感动自己罢了，就像你长大了明白你是两性生殖产生的，而不是像小时候妈妈告诉你，你是路边上捡来的。</p>
<p>这叫妥协吗……？</p>
<p>简单的来讲，套用逼乎模版，我可以说：（太长不看版）</p>
<p>1.先问是不是，再问为什么。成长是认识世界的过程，一草一木皆是世界，臭水沟是世界，乌托邦也是世界，小孩子可能只见识到世界的5%，而20岁的你可能见识到了10%，等四十不惑的时候可能到了25%，当我们悲伤逆流成河地说自己跟世界“妥协”了，你有没有想过，</p>
<p>这个宾语，所谓“世界”，你真的知道是什么吗？到底跟谁妥协的呢？美国国家妥协局？中国人民妥协部？你是在遍历了世界所有元素之后，然后说，这就是世界，我真的看透了，所以我不得不为了生存而修改自己的初心？</p>
<p>2.以大部分人的认知阅历水平，是没资格谈论自己的所谓“初心”被抹平的。你都不知道自己到底想要啥，还谈个锤子的初心？就像全中国你能够抓出来100万个创业者，连街边卖地瓜的都算，他也有梦想，他也会振振有词告诉你怎么从卖地瓜到卖坦克走向人生巅峰。</p>
<p>但这不意味着他真的拥有或者配拥有一个普遍意义上他能够驾驭的比较合理的梦想，梦想是个宏大叙事，而平头百姓烫头百姓很难说自己有资格探讨宏大叙事。就像你不能说自己看了本《时间简史》就说自己算是科学家了，你这充其量是个科晓家，少看点郭德纲吧。</p>
<p>3.私以为，很多人有这种疑问，还是因为过于“顾影自怜”+“对世界认识不到位”。就像第一点探讨的，世界就是世界，你也是世界的一部分，它不是割裂的，不是随着18岁生日的蜡烛吹灭，突然骤然忽然莫名其妙地就巨变了质变了。</p>
<p>你的所谓初心，类比一下，就好比windows系统，你中学是windows98，高中是windowsXP，大学是win8，等到成家立业可能变成了win10，难道你告诉我，“当年我像win98一样简陋的初心，当初我想当科学家，后来我成绩不好上了专科，我的梦想破灭了，我为了生存不得不跟世界妥协！”这不是很可笑吗？之所以有人能当科学家，是因为他们有资格当，而不仅仅是因为他们想当，你想当，那你就拿出证据。</p>
<p>win10之所以比前几版好使，不是它跟谁妥协了，是它更成熟了，更完善了，更适应时代了，你可以说98和XP也有很多独到之处，但是事实上，他们就是落伍了，他们也并不因为你的情怀，而变得可以亘古不变价值永恒，如果你觉得自己的初心是不可更改不可妥协的，我觉得90%的可能是你太自恋。记住，情怀，绝大多数时候，都是自恋，难道不是吗？</p>
<p>你的初恋，你念念不忘，但是关我屁事呢？我会对她/他高看一眼吗？不会。</p>
<p>你的梦想，你不能平息，但是我凭什么就得理解你呢？你爱干嘛干嘛与我无关啊。</p>
<p>先看看题主的问题：</p>
<p>在成人世界里，一直保持一颗初心和童真，怕是一件非常难的事儿吧。</p>
<blockquote>
<p>随着逐渐年长，人们总是在不停地向现实妥协，在守护心灵中的理想世界和接受世俗融入社会之间，大部分人都被迫选择了后者，世界给这种举动起了一个很好听的名儿：成长。<br>于是成长在成人世界里的含义，往往都是残酷的。<br>有的时候你会羡慕那些一直天真乐观的大孩子，因为他们就像年轻时候的自己；也会心疼那些保持初心却饱受现实摧残的「边缘人士」，也想要劝他们跟现实和解。<br>大多数时候，不是我们选择「自我阉割」，而是被生活「阉割」；很多经历促使你变得理性克制近乎冷淡、迟钝抗压近乎麻木，平滑老道近乎世故，因为这才是现在这个社会的生存之道。<br>如果可以选择的话，你会选择接受现实从而活的容易一些，还是宁愿跌跌撞撞也要永远年轻热泪盈眶?</p>
</blockquote>
<p>我是很有资格探讨这种问题的，初心，初恋，热血，激情，本愿，这些高大上的词汇，大家都有，我更有。<br>曾经中学的我，也是非常文艺的，我敢说比很多自诩文艺青年的人都更有资格，毕竟，那些熟读唐诗三百首的人，大概还是不如我这种写了诗歌300首的有资格说自己文艺吧，你行你也写呗，对吧。短篇也写了十几篇，长篇大概开了两个坑，我的理想就是去当个写手，甚至作家。我知道这条路很难，但是我想，韩寒，郭敬明，蒋方舟，这些人不都或多或少跟我有点像，他们能够成功，我为什么不能？</p>
<p>当然，这都不重要，我只是想证明，我确实有自己的初心，我也有点资格说自己有这个初心。</p>
<p>后来呢？我当然没有那么冲动，我没有辍学，我还是坚持学习，同时笔耕不辍，想着等我高考完，立马开始投稿，各种投，我写的也杂，我写诗歌，也写短篇小说，写长篇校园小说（类似于韩寒那种），也写科幻小说，我觉得自己还是挺有天赋的吧，我也觉得自己是独特的。</p>
<p>显然，我自然是四处碰壁，投稿别说拒稿，人家根本不回复你，你都以为自己是不是没有发过去。</p>
<p>另一方面，高中的时候，我一直是我们班里的前五名，万年掉不出去，我只要不自暴自弃，怎么都是前五，第一倒是少有，第二第三考过好几次，我觉得自己还是学习蛮好的吧，我觉得自己既文艺，又兼顾学业，多厉害啊。所以我觉得，我的前途是充满未知却金光灿烂的，我可以成为学霸型写手，以后那真是风光无限，美女如云……</p>
<p>然而？</p>
<p>投稿石沉大海，而且随着我在网上看各种文章，逛文学类贴吧，找所谓文字工作室（网上的小团体，收稿子卖钱那种），我才了解到，原来文字圈是这样，别说扬名立万了，现在出版社本身就不景气，你想出书也容易，几万块就可以出，然而意义何在？你说你想出名？不好意思，本来现在看书的就少，推广成本你没个上百万你根本推不出去，而且，文字圈毕竟是讲究圈子的，就像娱乐圈一样，不是你够努力够砸钱就能够混成当成炸子鸡的，你需要贵人伯乐，你需要切入点好机会……</p>
<p>这些，在最初形成我的初心的时候，我是都不知道的，所以赖谁呢？赖世界吗？</p>
<p>高考，更有意思了，我这个全班名列前茅的人只高了一本线一分，根本上不了什么正经的一本，我之前也知道我们班不是好班，但是谁知道到底放在高考的尺度下算是什么水平呢，对吧？</p>
<p>最后我们班一共才有五六个人过了一本线，最好的一个才去了青岛大学而已，这就是赤裸裸的世界，我的初心自然被打破了。</p>
<p>还是那个问题，这赖谁呢？赖世界没有给我一个我以为的预期吗？</p>
<p>难道这些不是世界本来的面目吗？投稿很难，难道不是一直都那样吗，出版业不景气，你自己不知道你赖谁呢？高考难，难道不是全中国人都该知道的吗，你以为自己学习很好，那又如何呢？大家都想考北大清华所以大家都该上吗？</p>
<p>因为你不知道，所以你就非常唯心主义的觉得，不对，这跟我想的不一样，所以世界错了，你们错了， 你们要按我说的改！</p>
<p>您是上帝吗？</p>
<p>再来看题主的话：</p>
<blockquote>
<p>随着逐渐年长，人们总是在不停地向现实妥协，在守护心灵中的理想世界和接受世俗融入社会之间，大部分人都被迫选择了后者，世界给这种举动起了一个很好听的名儿：成长。</p>
</blockquote>
<p>现实并没有变化，变化的是你而已，世俗也一直就是那样，只是你一直蹲在新手村看不见而已，大部分人当然选择后者，不然呢？就你特殊可以不去适应世界是吗？<br>进化论还不明白吗？尼安格特人怎么灭绝的？是因为他们不够强大，被我们的祖先给竞争灭绝了，你不想融入世俗，您就接受灭绝就好了，你有今天的这个肉体，全仰赖你的老祖宗积极入世。</p>
<blockquote>
<p>有的时候你会羡慕那些一直天真乐观的大孩子，因为他们就像年轻时候的自己；也会心疼那些保持初心却饱受现实摧残的「边缘人士」，也想要劝他们跟现实和解。</p>
</blockquote>
<p>一直的乐观天真，到底是一种<strong>不自知的愚昧</strong>，还是一种大无畏的乐观主义？</p>
<blockquote>
<p>大多数时候，不是我们选择「自我阉割」，而是被生活「阉割」</p>
</blockquote>
<p>文艺青年总喜欢说这种玄了吧唧的废话，我当年就是这样——自我阉割也好，被别人阉割也好，本质上是为了融入世界，你完全可以不融入，死掉就好咯，就这么简单。何况，所谓“自我阉割”，到底是自己越来越有逼数，越来越不那么狂妄愚昧，还是真的你一个天选之子不得不屈服于浮尘俗世？</p>
<p>丑小鸭不屈服于群体，那是因为人家基因里就是天鹅，你要是鸭子怎么办？</p>
<p>换句话说，你是选择主动认错，还是被别人揍一顿之后被教做人？</p>
<blockquote>
<p>很多经历促使你变得理性克制近乎冷淡、迟钝抗压近乎麻木，平滑老道近乎世故，因为这才是现在这个社会的生存之道。</p>
</blockquote>
<p>很多人以为变得理性就是变得迟钝，变得博学就是变得麻木，不好意思，我们家是县城的，我们家是做生意的，我从小到大就见识了太多底层家庭，底层人民，我还算是知道普罗大众的精神面貌和认知水平的，从农村的工人大爷，到城里的穷苦泼妇，从学校的天真中产，到大学的官富二代。</p>
<p>难道天真就意味着不迟钝？难道愚昧就意味着活力四射？</p>
<p>就像当年那个充满激情，满脑子未来憧憬的自己，我不知道投稿有多难，我不知道自己作品水平没那么好，我不知道自己高考就那么回事，我甚至也不知道自己到底多丑多帅……</p>
<p>所以当年那个我，就是所谓“不冷淡，不麻木，不圆滑不世故”的好青年了？</p>
<p>你当然可以说当年的自己是充满热血的，但是这不意味着中二少年就是值得敬佩的，这充其量，是人生的一个阶段，就像小处男夜夜幻想着美女的胴体，然后过了几年有了孩子反而性冷淡了，你难道还能分出个优劣来？你就应该一辈子都跟个小处男一样，像个泰迪一样看着谁都想日？这就是青春永驻了？这就是有意义的人生？</p>
<blockquote>
<p>如果可以选择的话，你会选择接受现实从而活的容易一些，还是宁愿跌跌撞撞也要永远年轻热泪盈眶?</p>
</blockquote>
<p>如果说我们有的选择的话，大概这句话还有点意义，<br>就像当初的我，我可以选择留在国内，按部就班来毕业找工作，考国家电网或者公务员，也可以选择出国留学充满未知和机遇，走一条比较艰险的路。</p>
<p>但是要说“跌跌撞撞也要永远年轻热泪盈眶”这就太符合我一开始说的，“自我感动”“不自知不自觉”“顾影自怜”，不要觉得我无情，毕竟，本人自己就非常中二过，我也有资格说自己追梦吧，你们有本事也写几百首诗然后投稿啊挣扎啊，别光口嗨啊对吧？我好歹真的去做了。</p>
<p>所以恰恰因为这样，我才认识到自己当初多么狂妄，多么自恋，多么无知。</p>
<p>这个世界不是给你准备的，你不是主角，你只是75亿人里面的一个罢了。</p>
<p>成长本质上就是越来越认识这个世界的面貌，越来越熟悉里面的规则，你会觉得这些东西残酷，那是因为，当你在父母的庇护下的时候，你不需要考虑这些——但不意味着这些不存在，因为当时——是你的父母在考虑这些，不是你。当你成为父母的时候，你的孩子也会一样，心安理得地造梦，觉得世界是他自己的，所有人都该围着他转，有这种心态这很正常，但是你不能一辈子都这样，这也不是对的。</p>
<p>所以总而言之，我们幻想出一个“棱角”来取悦自己的内心，让自己以为曾经，自己也是个勇士也是英雄，只是俗世逼自己一个大人物妥协，这个心态很常见，但是它是不靠谱的，你也根本就是普普通通的人罢了，你根本没有什么牛逼闪闪的“棱角”，被什么巨兽恶魔所打磨，你只是越来越有逼数了，越来越认识到自己在这个社会里的位置，世界到底是什么样子，你修正自己的航线，是为了不至于撞冰山撞死，而不是什么伟大的“壮士断腕”，</p>
<p>说难听点，你当年的梦想，一文不值。就像我当年的梦想，一文不值，但是这并不妨碍我继续前进，不然，也没有我今天知乎上的这个答案对吧？</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>centos设置</title>
    <url>/2019/06/18/md/part/system/linux/centos/</url>
    <content><![CDATA[<h4 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h4><p>修改/etc/sysconfig/network-scripts/ifcfg-ens33  文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">BOOTPROTO</span>=<span class="string">static</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">IPADDR</span>=<span class="string">192.168.85.135</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">GATEWAY</span>=<span class="string">192.168.85.2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">NETMASK</span>=<span class="string">255.255.255.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">DNS1</span>=<span class="string">192.168.85.2</span></span></pre></td></tr></table></figure>
<hr>
<h4 id="Linux下查看网关方法："><a href="#Linux下查看网关方法：" class="headerlink" title="Linux下查看网关方法："></a>Linux下查看网关方法：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route -n</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ip route show</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">第一行就是自己的默认网关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">traceroute www.prudentwoo.com -s 100 </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">netstat -r</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">more /etc/network/interfaces  #Debian/Ubuntu Linux</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">more /etc/sysconfig/network-scripts/ifcfg-eth0 #Red Hat</span></pre></td></tr></table></figure>
<hr>
<h4 id="如果报未找到ifconfig命令"><a href="#如果报未找到ifconfig命令" class="headerlink" title="如果报未找到ifconfig命令"></a>如果报未找到ifconfig命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装net-tools</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install net-tools  -y</span></pre></td></tr></table></figure>


<h4 id="Centos-7-更改为中国时区和时间同步"><a href="#Centos-7-更改为中国时区和时间同步" class="headerlink" title="Centos 7 更改为中国时区和时间同步"></a>Centos 7 更改为中国时区和时间同步</h4><h5 id="SSH-登录-VPS，执行-date-可以获取-VPS-当前时间，如：Tue-Sep-4-11-50-16-CST-2018"><a href="#SSH-登录-VPS，执行-date-可以获取-VPS-当前时间，如：Tue-Sep-4-11-50-16-CST-2018" class="headerlink" title="SSH 登录 VPS，执行 date 可以获取 VPS 当前时间，如：Tue Sep 4 11:50:16 CST 2018"></a>SSH 登录 VPS，执行 date 可以获取 VPS 当前时间，如：Tue Sep 4 11:50:16 CST 2018</h5><p>执行命令更改为中国上海时区：</p>
<p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<h5 id="提示-cp-overwrite-‘-etc-localtime’-时，输入-y-按回车确认即可。"><a href="#提示-cp-overwrite-‘-etc-localtime’-时，输入-y-按回车确认即可。" class="headerlink" title="提示 cp: overwrite ‘/etc/localtime’? 时，输入 y 按回车确认即可。"></a>提示 cp: overwrite ‘/etc/localtime’? 时，输入 y 按回车确认即可。</h5><p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>cp: overwrite ‘/etc/localtime’? y</p>
<h5 id="设置时间自动同步"><a href="#设置时间自动同步" class="headerlink" title="设置时间自动同步"></a>设置时间自动同步</h5><p>yum install -y ntp<br>ntpdate us.pool.ntp.org</p>
<h5 id="设置完成后执行命令检查一下当前时间是否与当地时间一致即可："><a href="#设置完成后执行命令检查一下当前时间是否与当地时间一致即可：" class="headerlink" title="设置完成后执行命令检查一下当前时间是否与当地时间一致即可："></a>设置完成后执行命令检查一下当前时间是否与当地时间一致即可：</h5><p>date</p>
<h4 id="vmware-centos网络不通"><a href="#vmware-centos网络不通" class="headerlink" title="vmware centos网络不通"></a>vmware centos网络不通</h4><p>编辑 /etc/sysconfig/network-scripts/ifcfg-ensXXXX</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改如下值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">BOOTPROTO</span>=<span class="string">dhcp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">ONBOOT</span>=<span class="string">yes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#重启网络服务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">service</span> <span class="string">network restart</span></span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux安装软件</title>
    <url>/2019/06/18/md/part/system/linux/linux-install/</url>
    <content><![CDATA[<h3 id="设置交换分区"><a href="#设置交换分区" class="headerlink" title="设置交换分区"></a>设置交换分区</h3><p>SpringBoot多项目部署项目运行被killed解决办法，没有分配swap空间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建/home/swap这么一个分区文件。文件大小是512000个block，一般情况下1个block为1k，所以这里空间是1024M，一般是物理内存的2倍。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/home/swap bs=1024 count=1024000</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将这个分区变成swap分区。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/sbin/mkswap /home/swap</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用swap分区，使其生效</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/sbin/swapon /home/swap</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看swap分区大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">free -m</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 系统重启后swap分区会还原，解决办法：修改/etc/fstab文件，增加一行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/home/swap           swap                 swap       defaults              0 0</span></pre></td></tr></table></figure>

<h3 id="安装openJdk"><a href="#安装openJdk" class="headerlink" title="安装openJdk"></a>安装openJdk</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 必须安装带devel版本（完整jdk）</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-devel.x86_64</span></pre></td></tr></table></figure>


<h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> first install yum-utils</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install yum-utils</span></pre></td></tr></table></figure>

<p>To set up the yum repository, create the file named <code>/etc/yum.repos.d/nginx.repo</code> with the following contents:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[nginx-stable]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">nginx stable repo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">baseurl</span>=<span class="string">http://nginx.org/packages/centos/$releasever/$basearch/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">enabled</span>=<span class="string">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://nginx.org/keys/nginx_signing.key</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">[nginx-mainline]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">nginx mainline repo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">baseurl</span>=<span class="string">http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">enabled</span>=<span class="string">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://nginx.org/keys/nginx_signing.key</span></span></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> By default, the repository <span class="keyword">for</span> stable nginx packages is used. If you would like to use mainline nginx packages, run the following <span class="built_in">command</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yum-config-manager --enable nginx-mainline</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> To install nginx,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install nginx</span></pre></td></tr></table></figure>


<blockquote>
<p>目前在官网下载低于jdk1.8的java jdk的时候需要登陆，这边分享一个账号，方便下载<br><a href="mailto:2696671285@qq.com">2696671285@qq.com</a><br>密码：Oracle123</p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>peerDNS</title>
    <url>/2019/06/18/md/part/system/linux/peer-dns/</url>
    <content><![CDATA[<p>先认识一下这三个配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/hosts #：这个是最早的 hostname 对应 IP 的存档；</span></pre></td></tr><tr><td class="code"><pre><span class="line">/etc/resolv.conf #：当需要解析域名时，读取该文件获得DNS 服务器 IP；</span></pre></td></tr><tr><td class="code"><pre><span class="line">/etc/nsswitch.conf#：这个档案『决定』先使用 /etc/hosts 还是 /etc/resolv.conf 的设定！</span></pre></td></tr></table></figure>

<p>当电脑要访问一个域名时，要将域名翻译成IP地址。<br> 这个过程通常会先访问/etc/hosts，看本地是否有对应的hostname – IP记录。<br> 如果没有就去查询DNS服务器，通过/etc/resolv.conf 得到dns服务器地址。</p>
<p>当在eth接口启用DHCP后，本地resolv.conf文件将被修改，resolv.conf文件中的DNS地址将被改为从DHCP获取到的地址。这种从DHCP获得的DNS即是Peer DNS。</p>
<p>启用DHCP后即便修改/etc/resolv.conf，不久又恢复成原样。如何解决这个问题？此时，你得要在 /etc/sysconfig/network-scripts/ifcfg-eth0 等相关档案内，增加一行：『PEERDNS=no』，然后重新启动网络即可。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2019/06/18/md/part/system/linux/shell/</url>
    <content><![CDATA[<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java</title>
    <url>/2019/06/18/md/jdk/java/</url>
    <content><![CDATA[<h4 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认是升序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Collections.sort;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 降序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, Collections.reverseOrder());</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>java8</title>
    <url>/2019/06/18/md/jdk/java8/</url>
    <content><![CDATA[<h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><p> 类主要解决的问题是臭名昭著的空指针异常（<code>NullPointerException</code>）</p>
<h5 id="orElse与orElseGet"><a href="#orElse与orElseGet" class="headerlink" title="orElse与orElseGet"></a>orElse与orElseGet</h5><p>of中值不为空，则orElseGet不执行函数，而orElse一定会执行的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">B</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  System.out.println(<span class="string">"B()..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="string">"B"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String... args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  System.out.println(Optional.of(<span class="string">"A"</span>).orElse(B()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  System.out.println(Optional.of(<span class="string">"A"</span>).orElseGet(() -&gt; B()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  System.out.println(Optional.ofNullable(<span class="keyword">null</span>).orElseGet(() -&gt; B()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//执行结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">B()...</span></pre></td></tr><tr><td class="code"><pre><span class="line">A</span></pre></td></tr><tr><td class="code"><pre><span class="line">A</span></pre></td></tr><tr><td class="code"><pre><span class="line">B()...</span></pre></td></tr><tr><td class="code"><pre><span class="line">B</span></pre></td></tr></table></figure>

<hr>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt;  name=Optional.of(<span class="string">"Huang Dahui"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; upperName = name.map(String::toUpperCase);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//执行结果：  HUANG DAHUI</span></span></pre></td></tr></table></figure>

<h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Predicate&lt;Integer&gt; predicate = n -&gt; true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// n 如果存在则 test 方法返回 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"输出所有数据:"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// 传递参数 n</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      eval(list, n-&gt;<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// 如果 n%2 为 0 test 方法返回 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"输出所有偶数:"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      eval(list, n-&gt; n%<span class="number">2</span> == <span class="number">0</span> );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// 如果 n 大于 3 test 方法返回 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.println(<span class="string">"输出大于 3 的所有数字:"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      eval(list, n-&gt; n &gt; <span class="number">3</span> );</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eval</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(Integer n: list) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">if</span>(predicate.test(n)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(n + <span class="string">" "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; spuCodes = itemDetails.stream().map(ItemListByKeyOVO.ItemDetail::getCode).collect(Collectors.toList());</span></pre></td></tr></table></figure>



<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>可以看到，thenAccept和thenRun都是无返回值的。如果说thenApply是不停的输入输出的进行生产，那么thenAccept和thenRun就是在进行消耗。它们是整个计算的最后两个阶段。<br>同样是执行指定的动作，同样是消耗，二者也有区别：</p>
<p>thenAccept接收上一阶段的输出作为本阶段的输入 　　</p>
<p>thenRun根本不关心前一阶段的输出，根本不不关心前一阶段的计算结果，因为它不需要输入参数</p>
]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>file</title>
    <url>/2019/06/18/md/jdk/jdk%20File/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//文件名，包含后缀，但不包含路径 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//   /root/11.jpg   则显示 11.jpg  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">file.getName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径  完整的绝对路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//   /root/11.jpg   则显示 /root/11.jpg</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">file.getPath()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 重命名   newPath新目标文件绝对路径    </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">file.renameTo(<span class="keyword">new</span> File(newPath));</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm参数</title>
    <url>/2019/06/18/md/jdk/jvm/jvm-cfg/</url>
    <content><![CDATA[<h3 id="Java-堆内存开关"><a href="#Java-堆内存开关" class="headerlink" title="Java 堆内存开关"></a>Java 堆内存开关</h3><table>
<thead>
<tr>
<th align="center">VM 开关</th>
<th align="left">VM 开关描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-Xms</td>
<td align="left">设置JVM启动时堆的初始化大小。</td>
</tr>
<tr>
<td align="center">-Xmx</td>
<td align="left">设置堆最大值。</td>
</tr>
<tr>
<td align="center">-Xmn</td>
<td align="left">设置年轻代的空间大小，剩下的为老年代的空间大小。</td>
</tr>
<tr>
<td align="center">-XX:PermGen</td>
<td align="left">设置永久代内存的初始化大小。</td>
</tr>
<tr>
<td align="center">-XX:MaxPermGen</td>
<td align="left">设置永久代的最大值。</td>
</tr>
<tr>
<td align="center">-XX:SurvivorRatio</td>
<td align="left">提供Eden区和survivor区的空间比例。比如，如果年轻代的大小为10m并且VM开关是-XX:SurvivorRatio=2，那么将会保留5m内存给Eden区和每个Survivor区分配2.5m内存。默认比例是8。</td>
</tr>
<tr>
<td align="center">-XX:NewRatio</td>
<td align="left">提供年老代和年轻代的比例大小。默认值是2。</td>
</tr>
</tbody></table>
<h3 id="最后汇总一下JVM常见配置"><a href="#最后汇总一下JVM常见配置" class="headerlink" title="最后汇总一下JVM常见配置"></a>最后汇总一下JVM常见配置</h3><h3 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h3><p>-Xms:初始堆大小   </p>
<p>-Xmx:最大堆大小   </p>
<p>-XX:NewSize=n:设置年轻代大小</p>
<p>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</p>
<p>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</p>
<p>-XX:MaxPermSize=n:设置持久代大小</p>
<h4 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h4><p>-XX:+UseSerialGC:设置串行收集器</p>
<p>-XX:+UseParallelGC:设置并行收集器</p>
<p>-XX:+UseParalledlOldGC:设置并行年老代收集器</p>
<p>-XX:+UseConcMarkSweepGC:设置并发收集器</p>
<h4 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h4><p>-XX:+PrintGC  </p>
<p>-XX:+PrintGCDetails  </p>
<p>-XX:+PrintGCTimeStamps  </p>
<p>-Xloggc:filename</p>
<h4 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h4><p>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</p>
<p>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</p>
<p>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p>
<h4 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h4><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</p>
<p>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
<h3 id="Tomcat运行jvm参数"><a href="#Tomcat运行jvm参数" class="headerlink" title="Tomcat运行jvm参数"></a>Tomcat运行jvm参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xms256m -Xmx512m -XX:MaxNewSize=256m -XX:MaxPermSize=256m</span></pre></td></tr></table></figure>

<h3 id="jdk版本变更中jvm内存结构变化"><a href="#jdk版本变更中jvm内存结构变化" class="headerlink" title="jdk版本变更中jvm内存结构变化"></a>jdk版本变更中jvm内存结构变化</h3><p>永久代的工作从JDK 1.7就开始了。JDK 1.7中，存储在永久代的部分数据就已经转移到Java Heap或者Native Heap。但永久代仍存在于JDK 1.7中，并没有完全移除，<br>符号引用(Symbols)转移到了native heap；<br>字面量(interned strings)转移到了Java heap；<br>类的静态变量(class statics)转移到了Java heap。</p>
<p><em>Java8之后的变化：</em></p>
<ul>
<li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li>
<li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li>
<li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li>
<li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li>
</ul>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发</title>
    <url>/2019/06/18/md/part/project/%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="首先要了解高并发的的瓶颈在哪里？"><a href="#首先要了解高并发的的瓶颈在哪里？" class="headerlink" title="首先要了解高并发的的瓶颈在哪里？"></a>首先要了解高并发的的瓶颈在哪里？</h2><h3 id="前端性能优化技术"><a href="#前端性能优化技术" class="headerlink" title="前端性能优化技术"></a>前端性能优化技术</h3><ol>
<li><p>前端负载均衡: DNS，CDN</p>
</li>
<li><p>减少前端链接数: 把js打成一个文件，把css也打成一个文件，把图标也打成一个文件，用css分块展示。把链接数减到最低。</p>
</li>
<li><p>减少网页大小增加带宽:尽量少用图片</p>
</li>
<li><p>前端页面静态化: 静态化一些不常变的页面和数据</p>
</li>
<li><p>优化查询: redis缓存</p>
</li>
</ol>
<hr>
<h3 id="后端性能优化技术"><a href="#后端性能优化技术" class="headerlink" title="后端性能优化技术"></a>后端性能优化技术</h3><ol>
<li><p>数据冗余: 减少表连接这样的开销比较大的操作，优化sql语句</p>
</li>
<li><p>数据镜像: 把一台数据库的负载均分到多台上，同时又保证了数据一致性(Oracle的SCN)。最重要的是，这样还可以有高可用性，一台废了，还有另一台在服务</p>
</li>
<li><p>数据分区</p>
<ul>
<li>把数据把某种逻辑来分类: 把一张表拆成多张有一样的字段但是不同种类的表</li>
<li>把数据按字段分，也就是竖着分表: 把一些不经常改的数据放在一个表里，经常改的数据放在另外多个表里。把一张表变成1对1的关系</li>
<li>平均分表: 通过主键ID的范围来分表。</li>
<li>同一数据分区: 把同一商品的库存值分到不同的服务器上，然后负载均衡</li>
</ul>
</li>
<li><p>后端系统负载均衡: 需要一个任务分配系统，其还能监控各个服务器的负载情况。</p>
</li>
<li><p>异步、 throttle 和 批量处理: 把一堆基本相同的请求批量处理,大家同时购买同一个商品，没有必要你买一个我就写一次数据库，完全可以收集到一定数量的请求，一次操作一个是作业量，另一个是timeout</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose</title>
    <url>/2019/06/18/md/part/docker/docker%20compose/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> -o /usr/local/bin/docker-compose</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker相关问题</title>
    <url>/2019/06/18/md/part/docker/docker%20problem/</url>
    <content><![CDATA[<h5 id="docker-WARNING-IPv4-forwarding-is-disabled-解决方法"><a href="#docker-WARNING-IPv4-forwarding-is-disabled-解决方法" class="headerlink" title="docker WARNING: IPv4 forwarding is disabled. 解决方法"></a>docker WARNING: IPv4 forwarding is disabled. 解决方法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">般情况下，我们的linux机器的ip forwarding选项都是关闭的。 但是如果我们的机器需要做网关，或路由器。那么这个就要打开了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">echo net.ipv4.ip_forward=1 &gt;&gt; /usr/lib/sysctl.d/00-system.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl restart network &amp;&amp; systemctl restart docker</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看是否修改成功</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2019/06/18/md/part/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>Docker</code> 是一个开源的轻量级容器管理<code>引擎</code>，可以轻松的为任<br>何应用创建一个轻量级的、可移植的、自给自足的容器</p>
<ul>
<li>简化程序</li>
<li>避免选择恐惧症</li>
<li>节省开支</li>
</ul>
<h4 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a><strong>创建镜像</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> docker commit -m " add hdh.log file" -a="hdh"  48f1dac1ceb9  mqiy/ubuntu:v0.01</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -m:提交的描述信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -a:指定镜像作者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 48f1dac1ceb9：容器ID</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mqiy/ubuntu:v0.01:指定要创建的目标镜像名   v0.01 tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行新建镜像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> docker run -t -i mqiy/ubuntu:v0.01</span></pre></td></tr></table></figure>

<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run ubuntu:15.10   --name hdh0.01  /bin/echo "Hello world"</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker: Docker 的二进制执行文件。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run:与前面的 docker 组合来运行一个容器。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库Docker Hub  下载公</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 共镜像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /bin/<span class="built_in">echo</span> <span class="string">"Hello world"</span>: 在启动的容器里执行的命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以上命令完整的意思：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/<span class="built_in">echo</span> <span class="string">"Hello world"</span>，然后输出结果。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d 开启Daemon模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --name hdh0.01 容器名称</span></span></pre></td></tr></table></figure>

<h5 id="运行交互式的容器"><a href="#运行交互式的容器" class="headerlink" title="运行交互式的容器"></a>运行交互式的容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -t:在新容器内指定一个伪终端或终端。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -i:允许你对容器内的标准输入 (STDIN) 进行交互。</span></span></pre></td></tr></table></figure>

<h5 id="启动容器（后台模式）"><a href="#启动容器（后台模式）" class="headerlink" title="启动容器（后台模式）"></a>启动容器（后台模式）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d ubuntu:15.10 /bin/sh -c "while true; do echo hello world; sleep 1; done"</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d 开启Daemon模式</span></span></pre></td></tr></table></figure>

<h4 id="关闭容器"><a href="#关闭容器" class="headerlink" title="关闭容器"></a>关闭容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop contain_id | name</span></pre></td></tr></table></figure>


<h4 id="docker查看日志"><a href="#docker查看日志" class="headerlink" title="docker查看日志"></a>docker查看日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --since="2018-03-31" --tail=100 elastic_raman</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> –since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -f : 表示查看实时日志 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">　-t : 查看日志产生的日期 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -tail=200 : 查看最后的200条日志。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sleepy_snyder 容器的名称，并不是镜像的名字</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">：执行docker ps命令可以看到docker容器列表，NAMES即为容器名，而不是image</span></span></pre></td></tr></table></figure>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container ls -a</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker container rm   XX  #   XX 为CONTAINER ID or NAMES</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker挂载目录</title>
    <url>/2019/06/18/md/part/docker/docker%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h4 id="关于Docker目录挂载的总结"><a href="#关于Docker目录挂载的总结" class="headerlink" title="关于Docker目录挂载的总结"></a>关于Docker目录挂载的总结</h4><ul>
<li><p>容器目录不可以为相对路径</p>
</li>
<li><p>宿主机目录如果不存在，则会自动生成</p>
</li>
<li><p>宿主机的目录如果为相对路径(实际上对路径指的是/var/lib/docker/volumes/，与宿主机的当前目录无关)</p>
</li>
<li><p>在容器内修改了目录的属主和属组，那么对应的挂载点会修改，容器销毁了，新建的挂载目录不会消失</p>
</li>
</ul>
<p>挂载宿主机已存在目录后，在容器内对其进行操作，报“Permission denied”。</p>
<p>1&gt; 关闭selinux。</p>
<p>2&gt; 以特权方式启动容器  指定–privileged参数</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker运行mariadb</title>
    <url>/2019/06/18/md/part/docker/mariadb/</url>
    <content><![CDATA[<h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  --privileged --name mariadb   -d --restart=always -e TIMEZONE=Asis/Shanghai -e MYSQL_ROOT_PASSWORD=Admin123# -e SERVER_ID=1 -v /docker/mariadb/dbdata:/var/lib/mysql  -p 3306:3306  mariadb:10.4.5 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">参数说明:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">--privileged 赋予容器扩展权限(root)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置--restart=always 参数的时候， 设置了此参数容器退出了会自动重启， 宿主机重启了容器也能自动重启           </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">-d后台运行 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">TIMEZONE 设置时区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">MYSQL_ROOT_PASSWORD 设置root密码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">-v  /opt/data/mariadb/dbdata:/var/lib/mysql:/var/lib/mysql  将mariadb里面的目录（/var/lib/mysql）挂载到宿主机里面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 设置 utf-8字符集和排序规则</span></span></pre></td></tr></table></figure>


<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建用户</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> sonar <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--授权</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'sonar@localhost'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span><span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'Admin123#'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> sonar <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'sonar'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">-- mariadb 开启远程连接权限</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> root@<span class="string">"%"</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">"Admin123#"</span>;  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--指定编码创建db</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> sonar <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--备份数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mysqldump -uroot -p <span class="comment">--all-database &gt; bk.sql</span></span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>docker</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Dockerfile创建镜像</title>
    <url>/2019/06/18/md/part/docker/%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>在Dockerfile中用到的命令有</p>
<h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>​    FROM指定一个基础镜像， 一般情况下一个可用的 Dockerfile一定是 FROM 为第一个指令。至于image则可以是任何合理存在的image镜像。<br>​    FROM 一定是首个非注释指令 Dockerfile.<br>​    FROM 可以在一个 Dockerfile 中出现多次，以便于创建混合的images。<br>​    如果没有指定 tag ，latest 将会被指定为要使用的基础镜像版本。</p>
<h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><p>​    这里是用于指定镜像制作者的信息</p>
<h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>​    RUN命令将在当前image中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行Dockerfile中的下一个指令。<br>​    层级 RUN 指令和生成提交是符合Docker核心理念的做法。它允许像版本控制那样，在任意一个点，对image 镜像进行定制化构建。<br>​    RUN 指令缓存不会在下个命令执行时自动失效。比如 RUN apt-get dist-upgrade -y 的缓存就可能被用于下一个指令. –no-cache 标志可以被用于强制取消缓存使用。</p>
<h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>​    ENV指令可以用于为docker容器设置环境变量<br>​    ENV设置的环境变量，可以使用 docker inspect命令来查看。同时还可以使用docker run –env <code>key</code>=<code>value</code>来修改环境变量。</p>
<h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><p>​    USER 用来切换运行属主身份的。Docker 默认是使用 root，但若不需要，建议切换使用者身分，毕竟 root 权限太大了，使用上有安全的风险。</p>
<h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>​    WORKDIR 用来切换工作目录的。Docker 默认的工作目录是/，只有 RUN 能执行 cd 命令切换目录，而且还只作用在当下下的 RUN，也就是说每一个 RUN 都是独立进行的。如果想让其他指令在指定的目录下执行，就得靠 WORKDIR。WORKDIR 动作的目录改变是持久的，不用每个指令前都使用一次 WORKDIR。</p>
<h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>​    COPY 将文件从路径 <code>src</code> 复制添加到容器内部路径 <code>dest</code>。<br>​    <code>src</code> 必须是想对于源文件夹的一个文件或目录，也可以是一个远程的url，<code>dest</code> 是目标容器中的绝对路径。<br>​    所有的新文件和文件夹都会创建UID 和 GID 。事实上如果 <code>src</code> 是一个远程文件URL，那么目标文件的权限将会是600。</p>
<h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p>​    ADD 将文件从路径 <code>src</code> 复制添加到容器内部路径 <code>dest</code>。<br>​    <code>src</code> 必须是想对于源文件夹的一个文件或目录，也可以是一个远程的url。<code>dest</code> 是目标容器中的绝对路径。<br>​    所有的新文件和文件夹都会创建UID 和 GID。事实上如果 <code>src</code> 是一个远程文件URL，那么目标文件的权限将会是600。</p>
<h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>​    创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>
<h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>​    EXPOSE 指令指定在docker允许时指定的端口进行转发。</p>
<h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>​    Dockerfile.中只能有一个CMD指令。 如果你指定了多个，那么最后个CMD指令是生效的。<br>​    CMD指令的主要作用是提供默认的执行容器。这些默认值可以包括可执行文件，也可以省略可执行文件。<br>​    当你使用shell或exec格式时，  CMD 会自动执行这个命令。</p>
<h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><p>​    ONBUILD 的作用就是让指令延迟執行，延迟到下一个使用 FROM 的 Dockerfile 在建立 image 时执行，只限延迟一次。<br>​    ONBUILD 的使用情景是在建立镜像时取得最新的源码 (搭配 RUN) 与限定系统框架。</p>
<h5 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h5><p>​    ARG是Docker1.9 版本才新加入的指令。<br>​    ARG 定义的变量只在建立 image 时有效，建立完成后变量就失效消失</p>
<h5 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h5><p>​    定义一个 image 标签 Owner，并赋值，其值为变量 Name 的值。(LABEL Owner=$Name )</p>
<h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>​    是指定 Docker image 运行成 instance (也就是 Docker container) 时，要执行的命令或者文件。<br>​    </p>
<p>我自己的Dockerfile文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM docker.io/centos</span></pre></td></tr><tr><td class="code"><pre><span class="line">MAINTAINER The CentOS Test Images - test</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN mkdir -p /usr/app</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN ls</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN pwd</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY /jdk /usr/app/jdk/</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD tomcat/ /usr/app/tomcat/</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD hadoop/ /usr/app/hadoop/</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENV JAVA_HOME /usr/app/jdk</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ADD /soft/jdk /</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ADD /soft/tomcat /</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ADD /soft/hadoop /</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Volumes <span class="keyword">for</span> systemd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> VOLUME [<span class="string">"/run"</span>, <span class="string">"/tmp"</span>]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Environment <span class="keyword">for</span> systemd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ENV container=docker</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> For systemd usage this changes to /usr/sbin/init</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Keeping it as /bin/bash <span class="keyword">for</span> compatibility with previous</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">CMD [<span class="string">"/bin/bash"</span>]</span></span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis获取主键</title>
    <url>/2019/06/18/md/part/db/mybatis/mybatis/</url>
    <content><![CDATA[<h3 id="Mybatis-在-insert-之后想获取自增的主键-id，但却总是返回1"><a href="#Mybatis-在-insert-之后想获取自增的主键-id，但却总是返回1" class="headerlink" title="Mybatis 在 insert 之后想获取自增的主键 id，但却总是返回1"></a>Mybatis 在 insert 之后想获取自增的主键 id，但却总是返回1</h3><p>想要获取自增主键id，需要通过xx.getId()方法获取，因为在mybatis中指定自增主键id封装到了对象的属性中，所以我们需要在对象中来获取</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"add"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    INSERT INTO `user` (`name`,sex,register_ts) VALUES (#&#123;name&#125;,#&#123;sex&#125;,#&#123;registerTs&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        SELECT LAST_INSERT_ID()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>想要获取自增主键id，应该通过对象的getId()方法，而并不是insert的返回值，insert的返回值表示的是影响行数</p>
</li>
<li><p>在mapper.xml中：useGeneratedKeys=”true”、keyProperty=”id”，这两个属性的作用：</p>
<ul>
<li>共同决定了sql执行后，会将主键封装到id属性上；</li>
<li>自增主键封装到了对象的id属性上了，那么想要获取，直接调用对象的getId()方法就可以了</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>面试</title>
    <url>/2019/06/18/md/interview/interview/</url>
    <content><![CDATA[<h3 id="如何提高求职时的谈判能力？"><a href="#如何提高求职时的谈判能力？" class="headerlink" title="如何提高求职时的谈判能力？"></a>如何提高求职时的谈判能力？</h3><ol>
<li>记住你不是在展示编程技巧或者漂亮的脸蛋，而是在推销某种商业需求（增加收入或降低成本）的解决方案。</li>
<li>面试时，要有自信，要平等的对话。你的对手可能也在做同样的事情。你要的是一个互利的录用合同，不要每次对方提出要求，你都说 Yes。</li>
<li>雇主可能会问”你的上一份工资是多少”，他们其实在说”给我一个理由，压低你的报酬”。你要想好如何适当地回答这个问题。</li>
<li>要讨价还价。这里不仅仅指钱，还指其它你关心的方面。如果你无法要求更高的薪水，那就试着要求更多的假期。</li>
<li>在对方决定录用你以后，才开始讨论薪水。因为那时，他们已经在你身上，投入了大量的时间和金钱。这个时候他们说“不行，我们不能成交”会浪费很大的成本，他们会觉得一些小问题已经不值得再纠缠了，比如每年的工资增加几千元。</li>
<li>多读书吧。很多人写过谈判方面的书。我喜欢《Getting To Yes | 谈判力》这本书。有一点令人不解的是，就整个职业生涯而言，谈判技巧值得每年花费数千美元，但工程师们却认为针对这学习方面很疯狂，他们宁愿去学习感兴趣技术的细枝末节。</li>
</ol>
<h3 id="面试时一定要问清楚这4点"><a href="#面试时一定要问清楚这4点" class="headerlink" title="面试时一定要问清楚这4点"></a>面试时一定要问清楚这4点</h3><ul>
<li>试用期的工资及时间</li>
<li>考核的转正方式及薪资范围</li>
<li>工作时间和加班时间计算</li>
<li>培训和晋升机制</li>
</ul>
<h3 id="怼"><a href="#怼" class="headerlink" title="怼"></a>怼</h3><blockquote>
<p>面试会：贵公司的核心竞争性是什么，业务壁垒是什么,然后面试官没词儿了</p>
</blockquote>
<p>spring的事务传播机制<br>springmvc参数绑定原理<br>mybatis的分页原理 limit</p>
]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式编程</title>
    <url>/2019/06/18/md/other/Reactive%20Programming/</url>
    <content><![CDATA[<h4 id="响应式编程核心特征"><a href="#响应式编程核心特征" class="headerlink" title="响应式编程核心特征"></a>响应式编程核心特征</h4><ul>
<li>变化传递(propagation of change)</li>
<li>基于数据流(data stream)</li>
<li>声明式(declarative)</li>
</ul>
<h4 id="响应式流"><a href="#响应式流" class="headerlink" title="响应式流"></a>响应式流</h4><ul>
<li>异步非阻塞</li>
<li>流量控制</li>
</ul>
<blockquote>
<p>(ps Java Stream是一种同步API)</p>
</blockquote>
<p>阻塞造成的性能损失，我们通常有两种思路来解决</p>
<ol>
<li>并行化：使用更多的线程和硬件资源；</li>
<li>异步化：基于现有的资源来提高执行效率。</li>
</ol>
<p>将输入转化为输出的过程中，处理速度小于输入速度的状态称为Backpressure<br>通常处理这种状态的策略有以下三种：</p>
<p>Buffer：将输入暂时保存下来</p>
<p>Drop：丢弃掉输入</p>
<p>Control：由消费者来控制生产者的速度</p>
]]></content>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>公钥与私钥</title>
    <url>/2019/06/18/md/other/encrypt/</url>
    <content><![CDATA[<p>公钥与私钥使用，在大部分情况下</p>
<ul>
<li>我们使用公钥加密、私钥解密，</li>
<li><code>签名</code>却是使用私钥加密，公钥解密</li>
</ul>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>测试相关</title>
    <url>/2019/06/18/md/other/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h4 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h4><p>冒烟测试;<br>    冒烟测试就是先保证系统能跑的起来，不至于让测试工作做到一半突然出现错误导致业务中断。目的就是先通过最基本的测试</p>
<p>猴子测试:<br>    它针对的不是功能点，而是业务流程,就是说，你把自己看成白痴，随便乱点，没有任何主观想法参与进来，让一些想不到的操作呈现出错误来</p>
<p>数据库来说吧， 数据做了分区， 一致性怎么保证啊？   选择分布式事务非常麻烦， 有时候不得不选择最终一致性来妥协</p>
<p>迅速定位问题:</p>
<p>一是查看错误日志，推断错误的可能</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM架构和Xen架构</title>
    <url>/2019/06/18/md/other/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>简述KVM架构和Xen架构<br>暑假最后一篇更新，因为，，，明天我就回学校了。</p>
<p>以下均为个人理解，如果有不对的地方还望各位dalao不吝赐教。</p>
<p>虚拟化<br>虚拟化是通过Hypervisor程序实现的，Hypervisor的作用是将硬件虚拟化提供给多个操作系统使用，是虚拟化技术的核心。<br>虚拟化分为两种：<code>1型虚拟化</code>和<code>2型虚拟化</code>。</p>
<p>1型虚拟化是将Hypervisor直接安装在物理机上，然后虚拟机直接运行在Hypervisor上，Xen就是属于1型虚拟化。<br>2型虚拟化是先在硬件上安装操作系统，然后将Hypervisor作为系统的一个程序运行在系统上从而实现对虚拟机的管理，KVM就是属于2型虚拟化。</p>
<h4 id="KVM架构"><a href="#KVM架构" class="headerlink" title="KVM架构"></a>KVM架构</h4><p>先来看一下KVM，KVM是基于Linux内核实现的，KVM的内核模块叫做kvm.ko，实现对Linux的CPU和内存虚拟化，是Linux的一个进程，负责VCPU和内存的分配,而其他设备的虚拟就交给了qemu。<br>qemu运行在用户空间，KVM运行在内核，两者通过/dev/kvm进行交互。<br>KVM仅支持全局虚拟化。</p>
<h4 id="Xen架构"><a href="#Xen架构" class="headerlink" title="Xen架构"></a>Xen架构</h4><p>再来看一下Xen，Xen支持全虚拟化和半虚拟化，（全虚拟化就是运行在虚拟环境的虚拟机无法感知到自己是运行在虚拟环境之上，只会觉得自己是运行在硬件之上，半虚拟化是运行在虚拟环境的虚拟机可以感知到自己不是直接运行在硬件环境之上）这一点不同于KVM的仅支持全局虚拟化。Xen是直接运行在硬件上的，也就是上面提到的1型虚拟化，直接对硬件进行虚拟化，然后在硬件之上直接跑虚拟机，在Xen架构中的虚拟机分为两种：Domain0和DoaminU.Domain0又叫做特权虚拟机，具有直接访问硬件和管理其他操作系统的权限，而DoaminU就是普通的虚拟机，DoaminU不能直接访问硬件，所有的操作都是通过驱动发送到特权虚拟机Domain0，由Domain0去和硬件交互再返回给普通用户，所以，Xen架构的虚拟化需要先运行Domain0。<br>Xen架构也是对CPU和内存进行虚拟化,提供给虚拟机用，其余硬件访问是通过特权虚拟机直接与硬件进行交互再返回的。<br>默认Domain0VCPU和内存的大小是这样计算的：</p>
<p>Domain0的VCPU = 物理设备线程数 % 10然后向上取最小的一个偶数，就是Domain0的VCPU数。<br>Domain0的内存：如果物理设备的内存小于96G，那么就默认为8G,如果物理机的内存大于96G，那么Domain0的内存 = 物理机内存 *0.05 + 8G。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/2019/06/18/md/part/distributed/Distributed/</url>
    <content><![CDATA[<p><code>通信渠道的不可靠</code>（超时等）是造成构建大规模分布式系统非常复杂并且困难的重要原因。</p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>docker运行redis</title>
    <url>/2019/06/18/md/part/docker/redis/</url>
    <content><![CDATA[<h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  --privileged  --name redis -v /docker/redis/data:/data  -p  6379:6379 -d redis:5.0.5  redis-server --appendonly yes</span></pre></td></tr></table></figure>





<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#客户端连 redis</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">redis-cli.exe -h <span class="number">192.168</span>.<span class="number">85.135</span> -p <span class="number">6379</span></span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>consul介绍</title>
    <url>/2019/06/18/md/part/microServices/consul/</url>
    <content><![CDATA[<p>consul是分布式的、高可用、横向扩展的（CP）。consul提供的一些关键特性：</p>
<ul>
<li>service discovery：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。</li>
<li>health checking：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。</li>
<li>key/value storage：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。</li>
<li>multi-datacenter：无需复杂的配置，即可支持任意数量的区域。</li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式与装饰模式区别</title>
    <url>/2019/06/18/md/develop/base/pattern/pattern/</url>
    <content><![CDATA[<p>代理模式主要是<code>控制对某个特定对象访问</code>，而装饰模式主要是为了<code>给对象添加行为</code></p>
<p>代理模式和装饰模式非常类似，甚至代码都类似。二者最主要的区别是：</p>
<ul>
<li>代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。</li>
<li>而装饰模式中，装饰类对代理对象<code>没有控制权</code>，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>docker运行sonarqube</title>
    <url>/2019/06/18/md/part/docker/sonarqube/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name sonarqube \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -e sonar.jdbc.username=sonar \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -e sonar.jdbc.password=sonar \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -e sonar.jdbc.url=jdbc:mariadb://localhost:3306/sonar \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -p 9000:9000 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -v /path/to/conf:/opt/sonarqube/conf \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -v /path/to/data:/opt/sonarqube/data \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -v /path/to/logs:/opt/sonarqube/logs \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -v /path/to/extensions:/opt/sonarqube/extensions \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sonarqube:6.7.7-community;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx介绍</title>
    <url>/2019/06/18/md/part/web/http/nginx/</url>
    <content><![CDATA[<h4 id="配置出错"><a href="#配置出错" class="headerlink" title="配置出错"></a>配置出错</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启nginx</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">nginx -s reload</span></pre></td></tr><tr><td class="code"><pre><span class="line">nginx: [emerg] unexpected "&#125;" in /etc/nginx/nginx.conf:79</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">A: 行尾没带分号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">检查修改的nginx.conf配置是否正确</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">nginx -t</span></pre></td></tr></table></figure>



<h4 id="upstream与ip-hash"><a href="#upstream与ip-hash" class="headerlink" title="upstream与ip_hash"></a>upstream与ip_hash</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># upstream 负载均衡</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> firstdemo &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment"># ip_hash  粘性IP  相当一段时间，只会跟第一访问sever</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ip_hash;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">#  同一个url（也就是同一个资源请求）会到达同一台机器,配合缓存命中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">hash</span> <span class="variable">$request_uri</span>;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">server</span> <span class="number">39.106.145.33</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">server</span> <span class="number">47.93.6.93</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Ip_hash机制缺陷:</p>
<ul>
<li>ip_hash要求nginx一定是最前端的服务器,否则nginx得不到正确ip,就不能根据ip作hash.    Eg: 使用的是squid为最前端.那么nginx取ip时只能得到squid的服务器ip地址,用这个地址来作分流肯定是错乱的</li>
<li>假如nginx后端还有其它负载均衡,将请求又通过另外的方式分流了,那么某个客户端的请求肯定不能定位到同一台session应用服务器上,这么算起来,nginx后端只能直接指向应用服务器,或者再搭一人squid,然后指向应用服务器. 最好 的办法是用location作一次分流,将需要session的部分请求通过ip_hash分流,剩下的走其它后端去.</li>
</ul>
<h4 id="常规示例"><a href="#常规示例" class="headerlink" title="常规示例"></a>常规示例</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">server_name</span>  www.mqiy.xyz ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">auth_basic</span> <span class="literal">off</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">location</span> / &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">proxy_pass</span>    http://10.10.10.10:20186;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">60</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">proxy_send_timeout</span> <span class="number">600</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>IK分词使用</title>
    <url>/2018/03/27/md/part/mid/es/es-example/</url>
    <content><![CDATA[<p>curl -XPOST <a href="http://192.168.85.143:9200/index/_mapping" target="_blank" rel="noopener">http://192.168.85.143:9200/index/_mapping</a> -H ‘Content-Type:application/json’ -d’<br>{<br>        “properties”: {<br>            “content”: {<br>                “type”: “text”,<br>                “analyzer”: “ik_max_word”,<br>                “search_analyzer”: “ik_smart”<br>            }<br>        }</p>
<p>}’</p>
<p>curl -XPOST <a href="http://192.168.85.143:9200/index/_create/1" target="_blank" rel="noopener">http://192.168.85.143:9200/index/_create/1</a> -H ‘Content-Type:application/json’ -d’<br>{“content”:”美国留给伊拉克的是个烂摊子吗”}’</p>
<p>curl -XPOST <a href="http://192.168.85.143:9200/index/_create/2" target="_blank" rel="noopener">http://192.168.85.143:9200/index/_create/2</a> -H ‘Content-Type:application/json’ -d’<br>{“content”:”公安部：各地校车将享最高路权”}<br>‘<br>curl -XPOST <a href="http://192.168.85.143:9200/index/_create/3" target="_blank" rel="noopener">http://192.168.85.143:9200/index/_create/3</a> -H ‘Content-Type:application/json’ -d’<br>{“content”:”中韩渔警冲突调查：韩警平均每天扣1艘中国渔船”}<br>‘<br>curl -XPOST <a href="http://192.168.85.143:9200/index/_create/4" target="_blank" rel="noopener">http://192.168.85.143:9200/index/_create/4</a> -H ‘Content-Type:application/json’ -d’<br>{“content”:”中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首”}<br>‘</p>
<p>‘<br>curl -XPOST <a href="http://192.168.85.143:9200/index/_create/5" target="_blank" rel="noopener">http://192.168.85.143:9200/index/_create/5</a> -H ‘Content-Type:application/json’ -d’<br>{“content”:”我是中国人”}’</p>
<p>curl -XPOST <a href="http://192.168.85.143:9200/index/_search?pretty" target="_blank" rel="noopener">http://192.168.85.143:9200/index/_search?pretty</a>  -H ‘Content-Type:application/json’ -d’<br>{<br>    “query” : { “match” : { “content” : “中国” }},<br>    “highlight” : {<br>        “pre_tags” : [“<tag1>“, “<tag2>“],<br>        “post_tags” : [“</tag1>“, “</tag2>“],<br>        “fields” : {<br>            “content” : {}<br>        }<br>    }<br>}<br>‘</p>
<p>curl -XPOST <a href="http://192.168.85.143:9200/index/_search?pretty" target="_blank" rel="noopener">http://192.168.85.143:9200/index/_search?pretty</a>  -H ‘Content-Type:application/json’ -d’<br>{<br>    “query” : { “match” : { “content” : “渔船” }},<br>    “highlight” : {<br>        “pre_tags” : [“<tag1>“, “<tag2>“],<br>        “post_tags” : [“</tag1>“, “</tag2>“],<br>        “fields” : {<br>            “content” : {}<br>        }<br>    }<br>}<br>‘</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
</search>
